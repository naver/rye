#line 2 "../../src/parser/rsql_lexer.c"

#line 4 "../../src/parser/rsql_lexer.c"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define yy_create_buffer rsql_yy_create_buffer
#define yy_delete_buffer rsql_yy_delete_buffer
#define yy_flex_debug rsql_yy_flex_debug
#define yy_init_buffer rsql_yy_init_buffer
#define yy_flush_buffer rsql_yy_flush_buffer
#define yy_load_buffer_state rsql_yy_load_buffer_state
#define yy_switch_to_buffer rsql_yy_switch_to_buffer
#define yyin rsql_yyin
#define yyleng rsql_yyleng
#define yylex rsql_yylex
#define yylineno rsql_yylineno
#define yyout rsql_yyout
#define yyrestart rsql_yyrestart
#define yytext rsql_yytext
#define yywrap rsql_yywrap
#define yyalloc rsql_yyalloc
#define yyrealloc rsql_yyrealloc
#define yyfree rsql_yyfree

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5
#define YY_FLEX_SUBMINOR_VERSION 35
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;
#endif /* ! C99 */

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#endif /* ! FLEXINT_H */

#ifdef __cplusplus

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else /* ! __cplusplus */

/* C99 requires __STDC__ to be defined as 1. */
#if defined (__STDC__)

#define YY_USE_CONST

#endif /* defined (__STDC__) */
#endif /* ! __cplusplus */

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start) - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE rsql_yyrestart(rsql_yyin  )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#define YY_BUF_SIZE 16384
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

extern int rsql_yyleng;

extern FILE *rsql_yyin, *rsql_yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

#define YY_LESS_LINENO(n)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up rsql_yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = (yy_hold_char); \
		YY_RESTORE_YY_MORE_OFFSET \
		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up rsql_yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, (yytext_ptr)  )

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
{
  FILE *yy_input_file;

  char *yy_ch_buf;              /* input buffer */
  char *yy_buf_pos;             /* current position in input buffer */

  /* Size of input buffer in bytes, not including room for EOB
   * characters.
   */
  yy_size_t yy_buf_size;

  /* Number of characters read into yy_ch_buf, not including EOB
   * characters.
   */
  int yy_n_chars;

  /* Whether we "own" the buffer - i.e., we know we created it,
   * and can realloc() it to grow it, and should free() it to
   * delete it.
   */
  int yy_is_our_buffer;

  /* Whether this is an "interactive" input source; if so, and
   * if we're using stdio for input, then we want to use getc()
   * instead of fread(), to make sure we stop fetching input after
   * each newline.
   */
  int yy_is_interactive;

  /* Whether we're considered to be at the beginning of a line.
   * If so, '^' rules will be active on the next match, otherwise
   * not.
   */
  int yy_at_bol;

  int yy_bs_lineno;   /**< The line count. */
  int yy_bs_column;   /**< The column count. */

  /* Whether to try to fill the input buffer when we reach the
   * end of it.
   */
  int yy_fill_buffer;

  int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
  /* When an EOF's been seen but there's still some text to process
   * then we mark the buffer as YY_EOF_PENDING, to indicate that we
   * shouldn't try reading from the input source any more.  We might
   * still have a bunch of tokens to match, though, because of
   * possible backing-up.
   *
   * When we actually see the EOF, we change the status to "new"
   * (via rsql_yyrestart()), so that the user can continue scanning by
   * just pointing rsql_yyin at a new input file.
   */
#define YY_BUFFER_EOF_PENDING 2

};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
static YY_BUFFER_STATE *yy_buffer_stack = 0;  /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                          : NULL)

/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when rsql_yytext is formed. */
static char yy_hold_char;
static int yy_n_chars;          /* number of characters read into yy_ch_buf */
int rsql_yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 0;         /* whether we need to initialize */
static int yy_start = 0;        /* start state number */

/* Flag which is used to allow rsql_yywrap()'s to do buffer switches
 * instead of setting up a fresh rsql_yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void rsql_yyrestart (FILE * input_file);
void rsql_yy_switch_to_buffer (YY_BUFFER_STATE new_buffer);
YY_BUFFER_STATE rsql_yy_create_buffer (FILE * file, int size);
void rsql_yy_delete_buffer (YY_BUFFER_STATE b);
void rsql_yy_flush_buffer (YY_BUFFER_STATE b);
void rsql_yypush_buffer_state (YY_BUFFER_STATE new_buffer);
void rsql_yypop_buffer_state (void);

static void rsql_yyensure_buffer_stack (void);
static void rsql_yy_load_buffer_state (void);
static void rsql_yy_init_buffer (YY_BUFFER_STATE b, FILE * file);

#define YY_FLUSH_BUFFER rsql_yy_flush_buffer(YY_CURRENT_BUFFER )

YY_BUFFER_STATE rsql_yy_scan_buffer (char *base, yy_size_t size);
YY_BUFFER_STATE rsql_yy_scan_string (yyconst char *yy_str);
YY_BUFFER_STATE rsql_yy_scan_bytes (yyconst char *bytes, int len);

void *rsql_yyalloc (yy_size_t);
void *rsql_yyrealloc (void *, yy_size_t);
void rsql_yyfree (void *);

#define yy_new_buffer rsql_yy_create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        rsql_yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            rsql_yy_create_buffer(rsql_yyin,YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}

#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        rsql_yyensure_buffer_stack (); \
		YY_CURRENT_BUFFER_LVALUE =    \
            rsql_yy_create_buffer(rsql_yyin,YY_BUF_SIZE ); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}

#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

typedef unsigned char YY_CHAR;

FILE *rsql_yyin = (FILE *) 0, *rsql_yyout = (FILE *) 0;

typedef int yy_state_type;

extern int rsql_yylineno;

int rsql_yylineno = 1;

extern char *rsql_yytext;
#define yytext_ptr rsql_yytext

static yy_state_type yy_get_previous_state (void);
static yy_state_type yy_try_NUL_trans (yy_state_type current_state);
static int yy_get_next_buffer (void);
static void yy_fatal_error (yyconst char msg[]);

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up rsql_yytext.
 */
#define YY_DO_BEFORE_ACTION \
	(yytext_ptr) = yy_bp; \
	rsql_yyleng = (size_t) (yy_cp - yy_bp); \
	(yy_hold_char) = *yy_cp; \
	*yy_cp = '\0'; \
	(yy_c_buf_p) = yy_cp;

#define YY_NUM_RULES 446
#define YY_END_OF_BUFFER 447
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
{
  flex_int32_t yy_verify;
  flex_int32_t yy_nxt;
};
static yyconst flex_int16_t yy_accept[1725] = { 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 447, 445,
  1, 2, 445, 413, 406, 402, 412, 445, 445, 445,
  404, 404, 445, 445, 445, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 414, 445, 415, 445, 425, 424, 416, 446, 426,
  417, 418, 419, 427, 420, 428, 421, 429, 422, 430,
  423, 1, 399, 406, 444, 393, 405, 443, 442, 405,
  404, 0, 0, 0, 400, 397, 395, 396, 401, 398,

  406, 406, 406, 406, 406, 406, 406, 16, 20, 406,
  410, 406, 406, 406, 406, 30, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 136, 406, 406, 406, 406, 406,
  153, 406, 157, 175, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 409, 214, 406,
  406, 220, 406, 406, 406, 232, 235, 406, 239, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,

  406, 406, 406, 406, 406, 406, 406, 346, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 411, 406, 406, 406, 392, 394, 425, 431, 440,
  441, 439, 437, 438, 434, 435, 436, 426, 427, 432,
  428, 429, 430, 433, 0, 405, 405, 0, 405, 0,
  405, 407, 408, 403, 406, 406, 406, 6, 406, 9,
  406, 406, 13, 406, 15, 17, 406, 406, 406, 22,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 43, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 77, 82,

  406, 406, 406, 406, 406, 406, 406, 98, 406, 406,
  406, 406, 406, 406, 107, 406, 108, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 129,
  406, 406, 406, 406, 131, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 177, 406, 406, 406, 406, 406,
  182, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 196, 406, 406, 406, 212, 406, 406, 406, 213,
  208, 406, 406, 406, 406, 406, 406, 406, 406, 225,
  406, 406, 406, 406, 233, 406, 406, 406, 241, 406,

  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 263, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 284, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 303, 406, 406, 406, 406, 406, 406, 311, 406,
  406, 406, 406, 327, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 365, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 388, 406, 406, 0, 405, 0, 405,
  0, 405, 405, 406, 406, 406, 406, 406, 406, 406,

  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  28, 406, 406, 406, 406, 35, 36, 406, 406, 70,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 60, 406, 406, 406, 406, 406, 406, 71,
  102, 406, 406, 406, 406, 406, 406, 406, 406, 91,
  406, 406, 406, 406, 406, 406, 100, 406, 104, 105,
  406, 406, 406, 406, 114, 406, 406, 406, 406, 406,
  127, 406, 406, 406, 406, 123, 124, 406, 406, 406,
  406, 137, 406, 406, 406, 406, 406, 406, 148, 149,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,

  406, 406, 406, 174, 406, 406, 179, 180, 181, 406,
  183, 406, 186, 406, 406, 406, 190, 406, 192, 406,
  194, 195, 197, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 215, 406, 406, 406, 219, 406,
  406, 406, 224, 228, 406, 406, 406, 406, 236, 406,
  406, 406, 406, 406, 406, 246, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 259, 260,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 280, 406, 406, 406,
  286, 406, 406, 406, 406, 406, 406, 406, 406, 406,

  406, 406, 406, 406, 406, 406, 306, 406, 308, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 341, 342, 354,
  406, 406, 406, 406, 406, 353, 356, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 366, 406, 406, 406,
  406, 406, 406, 406, 377, 406, 379, 380, 406, 406,
  384, 386, 406, 389, 391, 0, 405, 406, 406, 406,
  406, 8, 406, 11, 406, 406, 406, 19, 406, 406,
  406, 406, 406, 406, 406, 31, 406, 406, 406, 406,
  406, 406, 42, 44, 46, 406, 406, 406, 406, 406,

  406, 406, 406, 406, 61, 406, 63, 406, 406, 69,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 90, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 126, 119, 120, 128, 406, 122, 406, 406, 406,
  133, 134, 406, 138, 140, 406, 144, 145, 406, 406,
  406, 406, 406, 406, 159, 406, 406, 406, 166, 167,
  168, 406, 406, 406, 406, 406, 406, 406, 406, 187,
  406, 189, 191, 193, 198, 199, 406, 406, 406, 406,
  406, 406, 406, 406, 211, 406, 406, 218, 406, 406,

  406, 406, 229, 406, 406, 406, 406, 406, 406, 240,
  242, 406, 406, 245, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 258, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  278, 279, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 304,
  305, 406, 309, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 338, 406, 406, 406, 406, 347,
  406, 406, 406, 406, 358, 406, 368, 406, 406, 406,

  363, 364, 367, 369, 406, 406, 406, 406, 406, 406,
  406, 406, 382, 383, 406, 387, 406, 406, 4, 5,
  406, 406, 406, 406, 406, 406, 406, 24, 25, 406,
  406, 406, 406, 406, 406, 38, 406, 406, 406, 406,
  406, 50, 52, 406, 406, 406, 406, 406, 62, 406,
  68, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 89, 406, 406, 406, 406, 406,
  99, 103, 406, 106, 406, 110, 111, 112, 406, 116,
  406, 406, 406, 406, 406, 132, 135, 139, 142, 406,
  143, 146, 147, 406, 406, 154, 406, 406, 406, 406,

  406, 163, 164, 406, 169, 406, 406, 406, 406, 155,
  406, 406, 406, 406, 406, 406, 406, 406, 204, 406,
  209, 210, 406, 406, 406, 406, 406, 226, 406, 230,
  406, 234, 406, 238, 243, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  266, 406, 268, 269, 406, 406, 406, 406, 406, 275,
  277, 406, 282, 406, 285, 406, 288, 406, 290, 291,
  292, 406, 295, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 320,
  321, 337, 406, 406, 406, 406, 334, 406, 406, 406,

  339, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 360, 406, 362, 370, 406, 406, 406, 406, 406,
  406, 378, 406, 406, 406, 406, 7, 406, 12, 14,
  406, 406, 23, 406, 27, 29, 406, 33, 37, 406,
  41, 45, 406, 48, 406, 51, 406, 406, 406, 406,
  58, 406, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 83, 84, 406, 86, 406, 406, 406, 406,
  406, 406, 406, 406, 109, 406, 115, 117, 118, 121,
  406, 130, 406, 406, 406, 406, 406, 161, 406, 406,
  406, 406, 178, 406, 406, 406, 406, 406, 188, 200,

  406, 202, 406, 406, 406, 406, 217, 221, 406, 406,
  227, 406, 406, 406, 406, 248, 406, 250, 406, 406,
  406, 254, 406, 256, 257, 261, 406, 406, 406, 406,
  406, 272, 406, 406, 276, 406, 283, 406, 406, 406,
  294, 406, 406, 406, 406, 301, 307, 310, 406, 312,
  406, 406, 406, 406, 406, 406, 406, 406, 406, 325,
  406, 329, 406, 331, 406, 406, 406, 343, 406, 355,
  406, 406, 406, 352, 406, 406, 361, 406, 374, 406,
  376, 371, 406, 406, 385, 406, 3, 10, 406, 406,
  406, 32, 34, 406, 47, 406, 406, 406, 406, 57,

  406, 406, 72, 406, 76, 74, 75, 81, 406, 406,
  406, 406, 406, 88, 406, 406, 406, 406, 96, 406,
  406, 125, 406, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 173, 406, 185, 184, 406, 406, 406,
  406, 207, 216, 406, 406, 406, 406, 244, 406, 249,
  251, 406, 253, 406, 406, 406, 267, 406, 406, 273,
  274, 281, 406, 289, 406, 406, 406, 298, 406, 406,
  336, 313, 406, 315, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 328, 330, 406, 406, 348, 406,
  406, 357, 406, 406, 375, 372, 381, 406, 18, 21,

  406, 39, 49, 53, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 406, 85, 406, 406, 406, 406, 406,
  406, 101, 113, 406, 406, 406, 406, 156, 158, 406,
  162, 165, 170, 171, 176, 201, 406, 406, 406, 406,
  406, 406, 406, 406, 252, 406, 262, 406, 406, 406,
  406, 287, 406, 296, 297, 406, 406, 406, 406, 406,
  317, 318, 406, 406, 406, 406, 326, 406, 406, 406,
  340, 406, 406, 350, 406, 406, 373, 406, 26, 406,
  54, 55, 406, 406, 406, 406, 406, 406, 80, 79,
  87, 92, 406, 94, 95, 406, 406, 406, 406, 406,

  406, 406, 406, 406, 406, 222, 223, 406, 406, 247,
  255, 264, 406, 270, 271, 406, 406, 406, 406, 406,
  316, 319, 322, 406, 406, 406, 406, 406, 406, 406,
  406, 406, 406, 390, 406, 56, 406, 406, 406, 406,
  406, 406, 93, 97, 406, 406, 152, 151, 406, 406,
  203, 406, 406, 406, 406, 265, 406, 299, 406, 406,
  406, 323, 324, 333, 335, 406, 406, 406, 349, 351,
  359, 406, 406, 64, 65, 67, 73, 406, 141, 406,
  160, 172, 406, 406, 231, 237, 406, 300, 302, 314,
  332, 406, 406, 40, 59, 406, 406, 406, 406, 206,

  406, 344, 406, 406, 406, 406, 406, 406, 406, 406,
  78, 406, 406, 406, 345, 66, 150, 406, 406, 406,
  406, 205, 293, 0
};

static yyconst flex_int32_t yy_ec[256] = { 0,
  1, 1, 1, 1, 1, 1, 1, 1, 2, 3,
  1, 1, 2, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 2, 4, 5, 6, 1, 7, 1, 8, 1,
  1, 9, 10, 1, 11, 12, 13, 14, 15, 16,
  16, 16, 16, 16, 16, 16, 16, 17, 1, 18,
  19, 20, 21, 1, 22, 23, 24, 25, 26, 27,
  28, 29, 30, 31, 32, 33, 34, 35, 36, 37,
  38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 1, 51, 52, 22, 53, 24, 25,

  26, 27, 28, 29, 30, 31, 32, 33, 34, 54,
  36, 37, 38, 55, 40, 56, 42, 43, 44, 57,
  46, 47, 1, 58, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,

  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1
};

static yyconst flex_int32_t yy_meta[59] = { 0,
  1, 1, 2, 1, 3, 4, 1, 5, 1, 1,
  1, 1, 1, 6, 6, 6, 1, 1, 1, 1,
  1, 6, 6, 6, 6, 6, 6, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
  4, 4, 4, 4, 4, 4, 4, 1, 7, 8,
  4, 9, 6, 4, 4, 4, 4, 1
};

static yyconst flex_int16_t yy_base[1740] = { 0,
  0, 0, 56, 57, 58, 59, 60, 66, 67, 68,
  74, 75, 78, 79, 69, 70, 82, 83, 2307, 2308,
  2304, 2308, 2286, 2308, 0, 2308, 2308, 76, 74, 82,
  85, 113, 74, 83, 2287, 120, 110, 148, 156, 167,
  184, 189, 86, 145, 126, 2277, 128, 205, 210, 230,
  211, 2260, 256, 271, 285, 240, 85, 232, 90, 2275,
  2264, 2308, 2264, 2308, 2240, 0, 2308, 2289, 315, 0,
  2308, 2308, 2288, 0, 2290, 0, 2289, 0, 2308, 0,
  2241, 2290, 2308, 0, 2308, 2308, 315, 2308, 2308, 318,
  323, 336, 95, 0, 2308, 2271, 2308, 2308, 2308, 2308,

  2250, 127, 2264, 152, 163, 108, 143, 279, 160, 2260,
  2308, 199, 320, 207, 2261, 0, 319, 341, 135, 375,
  78, 158, 2262, 235, 354, 346, 217, 2249, 2247, 2259,
  342, 107, 2240, 2257, 375, 2247, 316, 351, 2243, 365,
  2242, 2244, 383, 2240, 321, 220, 2224, 2231, 2251, 2230,
  225, 2237, 416, 357, 2227, 2239, 2232, 2221, 388, 2244,
  405, 256, 430, 404, 204, 367, 401, 2308, 428, 2236,
  253, 441, 320, 2233, 323, 2236, 0, 437, 2237, 347,
  2235, 384, 449, 425, 2220, 455, 2237, 390, 483, 2230,
  2227, 450, 2213, 473, 518, 280, 388, 2219, 2232, 2220,

  474, 445, 2212, 283, 487, 2225, 480, 0, 503, 2228,
  511, 422, 524, 527, 2223, 2215, 2221, 111, 430, 448,
  2216, 2308, 483, 2223, 473, 2308, 2308, 0, 2308, 2308,
  2308, 2308, 2308, 2308, 2308, 2308, 2308, 0, 0, 2308,
  0, 0, 0, 2308, 553, 2308, 561, 569, 2308, 533,
  575, 486, 0, 2308, 2208, 2217, 2212, 2216, 2214, 2203,
  2212, 2204, 0, 2207, 0, 0, 2209, 517, 523, 0,
  2190, 2203, 2210, 2180, 2197, 2200, 2206, 2198, 2204, 568,
  2203, 558, 2200, 0, 2183, 2182, 2188, 266, 2186, 560,
  526, 555, 551, 2197, 2178, 567, 2184, 582, 2165, 587,

  593, 2189, 569, 2190, 2185, 2185, 594, 0, 2189, 305,
  2173, 2176, 2179, 2181, 0, 582, 0, 2184, 2183, 2178,
  2179, 2162, 2168, 584, 2160, 2175, 2172, 2157, 2174, 2169,
  592, 2160, 2160, 2166, 0, 158, 342, 2155, 593, 2148,
  599, 2159, 606, 594, 2146, 2161, 597, 604, 2135, 597,
  2159, 2142, 2141, 614, 615, 2140, 2148, 2158, 609, 610,
  621, 2151, 615, 2138, 623, 616, 2151, 2150, 2145, 617,
  2142, 0, 2136, 2146, 2147, 2140, 2139, 508, 2135, 556,
  632, 619, 2141, 635, 2144, 626, 2143, 646, 2138, 0,
  2130, 2136, 2135, 2134, 2119, 624, 2128, 2131, 643, 640,

  2130, 2129, 659, 2114, 2113, 2122, 659, 650, 2117, 646,
  2122, 661, 2107, 2106, 2121, 2120, 2123, 2108, 2121, 648,
  663, 661, 2100, 2105, 2111, 2107, 664, 651, 669, 2112,
  2111, 2099, 2099, 659, 669, 2108, 2093, 2110, 2089, 2100,
  2089, 0, 667, 669, 2098, 2101, 670, 2093, 692, 689,
  2100, 219, 694, 0, 696, 2091, 2086, 679, 692, 2096,
  2075, 709, 439, 703, 2080, 2083, 705, 696, 2096, 2091,
  2088, 701, 713, 2073, 730, 2070, 2071, 2080, 716, 2078,
  2081, 2077, 708, 0, 719, 2082, 763, 770, 777, 2308,
  780, 784, 2308, 2074, 2066, 2069, 2082, 720, 2079, 727,

  2056, 2071, 734, 2076, 2069, 2072, 726, 751, 2064, 2070,
  0, 2070, 2068, 2069, 2070, 0, 0, 2058, 2062, 779,
  2057, 2048, 2061, 2060, 2063, 2050, 2053, 2056, 761, 2051,
  2054, 2053, 0, 762, 764, 2038, 2051, 2040, 2049, 781,
  771, 781, 2040, 2051, 2046, 2029, 768, 768, 2041, 774,
  779, 2043, 2032, 2037, 2036, 2032, 0, 2034, 0, 2033,
  2016, 2028, 2023, 2022, 2016, 775, 2035, 2034, 2029, 2025,
  0, 784, 785, 2023, 2027, 0, 2011, 789, 795, 809,
  2028, 0, 795, 2012, 802, 812, 804, 2022, 0, 1996,
  2013, 2020, 2018, 797, 2019, 2009, 2011, 804, 804, 805,

  808, 2018, 827, 0, 2006, 2016, 0, 0, 0, 2007,
  0, 1994, 0, 2009, 2004, 2007, 0, 1999, 0, 811,
  0, 0, 0, 809, 2002, 1996, 1987, 2002, 1997, 816,
  2004, 1998, 1991, 1994, 0, 1986, 823, 830, 0, 1997,
  826, 835, 0, 732, 835, 1996, 832, 1993, 0, 841,
  837, 840, 1976, 1984, 841, 0, 1982, 1985, 1970, 1983,
  843, 1982, 1985, 1988, 1979, 1972, 845, 1981, 0, 0,
  1976, 842, 848, 848, 850, 1962, 1970, 1975, 1980, 1979,
  1972, 855, 859, 1967, 859, 1972, 0, 879, 1967, 1954,
  0, 1958, 1960, 1967, 1959, 1967, 869, 1960, 1965, 1958,

  869, 1961, 1964, 1955, 1959, 866, 0, 1950, 0, 871,
  1949, 1945, 874, 877, 1958, 1949, 900, 1952, 874, 879,
  1955, 884, 1954, 739, 909, 1949, 1938, 0, 0, 900,
  1943, 1946, 1938, 1930, 1941, 0, 0, 1944, 1941, 1932,
  902, 1923, 1928, 897, 900, 1937, 0, 1934, 1935, 1930,
  1930, 1936, 1927, 904, 0, 1922, 0, 1929, 1928, 1927,
  1916, 0, 1925, 1899, 0, 943, 946, 1907, 1908, 910,
  907, 0, 1925, 0, 1899, 1902, 910, 0, 893, 1918,
  911, 1897, 1916, 1919, 913, 0, 1910, 1914, 1902, 1911,
  1912, 1909, 0, 1908, 0, 1893, 927, 935, 930, 1908,

  933, 939, 936, 1891, 0, 1904, 0, 941, 939, 0,
  1907, 936, 1898, 957, 1891, 1896, 1899, 1902, 941, 1889,
  1889, 943, 1895, 0, 1890, 1883, 945, 950, 952, 955,
  1892, 1893, 1889, 1878, 1874, 1887, 958, 960, 1872, 1881,
  1886, 0, 0, 0, 0, 1881, 0, 1884, 1885, 1879,
  0, 0, 1872, 1864, 962, 1876, 0, 0, 1874, 964,
  909, 1868, 1870, 1865, 979, 1876, 981, 1875, 0, 0,
  0, 967, 975, 1870, 972, 1862, 970, 1860, 1871, 0,
  982, 0, 0, 0, 0, 0, 1850, 1857, 979, 1850,
  1863, 1855, 1841, 1860, 0, 985, 1863, 0, 1855, 1840,

  1839, 1854, 0, 1850, 984, 1828, 986, 1848, 989, 0,
  0, 990, 1855, 0, 1850, 1853, 1838, 1833, 1842, 1831,
  989, 993, 1837, 994, 1843, 0, 1835, 1827, 1840, 1828,
  1834, 1837, 1836, 1839, 997, 1836, 998, 1829, 1006, 1832,
  0, 0, 1835, 1819, 1010, 1821, 1818, 1831, 1801, 1818,
  1821, 1824, 1812, 1006, 1010, 1825, 1014, 1813, 1809, 0,
  0, 1822, 0, 1817, 1812, 1816, 1015, 1816, 1817, 1016,
  1805, 1803, 1796, 1795, 1785, 1797, 1783, 1016, 1019, 1020,
  1777, 1776, 1784, 1772, 1761, 1020, 1753, 1756, 1028, 0,
  1749, 1034, 1751, 1752, 0, 1737, 0, 1688, 1668, 1685,

  0, 0, 0, 1670, 1030, 1687, 1034, 1038, 1672, 1685,
  1680, 1662, 0, 0, 1661, 0, 1668, 1037, 0, 0,
  1675, 1038, 87, 183, 296, 343, 1042, 0, 0, 1045,
  1046, 384, 1042, 407, 422, 0, 1045, 1046, 450, 506,
  1059, 530, 1049, 1050, 666, 686, 1054, 731, 0, 1056,
  0, 768, 871, 947, 996, 1061, 1062, 1074, 1084, 1078,
  1087, 1088, 1074, 1094, 0, 1080, 1078, 1093, 1086, 1098,
  0, 0, 1101, 0, 1083, 0, 0, 1095, 1100, 0,
  1092, 1088, 1096, 1110, 1100, 0, 0, 0, 0, 1110,
  0, 0, 0, 1105, 1110, 0, 1115, 1112, 1101, 1105,

  1102, 0, 0, 1112, 0, 1123, 1109, 1123, 1129, 0,
  1122, 1123, 1126, 1127, 1122, 1127, 1119, 1134, 1110, 1120,
  0, 0, 1141, 1132, 1140, 1145, 1146, 0, 1145, 0,
  1137, 0, 1124, 0, 0, 1135, 1132, 1141, 1136, 1136,
  1140, 1148, 1136, 1134, 1155, 1156, 1144, 1159, 1155, 1151,
  0, 1144, 0, 0, 1154, 1168, 1167, 1172, 1171, 1156,
  0, 1173, 0, 1172, 0, 1170, 0, 1150, 0, 0,
  1151, 1168, 0, 1174, 1165, 1183, 1179, 1175, 1172, 1187,
  1178, 1188, 1179, 1190, 1177, 1182, 1189, 1194, 1182, 0,
  1173, 0, 1174, 1200, 1198, 1204, 1180, 1208, 1194, 1203,

  0, 1217, 1199, 1206, 1201, 1208, 1220, 1223, 1208, 1205,
  1218, 0, 1214, 0, 0, 1229, 1214, 1228, 1226, 1219,
  1224, 0, 1233, 1223, 1229, 1240, 0, 1241, 0, 0,
  1234, 1230, 0, 1244, 0, 0, 1227, 1249, 0, 1249,
  0, 0, 1250, 0, 1241, 0, 1252, 1250, 1251, 1256,
  0, 1247, 1233, 1259, 1250, 1262, 1264, 1267, 1252, 1259,
  1251, 1258, 0, 0, 1260, 0, 1273, 1272, 1257, 1259,
  1264, 1275, 1261, 1263, 0, 1267, 0, 0, 0, 0,
  1270, 0, 1270, 1275, 1285, 1271, 1276, 0, 1277, 1285,
  1289, 1297, 0, 1301, 1295, 1295, 1292, 1308, 0, 0,

  1300, 0, 1312, 1303, 1312, 1306, 0, 0, 1307, 1308,
  0, 1316, 1322, 1305, 1320, 0, 1322, 0, 1314, 1314,
  1325, 0, 1324, 0, 0, 0, 1310, 1331, 1330, 1327,
  1335, 0, 1326, 1319, 0, 1329, 0, 1327, 1312, 1330,
  0, 1322, 1330, 1341, 1322, 1319, 0, 0, 1330, 0,
  1334, 1335, 1348, 1346, 1336, 1343, 1349, 1343, 1357, 0,
  1349, 1344, 1345, 0, 1364, 1365, 1354, 0, 1368, 0,
  1367, 1355, 1357, 0, 1373, 1360, 0, 1363, 0, 1378,
  0, 0, 1368, 1367, 0, 1372, 0, 0, 1373, 1384,
  1373, 0, 0, 1373, 0, 1380, 1392, 1383, 1385, 0,

  1386, 1400, 0, 1397, 0, 0, 0, 0, 1394, 1389,
  1396, 1391, 1400, 0, 1399, 1406, 1413, 1414, 1404, 1418,
  1411, 0, 1413, 1416, 1409, 1416, 1427, 1413, 1429, 1418,
  1412, 1420, 1420, 0, 1427, 0, 0, 1422, 1428, 1436,
  1442, 0, 0, 1428, 1429, 1437, 1433, 0, 1438, 0,
  0, 1440, 0, 1453, 1454, 1456, 0, 1436, 1451, 0,
  0, 0, 1444, 0, 1457, 1462, 1451, 1441, 1473, 1454,
  0, 0, 1456, 0, 1463, 1453, 1460, 1478, 1467, 1482,
  1483, 1479, 1478, 1469, 1469, 0, 1465, 1462, 0, 1484,
  1489, 0, 1477, 1474, 0, 0, 0, 1480, 0, 0,

  1493, 1472, 0, 0, 1489, 1485, 1502, 1506, 1499, 1490,
  1480, 1492, 1508, 1510, 0, 1511, 1499, 1515, 1514, 1501,
  1508, 0, 0, 1521, 1516, 1506, 1513, 0, 0, 1522,
  0, 0, 0, 1520, 0, 0, 1516, 1519, 1529, 1529,
  1530, 1530, 1529, 1520, 0, 1521, 0, 1523, 1529, 1539,
  1540, 0, 1535, 0, 0, 1533, 1548, 1532, 1543, 1546,
  0, 0, 1535, 1539, 1543, 1537, 0, 1545, 1554, 1551,
  0, 1553, 1548, 0, 1549, 1560, 0, 1559, 0, 1549,
  0, 1550, 1561, 1551, 1560, 1569, 1545, 1571, 0, 0,
  0, 0, 1558, 0, 0, 1555, 1578, 1562, 1577, 1579,

  1575, 1570, 1583, 1576, 1574, 0, 0, 1570, 1576, 0,
  0, 0, 1585, 0, 0, 1581, 1588, 1583, 1591, 1582,
  0, 0, 0, 1582, 1594, 1595, 1583, 1589, 1588, 1595,
  1592, 1593, 1604, 0, 1604, 0, 1596, 1606, 1607, 1596,
  1583, 1612, 0, 0, 1596, 1613, 0, 0, 1596, 1605,
  0, 1612, 1608, 1615, 1610, 0, 1618, 0, 1623, 1615,
  1620, 0, 0, 0, 0, 1630, 1615, 1623, 0, 0,
  0, 1619, 1633, 1622, 0, 0, 0, 1629, 0, 1642,
  0, 0, 1627, 1643, 0, 0, 1629, 0, 0, 0,
  0, 1632, 1630, 0, 0, 1643, 1641, 1643, 1654, 0,

  1655, 0, 1641, 1649, 1659, 1650, 1662, 1664, 1663, 1664,
  0, 1666, 1656, 1657, 0, 0, 0, 1659, 1661, 1673,
  1674, 0, 0, 2308, 1715, 1724, 1733, 1742, 1751, 1760,
  1766, 1772, 1781, 1790, 1799, 1808, 1817, 1826, 1694
};

static yyconst flex_int16_t yy_def[1740] = { 0,
  1724, 1, 1725, 1725, 1726, 1726, 1726, 1726, 1725, 1725,
  1727, 1727, 1728, 1728, 1729, 1729, 1730, 1730, 1724, 1724,
  1724, 1724, 1724, 1724, 1731, 1724, 1724, 1724, 1724, 1724,
  1724, 1724, 1724, 1724, 1724, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1724, 1724, 1724, 1724, 1732, 1724, 1724, 1733, 1734,
  1724, 1724, 1724, 1735, 1724, 1736, 1724, 1737, 1724, 1738,
  1724, 1724, 1724, 1731, 1724, 1724, 1724, 1724, 1724, 1724,
  1724, 1724, 1724, 1739, 1724, 1724, 1724, 1724, 1724, 1724,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1724, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1724, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1724, 1731, 1731, 1731, 1724, 1724, 1732, 1724, 1724,
  1724, 1724, 1724, 1724, 1724, 1724, 1724, 1734, 1735, 1724,
  1736, 1737, 1738, 1724, 1724, 1724, 1724, 1724, 1724, 1724,
  1724, 1724, 1739, 1724, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1724, 1724, 1724, 1724,
  1724, 1724, 1724, 1731, 1731, 1731, 1731, 1731, 1731, 1731,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1724, 1724, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,

  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
  1731, 1731, 1731, 0, 1724, 1724, 1724, 1724, 1724, 1724,
  1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724
};

static yyconst flex_int16_t yy_nxt[2367] = { 0,
  20, 21, 22, 23, 24, 25, 26, 27, 20, 20,
  28, 29, 30, 31, 32, 32, 20, 33, 20, 34,
  35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
  45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
  55, 56, 57, 58, 59, 60, 61, 62, 63, 20,
  25, 64, 37, 49, 53, 55, 59, 65, 67, 67,
  67, 67, 67, 68, 68, 71, 71, 72, 67, 67,
  67, 67, 67, 72, 73, 73, 67, 67, 75, 75,
  67, 67, 77, 77, 67, 67, 85, 87, 87, 87,
  88, 95, 96, 97, 89, 86, 90, 222, 91, 91,

  91, 98, 99, 294, 69, 69, 214, 148, 252, 252,
  92, 149, 1229, 295, 215, 69, 69, 111, 79, 79,
  216, 150, 69, 69, 90, 223, 91, 91, 91, 262,
  316, 317, 263, 81, 81, 112, 479, 93, 92, 113,
  480, 94, 101, 102, 103, 114, 104, 155, 115, 159,
  256, 160, 105, 161, 106, 116, 285, 162, 107, 108,
  109, 156, 110, 163, 115, 157, 264, 257, 265, 117,
  286, 151, 101, 106, 107, 109, 118, 124, 152, 153,
  119, 125, 257, 120, 154, 126, 121, 579, 130, 122,
  580, 127, 259, 123, 128, 260, 296, 129, 153, 131,

  269, 132, 121, 261, 133, 136, 134, 259, 1230, 137,
  128, 135, 296, 138, 143, 269, 139, 168, 261, 140,
  132, 144, 141, 135, 145, 142, 164, 146, 377, 147,
  165, 169, 183, 170, 166, 171, 184, 378, 141, 271,
  167, 339, 275, 146, 147, 172, 185, 276, 719, 186,
  309, 173, 174, 175, 271, 340, 176, 217, 310, 345,
  218, 219, 276, 210, 177, 186, 178, 220, 179, 720,
  221, 180, 181, 182, 211, 298, 212, 188, 345, 213,
  299, 189, 174, 177, 179, 190, 221, 368, 191, 369,
  298, 192, 193, 211, 194, 370, 195, 386, 525, 196,

  197, 443, 266, 198, 199, 456, 204, 526, 200, 386,
  205, 201, 202, 206, 207, 444, 203, 231, 267, 232,
  208, 233, 232, 209, 268, 1231, 201, 556, 87, 87,
  87, 247, 247, 247, 90, 456, 91, 91, 91, 209,
  245, 246, 278, 248, 249, 250, 250, 272, 92, 251,
  251, 251, 391, 392, 273, 279, 326, 556, 280, 281,
  274, 338, 282, 394, 581, 234, 283, 305, 235, 236,
  237, 326, 306, 273, 281, 274, 338, 300, 394, 284,
  301, 314, 315, 327, 1232, 307, 302, 399, 308, 328,
  303, 356, 357, 304, 581, 284, 287, 315, 320, 379,

  321, 380, 399, 330, 322, 328, 331, 288, 289, 290,
  356, 323, 1236, 291, 292, 324, 293, 334, 401, 330,
  380, 445, 362, 335, 411, 381, 365, 363, 290, 291,
  324, 366, 1238, 336, 446, 382, 334, 401, 335, 347,
  348, 362, 349, 411, 375, 350, 469, 367, 376, 1239,
  351, 352, 353, 371, 382, 354, 355, 372, 470, 375,
  376, 383, 396, 405, 387, 373, 735, 453, 384, 351,
  481, 355, 736, 374, 388, 389, 402, 397, 454, 405,
  407, 390, 427, 384, 408, 481, 482, 403, 404, 1242,
  409, 428, 397, 429, 389, 450, 390, 453, 451, 252,

  252, 431, 482, 403, 412, 413, 414, 486, 432, 415,
  416, 433, 452, 460, 461, 417, 418, 419, 420, 421,
  457, 484, 422, 423, 462, 424, 486, 433, 452, 1243,
  628, 458, 463, 461, 466, 413, 419, 484, 423, 434,
  467, 435, 468, 458, 464, 471, 251, 251, 251, 472,
  436, 504, 437, 473, 438, 439, 440, 441, 442, 474,
  628, 505, 487, 487, 532, 475, 488, 488, 488, 1246,
  504, 437, 440, 442, 247, 247, 247, 505, 491, 491,
  532, 475, 492, 492, 492, 534, 489, 490, 251, 251,
  251, 515, 519, 516, 528, 533, 520, 630, 631, 529,

  530, 493, 531, 540, 534, 537, 538, 541, 517, 549,
  533, 519, 520, 528, 546, 530, 543, 553, 547, 544,
  561, 537, 568, 517, 549, 545, 575, 583, 585, 594,
  588, 586, 590, 595, 554, 593, 561, 597, 568, 601,
  603, 545, 589, 608, 609, 575, 583, 615, 590, 554,
  604, 593, 597, 610, 602, 613, 617, 621, 649, 634,
  611, 632, 608, 609, 636, 616, 639, 641, 652, 602,
  613, 617, 621, 633, 634, 642, 637, 649, 654, 653,
  657, 639, 662, 664, 667, 669, 678, 1249, 679, 687,
  681, 689, 665, 670, 654, 680, 688, 696, 663, 658,

  667, 682, 678, 690, 697, 705, 689, 706, 691, 698,
  710, 716, 707, 696, 658, 712, 682, 713, 721, 728,
  723, 705, 690, 706, 698, 710, 729, 1250, 737, 717,
  743, 714, 732, 722, 728, 715, 724, 738, 733, 747,
  741, 716, 742, 734, 717, 729, 725, 748, 763, 743,
  758, 724, 750, 751, 759, 747, 738, 764, 772, 752,
  781, 902, 734, 763, 981, 774, 748, 1252, 982, 758,
  759, 903, 777, 764, 772, 753, 488, 488, 488, 781,
  754, 774, 750, 488, 488, 488, 766, 766, 777, 782,
  767, 767, 767, 492, 492, 492, 246, 492, 492, 492,

  791, 801, 805, 811, 806, 782, 822, 1254, 823, 815,
  249, 813, 825, 826, 816, 839, 801, 805, 792, 806,
  817, 814, 822, 823, 844, 845, 813, 849, 825, 850,
  839, 812, 826, 811, 851, 854, 856, 857, 859, 844,
  845, 865, 869, 849, 870, 871, 872, 885, 850, 852,
  854, 884, 858, 865, 874, 856, 891, 859, 869, 870,
  871, 897, 872, 885, 852, 875, 884, 858, 898, 901,
  900, 891, 906, 904, 908, 910, 909, 897, 911, 914,
  928, 875, 900, 919, 898, 925, 929, 906, 901, 904,
  931, 910, 930, 938, 911, 914, 928, 939, 919, 941,

  925, 943, 929, 952, 930, 931, 961, 956, 976, 938,
  963, 964, 967, 939, 941, 1026, 1255, 969, 968, 977,
  944, 961, 952, 956, 979, 972, 964, 976, 967, 973,
  968, 943, 969, 983, 977, 987, 997, 1000, 1001, 979,
  1009, 974, 1094, 1010, 1020, 1026, 988, 1021, 1095, 984,
  1025, 1028, 1000, 1032, 1001, 997, 767, 767, 767, 767,
  767, 767, 1021, 1020, 984, 1025, 1028, 1041, 1032, 1042,
  1043, 1045, 490, 1046, 1047, 1050, 1053, 1051, 1055, 1061,
  1256, 1064, 1041, 1068, 1069, 1043, 1070, 1045, 1042, 1071,
  1047, 1053, 1046, 1051, 1050, 1061, 1056, 1064, 1078, 1068,

  1079, 1089, 1093, 1069, 1099, 1070, 1102, 1105, 1071, 1106,
  1111, 1108, 1090, 1078, 1109, 1079, 1114, 1117, 1093, 1123,
  1257, 1103, 1105, 1134, 1130, 1111, 1132, 1143, 1106, 1100,
  1135, 1144, 1158, 1117, 1146, 1114, 1103, 1156, 1123, 1130,
  1160, 1132, 1134, 1143, 1164, 1135, 1173, 1144, 1176, 1146,
  1174, 1158, 1156, 1183, 1186, 1207, 1194, 1195, 1202, 1160,
  1196, 1173, 1205, 1164, 1216, 1174, 1208, 1176, 1218, 1183,
  1186, 1194, 1219, 1195, 1202, 1196, 1233, 1226, 1228, 1234,
  1235, 1205, 1237, 1216, 1244, 1240, 1241, 1218, 1245, 1247,
  1248, 1219, 1226, 1228, 1251, 1233, 1253, 1237, 1234, 1235,

  1240, 1241, 1258, 1259, 1247, 1248, 1260, 1262, 1261, 1251,
  1263, 1253, 1264, 1265, 1266, 1267, 1269, 1270, 1271, 1268,
  1272, 1273, 1274, 1275, 1276, 1277, 1278, 1261, 1279, 1266,
  1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1275, 1272,
  1288, 1289, 1290, 1279, 1291, 1278, 1292, 1293, 1294, 1280,
  1295, 1296, 1297, 1298, 1299, 1300, 1301, 1290, 1302, 1303,
  1304, 1305, 1306, 1293, 1307, 1308, 1309, 1310, 1311, 1312,
  1313, 1314, 1315, 1316, 1317, 1319, 1318, 1320, 1321, 1322,
  1323, 1324, 1325, 1326, 1327, 1328, 1329, 1315, 1330, 1331,
  1317, 1318, 1332, 1333, 1334, 1335, 1336, 1337, 1325, 1338,

  1339, 1340, 1341, 1342, 1328, 1343, 1344, 1330, 1345, 1346,
  1347, 1348, 1349, 1350, 1351, 1352, 1354, 1353, 1355, 1356,
  1343, 1341, 1357, 1358, 1359, 1360, 1347, 1361, 1346, 1362,
  1363, 1349, 1353, 1364, 1365, 1354, 1366, 1357, 1367, 1368,
  1369, 1370, 1371, 1372, 1373, 1375, 1374, 1376, 1377, 1365,
  1378, 1380, 1379, 1381, 1368, 1382, 1370, 1383, 1384, 1369,
  1375, 1371, 1374, 1385, 1386, 1387, 1388, 1377, 1379, 1389,
  1390, 1391, 1392, 1393, 1394, 1395, 1396, 1397, 1385, 1398,
  1399, 1400, 1401, 1402, 1403, 1390, 1404, 1405, 1406, 1407,
  1408, 1409, 1410, 1411, 1412, 1413, 1414, 1415, 1417, 1416,

  1418, 1419, 1421, 1420, 1422, 1423, 1408, 1424, 1426, 1425,
  1428, 1427, 1415, 1412, 1416, 1429, 1419, 1417, 1420, 1407,
  1430, 1431, 1432, 1422, 1433, 1413, 1427, 1434, 1425, 1428,
  1435, 1429, 1436, 1437, 1438, 1439, 1440, 1442, 1443, 1444,
  1445, 1446, 1441, 1447, 1448, 1449, 1450, 1436, 1451, 1452,
  1453, 1454, 1455, 1438, 1456, 1457, 1458, 1459, 1460, 1461,
  1462, 1463, 1464, 1465, 1466, 1467, 1468, 1451, 1469, 1470,
  1471, 1473, 1472, 1474, 1461, 1475, 1476, 1477, 1478, 1479,
  1463, 1481, 1480, 1482, 1483, 1471, 1484, 1459, 1472, 1485,
  1486, 1476, 1487, 1488, 1489, 1490, 1477, 1491, 1492, 1483,

  1493, 1494, 1482, 1495, 1496, 1497, 1498, 1499, 1487, 1500,
  1490, 1502, 1491, 1501, 1503, 1493, 1504, 1494, 1505, 1506,
  1507, 1497, 1511, 1512, 1508, 1498, 1499, 1502, 1501, 1513,
  1514, 1515, 1516, 1503, 1517, 1518, 1519, 1520, 1506, 1507,
  1509, 1510, 1521, 1522, 1513, 1523, 1515, 1524, 1525, 1514,
  1526, 1527, 1528, 1529, 1530, 1509, 1531, 1532, 1521, 1533,
  1534, 1535, 1536, 1537, 1523, 1538, 1524, 1539, 1529, 1540,
  1541, 1542, 1531, 1543, 1545, 1534, 1544, 1536, 1546, 1547,
  1535, 1548, 1550, 1551, 1552, 1549, 1553, 1554, 1543, 1555,
  1542, 1556, 1544, 1545, 1557, 1558, 1559, 1560, 1561, 1552,

  1562, 1563, 1564, 1565, 1566, 1555, 1567, 1568, 1569, 1570,
  1571, 1559, 1572, 1573, 1574, 1562, 1560, 1576, 1575, 1577,
  1578, 1579, 1580, 1581, 1570, 1582, 1583, 1584, 1585, 1586,
  1587, 1588, 1576, 1589, 1590, 1578, 1591, 1592, 1593, 1594,
  1582, 1595, 1581, 1596, 1597, 1598, 1599, 1600, 1601, 1602,
  1603, 1604, 1605, 1592, 1606, 1607, 1595, 1608, 1609, 1610,
  1611, 1599, 1612, 1613, 1614, 1615, 1600, 1616, 1617, 1603,
  1618, 1619, 1620, 1621, 1622, 1623, 1624, 1625, 1626, 1627,
  1628, 1629, 1613, 1631, 1632, 1633, 1630, 1634, 1635, 1636,
  1637, 1638, 1625, 1639, 1640, 1641, 1642, 1643, 1644, 1645,

  1618, 1646, 1647, 1648, 1649, 1650, 1638, 1651, 1652, 1653,
  1654, 1655, 1656, 1657, 1658, 1659, 1660, 1661, 1662, 1663,
  1664, 1665, 1666, 1667, 1668, 1654, 1669, 1670, 1671, 1672,
  1673, 1674, 1675, 1677, 1676, 1678, 1679, 1665, 1680, 1682,
  1681, 1683, 1684, 1685, 1686, 1669, 1670, 1687, 1688, 1673,
  1676, 1679, 1681, 1689, 1690, 1691, 1692, 1693, 1682, 1694,
  1695, 1684, 1696, 1686, 1697, 1698, 1699, 1700, 1701, 1689,
  1702, 1703, 1704, 1690, 1694, 1705, 1693, 1696, 1706, 1707,
  1708, 1709, 1710, 1711, 1712, 1713, 1702, 1714, 1715, 1716,
  1717, 1718, 1719, 1720, 1705, 1721, 1709, 1722, 1723, 253,

  1227, 1225, 1224, 1712, 1223, 1222, 1221, 1220, 1217, 1215,
  1214, 1213, 1720, 1212, 1721, 66, 66, 66, 66, 66,
  66, 66, 66, 66, 70, 70, 70, 70, 70, 70,
  70, 70, 70, 74, 74, 74, 74, 74, 74, 74,
  74, 74, 76, 76, 76, 76, 76, 76, 76, 76,
  76, 78, 78, 78, 78, 78, 78, 78, 78, 78,
  80, 80, 80, 80, 80, 80, 80, 80, 80, 84,
  1211, 84, 228, 1210, 228, 228, 1209, 228, 1206, 228,
  228, 230, 230, 230, 230, 230, 230, 230, 230, 230,
  238, 1204, 238, 238, 1203, 238, 238, 238, 238, 239,

  1201, 1200, 239, 239, 239, 1199, 239, 239, 241, 1198,
  1197, 241, 241, 241, 241, 241, 241, 242, 1193, 242,
  242, 242, 242, 242, 1192, 242, 243, 1191, 243, 243,
  243, 243, 243, 243, 1190, 1189, 1188, 1187, 1185, 1184,
  1182, 1181, 1180, 1179, 1178, 1177, 1175, 1172, 1171, 1170,
  1169, 1168, 1167, 1166, 1165, 1163, 1162, 1161, 1159, 1157,
  1155, 1154, 1153, 1152, 1151, 1150, 1149, 1148, 1147, 1145,
  1142, 1141, 1140, 1139, 1138, 1137, 1136, 1133, 1131, 1129,
  1128, 1127, 1126, 1125, 1124, 1122, 1121, 1120, 1119, 1118,
  1116, 1115, 1113, 1112, 1110, 1107, 1104, 1101, 1098, 1097,

  1096, 1092, 1091, 1088, 1087, 1086, 1085, 1084, 1083, 1082,
  1081, 1080, 1077, 1076, 1075, 1074, 1073, 1072, 1067, 1066,
  1065, 1063, 1062, 1060, 1059, 1058, 1057, 1054, 1052, 1049,
  1048, 1044, 1040, 1039, 1038, 1037, 1036, 1035, 1034, 1033,
  1031, 1030, 1029, 1027, 1024, 1023, 1022, 1019, 1018, 1017,
  1016, 1015, 1014, 1013, 1012, 1011, 1008, 1007, 1006, 1005,
  1004, 1003, 1002, 999, 998, 996, 995, 994, 993, 992,
  991, 990, 989, 986, 985, 980, 978, 975, 971, 970,
  966, 965, 962, 960, 959, 958, 957, 955, 954, 953,
  951, 950, 949, 948, 947, 946, 945, 942, 940, 937,

  936, 935, 934, 933, 932, 927, 926, 924, 923, 922,
  921, 920, 918, 917, 916, 915, 913, 912, 907, 905,
  899, 896, 895, 894, 893, 892, 890, 889, 888, 887,
  886, 883, 882, 881, 880, 879, 878, 877, 876, 873,
  868, 867, 866, 864, 863, 862, 861, 860, 855, 853,
  848, 847, 846, 843, 842, 841, 840, 838, 837, 836,
  835, 834, 833, 832, 831, 830, 829, 828, 827, 824,
  821, 820, 819, 818, 810, 809, 808, 807, 804, 803,
  802, 800, 799, 798, 797, 796, 795, 794, 793, 790,
  789, 788, 787, 786, 785, 784, 783, 780, 779, 778,

  776, 775, 773, 771, 770, 769, 768, 765, 762, 761,
  760, 757, 756, 755, 749, 746, 745, 744, 740, 739,
  731, 730, 727, 726, 718, 711, 709, 708, 704, 703,
  702, 701, 700, 699, 695, 694, 693, 692, 686, 685,
  684, 683, 677, 676, 675, 674, 673, 672, 671, 668,
  666, 661, 660, 659, 656, 655, 651, 650, 648, 647,
  646, 645, 644, 643, 640, 638, 635, 629, 627, 626,
  625, 624, 623, 622, 620, 619, 618, 614, 612, 607,
  606, 605, 600, 599, 598, 596, 592, 591, 587, 584,
  582, 578, 577, 576, 574, 573, 572, 571, 570, 569,

  567, 566, 565, 564, 563, 562, 560, 559, 558, 557,
  555, 552, 551, 550, 548, 542, 539, 536, 535, 527,
  524, 523, 522, 521, 518, 514, 513, 512, 511, 510,
  509, 508, 507, 506, 503, 502, 501, 500, 499, 498,
  497, 496, 495, 494, 485, 483, 478, 477, 476, 465,
  459, 455, 449, 448, 447, 430, 426, 425, 410, 406,
  400, 398, 395, 393, 385, 364, 361, 360, 359, 358,
  346, 344, 343, 342, 341, 337, 333, 332, 329, 325,
  319, 318, 313, 312, 311, 297, 277, 270, 258, 255,
  254, 82, 244, 240, 240, 229, 229, 227, 226, 225,

  224, 187, 158, 100, 83, 82, 1724, 19, 1724, 1724,
  1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724,
  1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724,
  1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724,
  1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724,
  1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724,
  1724, 1724, 1724, 1724, 1724, 1724
};

static yyconst flex_int16_t yy_chk[2367] = { 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 3, 4,
  5, 6, 7, 3, 4, 5, 6, 7, 8, 9,
  10, 15, 16, 8, 9, 10, 11, 12, 11, 12,
  13, 14, 13, 14, 17, 18, 28, 29, 29, 29,
  30, 33, 33, 33, 30, 28, 31, 59, 31, 31,

  31, 34, 34, 121, 3, 4, 57, 43, 93, 93,
  31, 43, 1023, 121, 57, 9, 10, 37, 15, 16,
  57, 43, 11, 12, 32, 59, 32, 32, 32, 106,
  132, 132, 106, 17, 18, 37, 218, 31, 32, 37,
  218, 31, 36, 36, 36, 37, 36, 45, 37, 47,
  102, 47, 36, 47, 36, 37, 119, 47, 36, 36,
  36, 45, 36, 47, 37, 45, 107, 102, 107, 38,
  119, 44, 36, 36, 36, 36, 38, 39, 44, 44,
  38, 39, 102, 38, 44, 39, 38, 336, 40, 38,
  336, 39, 104, 38, 39, 105, 122, 39, 44, 40,

  109, 40, 38, 105, 40, 41, 40, 104, 1024, 41,
  39, 40, 122, 41, 42, 109, 41, 49, 105, 41,
  40, 42, 41, 40, 42, 41, 48, 42, 165, 42,
  48, 49, 51, 49, 48, 49, 51, 165, 41, 112,
  48, 146, 114, 42, 42, 49, 51, 114, 452, 51,
  127, 49, 50, 50, 112, 146, 50, 58, 127, 151,
  58, 58, 114, 56, 50, 51, 50, 58, 50, 452,
  58, 50, 50, 50, 56, 124, 56, 53, 151, 56,
  124, 53, 50, 50, 50, 53, 58, 162, 53, 162,
  124, 53, 54, 56, 54, 162, 54, 171, 288, 54,

  54, 196, 108, 54, 54, 204, 55, 288, 54, 171,
  55, 54, 54, 55, 55, 196, 54, 69, 108, 69,
  55, 69, 69, 55, 108, 1025, 54, 310, 87, 87,
  87, 90, 90, 90, 91, 204, 91, 91, 91, 55,
  87, 87, 117, 90, 90, 92, 92, 113, 91, 92,
  92, 92, 173, 173, 113, 117, 137, 310, 117, 117,
  113, 145, 118, 175, 337, 69, 118, 126, 69, 69,
  69, 137, 126, 113, 117, 113, 145, 125, 175, 118,
  125, 131, 131, 138, 1026, 126, 125, 180, 126, 138,
  125, 154, 154, 125, 337, 118, 120, 131, 135, 166,

  135, 166, 180, 140, 135, 138, 140, 120, 120, 120,
  154, 135, 1032, 120, 120, 135, 120, 143, 182, 140,
  166, 197, 159, 143, 188, 167, 161, 159, 120, 120,
  135, 161, 1034, 143, 197, 167, 143, 182, 143, 153,
  153, 159, 153, 188, 164, 153, 212, 161, 164, 1035,
  153, 153, 153, 163, 167, 153, 153, 163, 212, 164,
  164, 169, 178, 184, 172, 163, 463, 202, 169, 153,
  219, 153, 463, 163, 172, 172, 183, 178, 202, 184,
  186, 172, 192, 169, 186, 219, 220, 183, 183, 1039,
  186, 192, 178, 192, 172, 201, 172, 202, 201, 252,

  252, 194, 220, 183, 189, 189, 189, 225, 194, 189,
  189, 194, 201, 207, 207, 189, 189, 189, 189, 189,
  205, 223, 189, 189, 209, 189, 225, 194, 201, 1040,
  378, 205, 209, 207, 211, 189, 189, 223, 189, 195,
  211, 195, 211, 205, 209, 213, 250, 250, 250, 213,
  195, 268, 195, 213, 195, 195, 195, 195, 195, 214,
  378, 269, 245, 245, 291, 214, 245, 245, 245, 1042,
  268, 195, 195, 195, 247, 247, 247, 269, 248, 248,
  291, 214, 248, 248, 248, 293, 247, 247, 251, 251,
  251, 280, 282, 280, 290, 292, 282, 380, 380, 290,

  290, 251, 290, 298, 293, 296, 296, 298, 280, 303,
  292, 282, 282, 290, 301, 290, 300, 307, 301, 300,
  316, 296, 324, 280, 303, 300, 331, 339, 341, 348,
  343, 341, 344, 348, 307, 347, 316, 350, 324, 354,
  355, 300, 343, 359, 360, 331, 339, 365, 344, 307,
  355, 347, 350, 361, 354, 363, 366, 370, 396, 382,
  361, 381, 359, 360, 384, 365, 386, 388, 399, 354,
  363, 366, 370, 381, 382, 388, 384, 396, 400, 399,
  403, 386, 407, 408, 410, 412, 420, 1045, 421, 427,
  422, 428, 408, 412, 400, 421, 427, 434, 407, 403,

  410, 422, 420, 429, 435, 443, 428, 444, 429, 435,
  447, 450, 444, 434, 403, 449, 422, 449, 453, 458,
  455, 443, 429, 444, 435, 447, 459, 1046, 464, 450,
  468, 449, 462, 453, 458, 449, 455, 464, 462, 472,
  467, 450, 467, 462, 450, 459, 455, 473, 483, 468,
  479, 455, 475, 475, 479, 472, 464, 485, 498, 475,
  507, 644, 462, 483, 724, 500, 473, 1048, 724, 479,
  479, 644, 503, 485, 498, 475, 487, 487, 487, 507,
  475, 500, 475, 488, 488, 488, 489, 489, 503, 508,
  489, 489, 489, 491, 491, 491, 488, 492, 492, 492,

  520, 529, 534, 540, 535, 508, 547, 1052, 548, 542,
  492, 541, 550, 551, 542, 566, 529, 534, 520, 535,
  542, 541, 547, 548, 572, 573, 541, 578, 550, 579,
  566, 540, 551, 540, 580, 583, 585, 586, 587, 572,
  573, 594, 598, 578, 599, 600, 601, 624, 579, 580,
  583, 620, 586, 594, 603, 585, 630, 587, 598, 599,
  600, 637, 601, 624, 580, 603, 620, 586, 638, 642,
  641, 630, 647, 645, 650, 651, 650, 637, 652, 655,
  672, 603, 641, 661, 638, 667, 673, 647, 642, 645,
  675, 651, 674, 682, 652, 655, 672, 683, 661, 685,

  667, 688, 673, 697, 674, 675, 706, 701, 719, 682,
  710, 710, 713, 683, 685, 779, 1053, 714, 713, 720,
  688, 706, 697, 701, 722, 717, 710, 719, 713, 717,
  713, 688, 714, 725, 720, 730, 741, 744, 745, 722,
  754, 717, 861, 754, 770, 779, 730, 771, 861, 725,
  777, 781, 744, 785, 745, 741, 766, 766, 766, 767,
  767, 767, 771, 770, 725, 777, 781, 797, 785, 798,
  799, 801, 767, 802, 803, 808, 812, 809, 814, 819,
  1054, 822, 797, 827, 828, 799, 829, 801, 798, 830,
  803, 812, 802, 809, 808, 819, 814, 822, 837, 827,

  838, 855, 860, 828, 865, 829, 867, 872, 830, 873,
  877, 875, 855, 837, 875, 838, 881, 889, 860, 896,
  1055, 867, 872, 909, 905, 877, 907, 921, 873, 865,
  912, 922, 937, 889, 924, 881, 867, 935, 896, 905,
  939, 907, 909, 921, 945, 912, 954, 922, 957, 924,
  955, 937, 935, 967, 970, 992, 978, 979, 986, 939,
  980, 954, 989, 945, 1005, 955, 992, 957, 1007, 967,
  970, 978, 1008, 979, 986, 980, 1027, 1018, 1022, 1030,
  1031, 989, 1033, 1005, 1041, 1037, 1038, 1007, 1041, 1043,
  1044, 1008, 1018, 1022, 1047, 1027, 1050, 1033, 1030, 1031,

  1037, 1038, 1056, 1057, 1043, 1044, 1058, 1059, 1058, 1047,
  1060, 1050, 1061, 1062, 1063, 1064, 1066, 1067, 1068, 1064,
  1069, 1070, 1073, 1075, 1078, 1079, 1081, 1058, 1082, 1063,
  1083, 1084, 1085, 1090, 1094, 1095, 1097, 1098, 1075, 1069,
  1099, 1100, 1101, 1082, 1104, 1081, 1106, 1107, 1108, 1083,
  1109, 1111, 1112, 1113, 1114, 1115, 1116, 1101, 1117, 1118,
  1119, 1120, 1123, 1107, 1124, 1125, 1126, 1127, 1129, 1131,
  1133, 1136, 1137, 1138, 1139, 1141, 1140, 1142, 1143, 1144,
  1145, 1146, 1147, 1148, 1149, 1150, 1152, 1137, 1155, 1156,
  1139, 1140, 1157, 1158, 1159, 1160, 1162, 1164, 1147, 1166,

  1168, 1171, 1172, 1174, 1150, 1175, 1176, 1155, 1177, 1178,
  1179, 1180, 1181, 1182, 1183, 1184, 1186, 1185, 1187, 1188,
  1175, 1172, 1189, 1191, 1193, 1194, 1179, 1195, 1178, 1196,
  1197, 1181, 1185, 1198, 1199, 1186, 1200, 1189, 1202, 1203,
  1204, 1205, 1206, 1207, 1208, 1210, 1209, 1211, 1213, 1199,
  1216, 1218, 1217, 1219, 1203, 1220, 1205, 1221, 1223, 1204,
  1210, 1206, 1209, 1224, 1225, 1226, 1228, 1213, 1217, 1231,
  1232, 1234, 1237, 1238, 1240, 1243, 1245, 1247, 1224, 1248,
  1249, 1250, 1252, 1253, 1254, 1232, 1255, 1256, 1257, 1258,
  1259, 1260, 1261, 1262, 1265, 1267, 1268, 1269, 1271, 1270,

  1272, 1273, 1276, 1274, 1281, 1283, 1259, 1284, 1285, 1284,
  1287, 1286, 1269, 1265, 1270, 1289, 1273, 1271, 1274, 1258,
  1290, 1291, 1292, 1281, 1294, 1267, 1286, 1295, 1284, 1287,
  1296, 1289, 1297, 1298, 1301, 1303, 1304, 1305, 1306, 1309,
  1310, 1312, 1304, 1313, 1314, 1315, 1317, 1297, 1319, 1320,
  1321, 1323, 1327, 1301, 1328, 1329, 1330, 1331, 1333, 1334,
  1336, 1338, 1339, 1340, 1342, 1343, 1344, 1319, 1345, 1346,
  1349, 1352, 1351, 1353, 1334, 1354, 1355, 1356, 1357, 1358,
  1338, 1359, 1358, 1361, 1362, 1349, 1363, 1331, 1351, 1365,
  1366, 1355, 1367, 1369, 1371, 1372, 1356, 1373, 1375, 1362,

  1376, 1378, 1361, 1380, 1383, 1384, 1386, 1389, 1367, 1390,
  1372, 1394, 1373, 1391, 1396, 1376, 1397, 1378, 1398, 1399,
  1401, 1384, 1404, 1409, 1402, 1386, 1389, 1394, 1391, 1410,
  1411, 1412, 1413, 1396, 1415, 1416, 1417, 1418, 1399, 1401,
  1402, 1402, 1419, 1420, 1410, 1421, 1412, 1423, 1424, 1411,
  1425, 1426, 1427, 1428, 1429, 1402, 1430, 1431, 1419, 1432,
  1433, 1435, 1438, 1439, 1421, 1440, 1423, 1441, 1428, 1444,
  1445, 1446, 1430, 1447, 1452, 1433, 1449, 1438, 1454, 1455,
  1435, 1456, 1458, 1459, 1463, 1456, 1465, 1466, 1447, 1467,
  1446, 1468, 1449, 1452, 1469, 1470, 1473, 1475, 1476, 1463,

  1477, 1478, 1479, 1480, 1481, 1467, 1482, 1483, 1484, 1485,
  1487, 1473, 1488, 1490, 1491, 1477, 1475, 1493, 1491, 1494,
  1498, 1501, 1502, 1505, 1485, 1506, 1507, 1508, 1509, 1510,
  1511, 1512, 1493, 1513, 1514, 1498, 1516, 1517, 1518, 1519,
  1506, 1520, 1505, 1521, 1524, 1525, 1526, 1527, 1530, 1534,
  1537, 1538, 1539, 1517, 1540, 1541, 1520, 1542, 1543, 1544,
  1546, 1526, 1548, 1549, 1550, 1551, 1527, 1553, 1556, 1537,
  1557, 1558, 1559, 1560, 1563, 1564, 1565, 1566, 1568, 1569,
  1570, 1572, 1549, 1573, 1575, 1576, 1572, 1578, 1580, 1582,
  1583, 1584, 1566, 1585, 1586, 1587, 1588, 1593, 1596, 1597,

  1557, 1598, 1599, 1600, 1601, 1602, 1584, 1603, 1604, 1605,
  1608, 1609, 1613, 1616, 1617, 1618, 1619, 1620, 1624, 1625,
  1626, 1627, 1628, 1629, 1630, 1608, 1631, 1632, 1633, 1635,
  1637, 1638, 1639, 1641, 1640, 1642, 1645, 1627, 1646, 1650,
  1649, 1652, 1653, 1654, 1655, 1631, 1632, 1657, 1659, 1637,
  1640, 1645, 1649, 1660, 1661, 1666, 1667, 1668, 1650, 1672,
  1673, 1653, 1674, 1655, 1678, 1680, 1683, 1684, 1687, 1660,
  1692, 1693, 1696, 1661, 1672, 1697, 1668, 1674, 1698, 1699,
  1701, 1703, 1704, 1705, 1706, 1707, 1692, 1708, 1709, 1710,
  1712, 1713, 1714, 1718, 1697, 1719, 1703, 1720, 1721, 1739,

  1021, 1017, 1015, 1706, 1012, 1011, 1010, 1009, 1006, 1004,
  1000, 999, 1718, 998, 1719, 1725, 1725, 1725, 1725, 1725,
  1725, 1725, 1725, 1725, 1726, 1726, 1726, 1726, 1726, 1726,
  1726, 1726, 1726, 1727, 1727, 1727, 1727, 1727, 1727, 1727,
  1727, 1727, 1728, 1728, 1728, 1728, 1728, 1728, 1728, 1728,
  1728, 1729, 1729, 1729, 1729, 1729, 1729, 1729, 1729, 1729,
  1730, 1730, 1730, 1730, 1730, 1730, 1730, 1730, 1730, 1731,
  996, 1731, 1732, 994, 1732, 1732, 993, 1732, 991, 1732,
  1732, 1733, 1733, 1733, 1733, 1733, 1733, 1733, 1733, 1733,
  1734, 988, 1734, 1734, 987, 1734, 1734, 1734, 1734, 1735,

  985, 984, 1735, 1735, 1735, 983, 1735, 1735, 1736, 982,
  981, 1736, 1736, 1736, 1736, 1736, 1736, 1737, 977, 1737,
  1737, 1737, 1737, 1737, 976, 1737, 1738, 975, 1738, 1738,
  1738, 1738, 1738, 1738, 974, 973, 972, 971, 969, 968,
  966, 965, 964, 962, 959, 958, 956, 953, 952, 951,
  950, 949, 948, 947, 946, 944, 943, 940, 938, 936,
  934, 933, 932, 931, 930, 929, 928, 927, 925, 923,
  920, 919, 918, 917, 916, 915, 913, 908, 906, 904,
  902, 901, 900, 899, 897, 894, 893, 892, 891, 890,
  888, 887, 879, 878, 876, 874, 868, 866, 864, 863,

  862, 859, 856, 854, 853, 850, 849, 848, 846, 841,
  840, 839, 836, 835, 834, 833, 832, 831, 826, 825,
  823, 821, 820, 818, 817, 816, 815, 813, 811, 806,
  804, 800, 796, 794, 792, 791, 790, 789, 788, 787,
  784, 783, 782, 780, 776, 775, 773, 769, 768, 764,
  763, 761, 760, 759, 758, 756, 753, 752, 751, 750,
  749, 748, 746, 743, 742, 740, 739, 738, 735, 734,
  733, 732, 731, 727, 726, 723, 721, 718, 716, 715,
  712, 711, 708, 705, 704, 703, 702, 700, 699, 698,
  696, 695, 694, 693, 692, 690, 689, 686, 684, 681,

  680, 679, 678, 677, 676, 671, 668, 666, 665, 664,
  663, 662, 660, 659, 658, 657, 654, 653, 648, 646,
  640, 636, 634, 633, 632, 631, 629, 628, 627, 626,
  625, 618, 616, 615, 614, 612, 610, 606, 605, 602,
  597, 596, 595, 593, 592, 591, 590, 588, 584, 581,
  577, 575, 574, 570, 569, 568, 567, 565, 564, 563,
  562, 561, 560, 558, 556, 555, 554, 553, 552, 549,
  546, 545, 544, 543, 539, 538, 537, 536, 532, 531,
  530, 528, 527, 526, 525, 524, 523, 522, 521, 519,
  518, 515, 514, 513, 512, 510, 509, 506, 505, 504,

  502, 501, 499, 497, 496, 495, 494, 486, 482, 481,
  480, 478, 477, 476, 474, 471, 470, 469, 466, 465,
  461, 460, 457, 456, 451, 448, 446, 445, 441, 440,
  439, 438, 437, 436, 433, 432, 431, 430, 426, 425,
  424, 423, 419, 418, 417, 416, 415, 414, 413, 411,
  409, 406, 405, 404, 402, 401, 398, 397, 395, 394,
  393, 392, 391, 389, 387, 385, 383, 379, 377, 376,
  375, 374, 373, 371, 369, 368, 367, 364, 362, 358,
  357, 356, 353, 352, 351, 349, 346, 345, 342, 340,
  338, 334, 333, 332, 330, 329, 328, 327, 326, 325,

  323, 322, 321, 320, 319, 318, 314, 313, 312, 311,
  309, 306, 305, 304, 302, 299, 297, 295, 294, 289,
  287, 286, 285, 283, 281, 279, 278, 277, 276, 275,
  274, 273, 272, 271, 267, 264, 262, 261, 260, 259,
  258, 257, 256, 255, 224, 221, 217, 216, 215, 210,
  206, 203, 200, 199, 198, 193, 191, 190, 187, 185,
  181, 179, 176, 174, 170, 160, 158, 157, 156, 155,
  152, 150, 149, 148, 147, 144, 142, 141, 139, 136,
  134, 133, 130, 129, 128, 123, 115, 110, 103, 101,
  96, 82, 81, 77, 75, 73, 68, 65, 63, 61,

  60, 52, 46, 35, 23, 21, 19, 1724, 1724, 1724,
  1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724,
  1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724,
  1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724,
  1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724,
  1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724,
  1724, 1724, 1724, 1724, 1724, 1724
};

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

extern int rsql_yy_flex_debug;
int rsql_yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *rsql_yytext;
#line 1 "../../src/parser/rsql_lexer.l"
/*
 * Copyright (C) 2008 Search Solution Corporation. All rights reserved by Search Solution.
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or 
 *   (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *
 */
/*
 * rsql_lexer.l - SQL lexer file
 */
#line 30 "../../src/parser/rsql_lexer.l"
#include "rsql_grammar.h"
#include "parse_tree.h"
#include "system_parameter.h"
#include "message_catalog.h"

#define RSQL_MAXNAME	256

#if defined (ENABLE_UNUSED_FUNCTION)
static int parser_yyinput_single_line (char *buff, int max_size);
#endif
static int parser_yyinput_multi_line (char *buff, int max_size);
static int parser_yyinput (char *buff, int max_size);
static char *parser_c_hint (void);
static char *parser_line_hint (void);
static void begin_token (char *token);

extern int yyline;
extern int yycolumn;
extern int yycolumn_end;






#undef YY_INPUT
#define YY_INPUT(buffer, result, max_size) { result = parser_yyinput(buffer, max_size); result == 0 ? result = YY_NULL : result; }

/*
 * This action is executed each time a token is matched. Its position in the 
 * buffer is saved as part of the location information.
 */
#define YY_USER_ACTION  {yybuffer_pos += rsql_yyget_leng (); rsql_yylloc.buffer_pos = yybuffer_pos;}










#line 1626 "../../src/parser/rsql_lexer.c"

#define INITIAL 0
#define QUOTED_NCHAR_STRING 1
#define QUOTED_BIT_STRING 2
#define QUOTED_HEX_STRING 3
#define QUOTED_CHAR_STRING 4
#define DOUBLY_QUOTED_CHAR_STRING 5
#define DELIMITED_ID_NAME 6
#define BRACKET_ID_NAME 7
#define BACKTICK_ID_NAME 8

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

static int yy_init_globals (void);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int rsql_yylex_destroy (void);

int rsql_yyget_debug (void);

void rsql_yyset_debug (int debug_flag);

YY_EXTRA_TYPE rsql_yyget_extra (void);

void rsql_yyset_extra (YY_EXTRA_TYPE user_defined);

FILE *rsql_yyget_in (void);

void rsql_yyset_in (FILE * in_str);

FILE *rsql_yyget_out (void);

void rsql_yyset_out (FILE * out_str);

int rsql_yyget_leng (void);

char *rsql_yyget_text (void);

int rsql_yyget_lineno (void);

void rsql_yyset_lineno (int line_number);

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int rsql_yywrap (void);
#else
extern int rsql_yywrap (void);
#endif
#endif

static void yyunput (int c, char *buf_ptr);

#ifndef yytext_ptr
static void yy_flex_strncpy (char *, yyconst char *, int);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (yyconst char *);
#endif

#ifndef YY_NO_INPUT

#ifdef __cplusplus
static int yyinput (void);
#else
static int input (void);
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO fwrite( rsql_yytext, rsql_yyleng, 1, rsql_yyout )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		int n; \
		for ( n = 0; n < max_size && \
			     (c = getc( rsql_yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( rsql_yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = fread(buf, 1, max_size, rsql_yyin))==0 && ferror(rsql_yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(rsql_yyin); \
			} \
		}\
\

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int rsql_yylex (void);

#define YY_DECL int rsql_yylex (void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after rsql_yytext and rsql_yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
  register yy_state_type yy_current_state;
  register char *yy_cp, *yy_bp;
  register int yy_act;

#line 79 "../../src/parser/rsql_lexer.l"


#line 1819 "../../src/parser/rsql_lexer.c"

  if (!(yy_init))
    {
      (yy_init) = 1;

#ifdef YY_USER_INIT
      YY_USER_INIT;
#endif

      if (!(yy_start))
        (yy_start) = 1;         /* first start state */

      if (!rsql_yyin)
        rsql_yyin = stdin;

      if (!rsql_yyout)
        rsql_yyout = stdout;

      if (!YY_CURRENT_BUFFER)
        {
          rsql_yyensure_buffer_stack ();
          YY_CURRENT_BUFFER_LVALUE = rsql_yy_create_buffer (rsql_yyin, YY_BUF_SIZE);
        }

      rsql_yy_load_buffer_state ();
    }

  while (1)                     /* loops until end-of-file is reached */
    {
      yy_cp = (yy_c_buf_p);

      /* Support of rsql_yytext. */
      *yy_cp = (yy_hold_char);

      /* yy_bp points to the position in yy_ch_buf of the start of
       * the current run.
       */
      yy_bp = yy_cp;

      yy_current_state = (yy_start);
    yy_match:
      do
        {
          register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI (*yy_cp)];
          if (yy_accept[yy_current_state])
            {
              (yy_last_accepting_state) = yy_current_state;
              (yy_last_accepting_cpos) = yy_cp;
            }
          while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
            {
              yy_current_state = (int) yy_def[yy_current_state];
              if (yy_current_state >= 1725)
                yy_c = yy_meta[(unsigned int) yy_c];
            }
          yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
          ++yy_cp;
        }
      while (yy_base[yy_current_state] != 2308);

    yy_find_action:
      yy_act = yy_accept[yy_current_state];
      if (yy_act == 0)
        {                       /* have to back up */
          yy_cp = (yy_last_accepting_cpos);
          yy_current_state = (yy_last_accepting_state);
          yy_act = yy_accept[yy_current_state];
        }

      YY_DO_BEFORE_ACTION;

    do_action:                 /* This label is used only to access EOF actions. */

      switch (yy_act)
        {                       /* beginning of action switch */
        case 0:                /* must back up */
          /* undo the effects of YY_DO_BEFORE_ACTION */
          *yy_cp = (yy_hold_char);
          yy_cp = (yy_last_accepting_cpos);
          yy_current_state = (yy_last_accepting_state);
          goto yy_find_action;

        case 1:
          YY_RULE_SETUP
#line 81 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
          }
        YY_BREAK case 2:
/* rule 2 can match eol */
          YY_RULE_SETUP
#line 82 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            this_parser->line = yyline++;
            this_parser->column = yycolumn = yycolumn_end = 1;
          }
        YY_BREAK case 3:
          YY_RULE_SETUP
#line 90 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ABSOLUTE_;
          }
        YY_BREAK case 4:
          YY_RULE_SETUP
#line 91 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ACCESS;
          }
        YY_BREAK case 5:
          YY_RULE_SETUP
#line 92 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ACTION;
          }
        YY_BREAK case 6:
          YY_RULE_SETUP
#line 93 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ADD;
          }
        YY_BREAK case 7:
          YY_RULE_SETUP
#line 94 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return ADDDATE;
          }
        YY_BREAK case 8:
          YY_RULE_SETUP
#line 97 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return AFTER;
          }
        YY_BREAK case 9:
          YY_RULE_SETUP
#line 98 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ALL;
          }
        YY_BREAK case 10:
          YY_RULE_SETUP
#line 99 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ALLOCATE;
          }
        YY_BREAK case 11:
          YY_RULE_SETUP
#line 100 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ALTER;
          }
        YY_BREAK case 12:
          YY_RULE_SETUP
#line 101 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return ANALYZE;
          }
        YY_BREAK case 13:
          YY_RULE_SETUP
#line 104 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return AND;
          }
        YY_BREAK case 14:
          YY_RULE_SETUP
#line 105 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return ARCHIVE;
          }
        YY_BREAK case 15:
          YY_RULE_SETUP
#line 108 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ARE;
          }
        YY_BREAK case 16:
          YY_RULE_SETUP
#line 109 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return AS;
          }
        YY_BREAK case 17:
          YY_RULE_SETUP
#line 110 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ASC;
          }
        YY_BREAK case 18:
          YY_RULE_SETUP
#line 111 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ASSERTION;
          }
        YY_BREAK case 19:
          YY_RULE_SETUP
#line 112 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ASYNC;
          }
        YY_BREAK case 20:
          YY_RULE_SETUP
#line 113 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return AT;
          }
        YY_BREAK case 21:
          YY_RULE_SETUP
#line 114 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ATTRIBUTE;
          }
        YY_BREAK case 22:
          YY_RULE_SETUP
#line 115 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return AVG;
          }
        YY_BREAK case 23:
          YY_RULE_SETUP
#line 116 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return BETWEEN;
          }
        YY_BREAK case 24:
          YY_RULE_SETUP
#line 117 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return BIGINT;
          }
        YY_BREAK case 25:
          YY_RULE_SETUP
#line 118 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return BINARY;
          }
        YY_BREAK case 26:
          YY_RULE_SETUP
#line 119 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return BIT_LENGTH;
          }
        YY_BREAK case 27:
          YY_RULE_SETUP
#line 120 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return BOOLEAN_;
          }
        YY_BREAK case 28:
          YY_RULE_SETUP
#line 121 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return BOTH_;
          }
        YY_BREAK case 29:
          YY_RULE_SETUP
#line 122 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return BREADTH;
          }
        YY_BREAK case 30:
          YY_RULE_SETUP
#line 123 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return BY;
          }
        YY_BREAK case 31:
          YY_RULE_SETUP
#line 124 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return CACHE;
          }
        YY_BREAK case 32:
          YY_RULE_SETUP
#line 127 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return CAPACITY;
          }
        YY_BREAK case 33:
          YY_RULE_SETUP
#line 130 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CASCADE;
          }
        YY_BREAK case 34:
          YY_RULE_SETUP
#line 131 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CASCADED;
          }
        YY_BREAK case 35:
          YY_RULE_SETUP
#line 132 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CASE;
          }
        YY_BREAK case 36:
          YY_RULE_SETUP
#line 133 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CAST;
          }
        YY_BREAK case 37:
          YY_RULE_SETUP
#line 134 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CATALOG;
          }
        YY_BREAK case 38:
          YY_RULE_SETUP
#line 135 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CHANGE;
          }
        YY_BREAK case 39:
          YY_RULE_SETUP
#line 136 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CHAR_;
          }
        YY_BREAK case 40:
          YY_RULE_SETUP
#line 137 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return CHARACTER_SET_;
          }
        YY_BREAK case 41:
          YY_RULE_SETUP
#line 140 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return CHARSET;
          }
        YY_BREAK case 42:
          YY_RULE_SETUP
#line 143 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CHECK;
          }
        YY_BREAK case 43:
          YY_RULE_SETUP
#line 144 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return CHR;
          }
        YY_BREAK case 44:
          YY_RULE_SETUP
#line 147 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CLASS;
          }
        YY_BREAK case 45:
          YY_RULE_SETUP
#line 148 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CLASSES;
          }
        YY_BREAK case 46:
          YY_RULE_SETUP
#line 149 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CLOSE;
          }
        YY_BREAK case 47:
          YY_RULE_SETUP
#line 150 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return COALESCE;
          }
        YY_BREAK case 48:
          YY_RULE_SETUP
#line 151 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return COLLATE;
          }
        YY_BREAK case 49:
          YY_RULE_SETUP
#line 152 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return COLLATION;
          }
        YY_BREAK case 50:
          YY_RULE_SETUP
#line 155 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return COLUMN;
          }
        YY_BREAK case 51:
          YY_RULE_SETUP
#line 156 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return COLUMNS;
          }
        YY_BREAK case 52:
          YY_RULE_SETUP
#line 159 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return COMMIT;
          }
        YY_BREAK case 53:
          YY_RULE_SETUP
#line 160 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return COMMITTED;
          }
        YY_BREAK case 54:
          YY_RULE_SETUP
#line 163 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CONNECTION;
          }
        YY_BREAK case 55:
          YY_RULE_SETUP
#line 164 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CONSTRAINT;
          }
        YY_BREAK case 56:
          YY_RULE_SETUP
#line 165 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CONSTRAINTS;
          }
        YY_BREAK case 57:
          YY_RULE_SETUP
#line 166 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CONTINUE;
          }
        YY_BREAK case 58:
          YY_RULE_SETUP
#line 167 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CONVERT;
          }
        YY_BREAK case 59:
          YY_RULE_SETUP
#line 168 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CORRESPONDING;
          }
        YY_BREAK case 60:
          YY_RULE_SETUP
#line 169 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return COST;
          }
        YY_BREAK case 61:
          YY_RULE_SETUP
#line 173 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return COUNT;
          }
        YY_BREAK case 62:
          YY_RULE_SETUP
#line 174 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CREATE;
          }
        YY_BREAK case 63:
          YY_RULE_SETUP
#line 175 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CROSS;
          }
        YY_BREAK case 64:
          YY_RULE_SETUP
#line 176 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CURRENT_DATE;
          }
        YY_BREAK case 65:
          YY_RULE_SETUP
#line 177 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CURRENT_TIME;
          }
        YY_BREAK case 66:
          YY_RULE_SETUP
#line 178 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CURRENT_DATETIME;
          }
        YY_BREAK case 67:
          YY_RULE_SETUP
#line 179 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CURRENT_USER;
          }
        YY_BREAK case 68:
          YY_RULE_SETUP
#line 180 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CURSOR;
          }
        YY_BREAK case 69:
          YY_RULE_SETUP
#line 181 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CYCLE;
          }
        YY_BREAK case 70:
          YY_RULE_SETUP
#line 182 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return CHAR_;
          }
        YY_BREAK case 71:
          YY_RULE_SETUP
#line 183 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DATA;
          }
        YY_BREAK case 72:
          YY_RULE_SETUP
#line 184 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DATABASE;
          }
        YY_BREAK case 73:
          YY_RULE_SETUP
#line 185 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DATA_TYPE_;
          }
        YY_BREAK case 74:
          YY_RULE_SETUP
#line 186 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return DATE_ADD;
          }
        YY_BREAK case 75:
          YY_RULE_SETUP
#line 189 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return DATE_SUB;
          }
        YY_BREAK case 76:
          YY_RULE_SETUP
#line 192 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DATETIME;
          }
        YY_BREAK case 77:
          YY_RULE_SETUP
#line 193 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DAY_;
          }
        YY_BREAK case 78:
          YY_RULE_SETUP
#line 194 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DAY_MILLISECOND;
          }
        YY_BREAK case 79:
          YY_RULE_SETUP
#line 195 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DAY_SECOND;
          }
        YY_BREAK case 80:
          YY_RULE_SETUP
#line 196 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DAY_MINUTE;
          }
        YY_BREAK case 81:
          YY_RULE_SETUP
#line 197 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DAY_HOUR;
          }
        YY_BREAK case 82:
          YY_RULE_SETUP
#line 198 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return NUMERIC;
          }
        YY_BREAK case 83:
          YY_RULE_SETUP
#line 199 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return NUMERIC;
          }
        YY_BREAK case 84:
          YY_RULE_SETUP
#line 200 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DECLARE;
          }
        YY_BREAK case 85:
          YY_RULE_SETUP
#line 201 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return DECREMENT;
          }
        YY_BREAK case 86:
          YY_RULE_SETUP
#line 204 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DEFAULT;
          }
        YY_BREAK case 87:
          YY_RULE_SETUP
#line 205 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DEFERRABLE;
          }
        YY_BREAK case 88:
          YY_RULE_SETUP
#line 206 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DEFERRED;
          }
        YY_BREAK case 89:
          YY_RULE_SETUP
#line 207 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DELETE_;
          }
        YY_BREAK case 90:
          YY_RULE_SETUP
#line 208 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DEPTH;
          }
        YY_BREAK case 91:
          YY_RULE_SETUP
#line 209 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DESC;
          }
        YY_BREAK case 92:
          YY_RULE_SETUP
#line 210 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DESCRIPTOR;
          }
        YY_BREAK case 93:
          YY_RULE_SETUP
#line 211 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DIAGNOSTICS;
          }
        YY_BREAK case 94:
          YY_RULE_SETUP
#line 212 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DIFFERENCE_;
          }
        YY_BREAK case 95:
          YY_RULE_SETUP
#line 213 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DISCONNECT;
          }
        YY_BREAK case 96:
          YY_RULE_SETUP
#line 214 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DISTINCT;
          }
        YY_BREAK case 97:
          YY_RULE_SETUP
#line 215 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DISTINCT;
          }
        YY_BREAK case 98:
          YY_RULE_SETUP
#line 216 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DIV;
          }
        YY_BREAK case 99:
          YY_RULE_SETUP
#line 217 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return Domain;
          }
        YY_BREAK case 100:
          YY_RULE_SETUP
#line 218 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DROP;
          }
        YY_BREAK case 101:
          YY_RULE_SETUP
#line 219 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return DUPLICATE_;
          }
        YY_BREAK case 102:
          YY_RULE_SETUP
#line 220 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return Date;
          }
        YY_BREAK case 103:
          YY_RULE_SETUP
#line 221 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return Double;
          }
        YY_BREAK case 104:
          YY_RULE_SETUP
#line 222 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return EACH;
          }
        YY_BREAK case 105:
          YY_RULE_SETUP
#line 223 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ELSE;
          }
        YY_BREAK case 106:
          YY_RULE_SETUP
#line 224 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ELSEIF;
          }
        YY_BREAK case 107:
          YY_RULE_SETUP
#line 225 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return ELT;
          }
        YY_BREAK case 108:
          YY_RULE_SETUP
#line 228 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return END;
          }
        YY_BREAK case 109:
          YY_RULE_SETUP
#line 229 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return ENCRYPT;
          }
        YY_BREAK case 110:
          YY_RULE_SETUP
#line 232 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return EQUALS;
          }
        YY_BREAK case 111:
          YY_RULE_SETUP
#line 233 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ESCAPE;
          }
        YY_BREAK case 112:
          YY_RULE_SETUP
#line 234 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return EXCEPT;
          }
        YY_BREAK case 113:
          YY_RULE_SETUP
#line 235 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return EXCEPTION;
          }
        YY_BREAK case 114:
          YY_RULE_SETUP
#line 236 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return EXEC;
          }
        YY_BREAK case 115:
          YY_RULE_SETUP
#line 237 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return EXECUTE;
          }
        YY_BREAK case 116:
          YY_RULE_SETUP
#line 238 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return EXISTS;
          }
        YY_BREAK case 117:
          YY_RULE_SETUP
#line 239 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return EXPLAIN;
          }
        YY_BREAK case 118:
          YY_RULE_SETUP
#line 242 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return EXTRACT;
          }
        YY_BREAK case 119:
          YY_RULE_SETUP
#line 243 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return FETCH;
          }
        YY_BREAK case 120:
          YY_RULE_SETUP
#line 244 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return FIRST;
          }
        YY_BREAK case 121:
          YY_RULE_SETUP
#line 245 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return FOREIGN;
          }
        YY_BREAK case 122:
          YY_RULE_SETUP
#line 246 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return FOUND;
          }
        YY_BREAK case 123:
          YY_RULE_SETUP
#line 247 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return FROM;
          }
        YY_BREAK case 124:
          YY_RULE_SETUP
#line 248 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return FULL;
          }
        YY_BREAK case 125:
          YY_RULE_SETUP
#line 249 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return FULLSCAN;
          }
        YY_BREAK case 126:
          YY_RULE_SETUP
#line 252 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return False;
          }
        YY_BREAK case 127:
          YY_RULE_SETUP
#line 253 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return File;
          }
        YY_BREAK case 128:
          YY_RULE_SETUP
#line 254 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return FLOAT_;
          }
        YY_BREAK case 129:
          YY_RULE_SETUP
#line 255 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return For;
          }
        YY_BREAK case 130:
          YY_RULE_SETUP
#line 256 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return GENERAL;
          }
        YY_BREAK case 131:
          YY_RULE_SETUP
#line 257 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return GET;
          }
        YY_BREAK case 132:
          YY_RULE_SETUP
#line 258 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return GE_INF_;
          }
        YY_BREAK case 133:
          YY_RULE_SETUP
#line 261 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return GE_LE_;
          }
        YY_BREAK case 134:
          YY_RULE_SETUP
#line 264 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return GE_LT_;
          }
        YY_BREAK case 135:
          YY_RULE_SETUP
#line 267 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return GLOBAL;
          }
        YY_BREAK case 136:
          YY_RULE_SETUP
#line 268 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return GO;
          }
        YY_BREAK case 137:
          YY_RULE_SETUP
#line 269 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return GOTO;
          }
        YY_BREAK case 138:
          YY_RULE_SETUP
#line 270 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return GRANT;
          }
        YY_BREAK case 139:
          YY_RULE_SETUP
#line 271 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return GRANTS;
          }
        YY_BREAK case 140:
          YY_RULE_SETUP
#line 274 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return GROUP_;
          }
        YY_BREAK case 141:
          YY_RULE_SETUP
#line 275 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return GROUP_CONCAT;
          }
        YY_BREAK case 142:
          YY_RULE_SETUP
#line 278 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return GROUPS;
          }
        YY_BREAK case 143:
          YY_RULE_SETUP
#line 281 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return GT_INF_;
          }
        YY_BREAK case 144:
          YY_RULE_SETUP
#line 284 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return GT_LE_;
          }
        YY_BREAK case 145:
          YY_RULE_SETUP
#line 287 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return GT_LT_;
          }
        YY_BREAK case 146:
          YY_RULE_SETUP
#line 290 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return HAVING;
          }
        YY_BREAK case 147:
          YY_RULE_SETUP
#line 291 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return HEADER;
          }
        YY_BREAK case 148:
          YY_RULE_SETUP
#line 294 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return HEAP;
          }
        YY_BREAK case 149:
          YY_RULE_SETUP
#line 297 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return HOUR_;
          }
        YY_BREAK case 150:
          YY_RULE_SETUP
#line 298 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return HOUR_MILLISECOND;
          }
        YY_BREAK case 151:
          YY_RULE_SETUP
#line 299 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return HOUR_SECOND;
          }
        YY_BREAK case 152:
          YY_RULE_SETUP
#line 300 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return HOUR_MINUTE;
          }
        YY_BREAK case 153:
          YY_RULE_SETUP
#line 301 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return IF;
          }
        YY_BREAK case 154:
          YY_RULE_SETUP
#line 302 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return IFNULL;
          }
        YY_BREAK case 155:
          YY_RULE_SETUP
#line 305 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return ISNULL;
          }
        YY_BREAK case 156:
          YY_RULE_SETUP
#line 308 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return IMMEDIATE;
          }
        YY_BREAK case 157:
          YY_RULE_SETUP
#line 309 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return IN_;
          }
        YY_BREAK case 158:
          YY_RULE_SETUP
#line 310 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return INCREMENT;
          }
        YY_BREAK case 159:
          YY_RULE_SETUP
#line 313 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return INDEX;
          }
        YY_BREAK case 160:
          YY_RULE_SETUP
#line 314 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return INDEX_PREFIX;
          }
        YY_BREAK case 161:
          YY_RULE_SETUP
#line 315 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return INDEXES;
          }
        YY_BREAK case 162:
          YY_RULE_SETUP
#line 318 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return INDICATOR;
          }
        YY_BREAK case 163:
          YY_RULE_SETUP
#line 319 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return INF_LE_;
          }
        YY_BREAK case 164:
          YY_RULE_SETUP
#line 322 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return INF_LT_;
          }
        YY_BREAK case 165:
          YY_RULE_SETUP
#line 325 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return INITIALLY;
          }
        YY_BREAK case 166:
          YY_RULE_SETUP
#line 326 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return INNER;
          }
        YY_BREAK case 167:
          YY_RULE_SETUP
#line 327 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return INOUT;
          }
        YY_BREAK case 168:
          YY_RULE_SETUP
#line 328 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return INPUT_;
          }
        YY_BREAK case 169:
          YY_RULE_SETUP
#line 329 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return INSERT;
          }
        YY_BREAK case 170:
          YY_RULE_SETUP
#line 330 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return INSTANCES;
          }
        YY_BREAK case 171:
          YY_RULE_SETUP
#line 333 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return INTERSECT;
          }
        YY_BREAK case 172:
          YY_RULE_SETUP
#line 334 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return INTERSECTION;
          }
        YY_BREAK case 173:
          YY_RULE_SETUP
#line 335 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return INTERVAL;
          }
        YY_BREAK case 174:
          YY_RULE_SETUP
#line 336 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return INTO;
          }
        YY_BREAK case 175:
          YY_RULE_SETUP
#line 337 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return IS;
          }
        YY_BREAK case 176:
          YY_RULE_SETUP
#line 338 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ISOLATION;
          }
        YY_BREAK case 177:
          YY_RULE_SETUP
#line 339 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return INTEGER;
          }
        YY_BREAK case 178:
          YY_RULE_SETUP
#line 340 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return INTEGER;
          }
        YY_BREAK case 179:
          YY_RULE_SETUP
#line 341 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return JAVA;
          }
        YY_BREAK case 180:
          YY_RULE_SETUP
#line 344 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return JOIN;
          }
        YY_BREAK case 181:
          YY_RULE_SETUP
#line 345 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return JSON;
          }
        YY_BREAK case 182:
          YY_RULE_SETUP
#line 348 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return KEY;
          }
        YY_BREAK case 183:
          YY_RULE_SETUP
#line 349 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return KEYS;
          }
        YY_BREAK case 184:
          YY_RULE_SETUP
#line 352 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return LANGUAGE;
          }
        YY_BREAK case 185:
          YY_RULE_SETUP
#line 353 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return KEYLIMIT;
          }
        YY_BREAK case 186:
          YY_RULE_SETUP
#line 354 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return LAST;
          }
        YY_BREAK case 187:
          YY_RULE_SETUP
#line 355 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return LCASE;
          }
        YY_BREAK case 188:
          YY_RULE_SETUP
#line 358 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return LEADING_;
          }
        YY_BREAK case 189:
          YY_RULE_SETUP
#line 359 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return LEAVE;
          }
        YY_BREAK case 190:
          YY_RULE_SETUP
#line 360 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return LEFT;
          }
        YY_BREAK case 191:
          YY_RULE_SETUP
#line 361 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return LEVEL;
          }
        YY_BREAK case 192:
          YY_RULE_SETUP
#line 362 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return LIKE;
          }
        YY_BREAK case 193:
          YY_RULE_SETUP
#line 363 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return LIMIT;
          }
        YY_BREAK case 194:
          YY_RULE_SETUP
#line 364 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return LIST;
          }
        YY_BREAK case 195:
          YY_RULE_SETUP
#line 365 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return LOCK_;
          }
        YY_BREAK case 196:
          YY_RULE_SETUP
#line 368 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return LOG;
          }
        YY_BREAK case 197:
          YY_RULE_SETUP
#line 371 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return LOOP;
          }
        YY_BREAK case 198:
          YY_RULE_SETUP
#line 372 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return LOWER;
          }
        YY_BREAK case 199:
          YY_RULE_SETUP
#line 373 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return MATCH;
          }
        YY_BREAK case 200:
          YY_RULE_SETUP
#line 374 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return MAXIMUM;
          }
        YY_BREAK case 201:
          YY_RULE_SETUP
#line 377 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return INTEGER;
          }
        YY_BREAK case 202:
          YY_RULE_SETUP
#line 378 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return MEMBERS;
          }
        YY_BREAK case 203:
          YY_RULE_SETUP
#line 381 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return MILLISECOND_;
          }
        YY_BREAK case 204:
          YY_RULE_SETUP
#line 382 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return MINUTE_;
          }
        YY_BREAK case 205:
          YY_RULE_SETUP
#line 383 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return MINUTE_MILLISECOND;
          }
        YY_BREAK case 206:
          YY_RULE_SETUP
#line 384 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return MINUTE_SECOND;
          }
        YY_BREAK case 207:
          YY_RULE_SETUP
#line 385 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return MINVALUE;
          }
        YY_BREAK case 208:
          YY_RULE_SETUP
#line 388 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return MOD;
          }
        YY_BREAK case 209:
          YY_RULE_SETUP
#line 389 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return MODIFY;
          }
        YY_BREAK case 210:
          YY_RULE_SETUP
#line 390 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return MODULE;
          }
        YY_BREAK case 211:
          YY_RULE_SETUP
#line 391 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return MONTH_;
          }
        YY_BREAK case 212:
          YY_RULE_SETUP
#line 392 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return Max;
          }
        YY_BREAK case 213:
          YY_RULE_SETUP
#line 393 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return Min;
          }
        YY_BREAK case 214:
          YY_RULE_SETUP
#line 394 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return NA;
          }
        YY_BREAK case 215:
          YY_RULE_SETUP
#line 395 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return NAME;
          }
        YY_BREAK case 216:
          YY_RULE_SETUP
#line 398 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return NATIONAL;
          }
        YY_BREAK case 217:
          YY_RULE_SETUP
#line 399 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return NATURAL;
          }
        YY_BREAK case 218:
          YY_RULE_SETUP
#line 400 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return NCHAR;
          }
        YY_BREAK case 219:
          YY_RULE_SETUP
#line 401 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return NEXT;
          }
        YY_BREAK case 220:
          YY_RULE_SETUP
#line 402 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return NO;
          }
        YY_BREAK case 221:
          YY_RULE_SETUP
#line 403 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return NOCACHE;
          }
        YY_BREAK case 222:
          YY_RULE_SETUP
#line 406 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return NOMAXVALUE;
          }
        YY_BREAK case 223:
          YY_RULE_SETUP
#line 409 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return NOMINVALUE;
          }
        YY_BREAK case 224:
          YY_RULE_SETUP
#line 412 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return NONE;
          }
        YY_BREAK case 225:
          YY_RULE_SETUP
#line 413 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return NOT;
          }
        YY_BREAK case 226:
          YY_RULE_SETUP
#line 414 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return NULLIF;
          }
        YY_BREAK case 227:
          YY_RULE_SETUP
#line 415 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return NUMERIC;
          }
        YY_BREAK case 228:
          YY_RULE_SETUP
#line 416 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return Null;
          }
        YY_BREAK case 229:
          YY_RULE_SETUP
#line 417 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return NULLS;
          }
        YY_BREAK case 230:
          YY_RULE_SETUP
#line 420 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return OBJECT;
          }
        YY_BREAK case 231:
          YY_RULE_SETUP
#line 421 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return OCTET_LENGTH;
          }
        YY_BREAK case 232:
          YY_RULE_SETUP
#line 422 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return OF;
          }
        YY_BREAK case 233:
          YY_RULE_SETUP
#line 423 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return OFF_;
          }
        YY_BREAK case 234:
          YY_RULE_SETUP
#line 424 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return OFFSET;
          }
        YY_BREAK case 235:
          YY_RULE_SETUP
#line 427 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ON_;
          }
        YY_BREAK case 236:
          YY_RULE_SETUP
#line 428 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return OPEN;
          }
        YY_BREAK case 237:
          YY_RULE_SETUP
#line 429 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return OPTIMIZATION;
          }
        YY_BREAK case 238:
          YY_RULE_SETUP
#line 430 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return OPTION;
          }
        YY_BREAK case 239:
          YY_RULE_SETUP
#line 431 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return OR;
          }
        YY_BREAK case 240:
          YY_RULE_SETUP
#line 432 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ORDER;
          }
        YY_BREAK case 241:
          YY_RULE_SETUP
#line 433 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return OUT_;
          }
        YY_BREAK case 242:
          YY_RULE_SETUP
#line 434 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return OUTER;
          }
        YY_BREAK case 243:
          YY_RULE_SETUP
#line 435 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return OUTPUT;
          }
        YY_BREAK case 244:
          YY_RULE_SETUP
#line 436 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return OVERLAPS;
          }
        YY_BREAK case 245:
          YY_RULE_SETUP
#line 437 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return OWNER;
          }
        YY_BREAK case 246:
          YY_RULE_SETUP
#line 440 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return PAGE;
          }
        YY_BREAK case 247:
          YY_RULE_SETUP
#line 443 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return PARAMETERS;
          }
        YY_BREAK case 248:
          YY_RULE_SETUP
#line 444 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return PARTIAL;
          }
        YY_BREAK case 249:
          YY_RULE_SETUP
#line 445 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return PASSWORD;
          }
        YY_BREAK case 250:
          YY_RULE_SETUP
#line 448 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return PERSIST;
          }
        YY_BREAK case 251:
          YY_RULE_SETUP
#line 449 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return POSITION;
          }
        YY_BREAK case 252:
          YY_RULE_SETUP
#line 450 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return PRECISION;
          }
        YY_BREAK case 253:
          YY_RULE_SETUP
#line 451 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return PRESERVE;
          }
        YY_BREAK case 254:
          YY_RULE_SETUP
#line 452 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return PRIMARY;
          }
        YY_BREAK case 255:
          YY_RULE_SETUP
#line 453 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return PRIVILEGES;
          }
        YY_BREAK case 256:
          YY_RULE_SETUP
#line 454 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return PROMOTE;
          }
        YY_BREAK case 257:
          YY_RULE_SETUP
#line 455 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return QUARTER;
          }
        YY_BREAK case 258:
          YY_RULE_SETUP
#line 458 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return RANGE_;
          }
        YY_BREAK case 259:
          YY_RULE_SETUP
#line 461 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return READ;
          }
        YY_BREAK case 260:
          YY_RULE_SETUP
#line 462 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return FLOAT_;
          }
        YY_BREAK case 261:
          YY_RULE_SETUP
#line 463 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return REBUILD;
          }
        YY_BREAK case 262:
          YY_RULE_SETUP
#line 464 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return RECURSIVE;
          }
        YY_BREAK case 263:
          YY_RULE_SETUP
#line 465 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return REF;
          }
        YY_BREAK case 264:
          YY_RULE_SETUP
#line 466 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return REFERENCES;
          }
        YY_BREAK case 265:
          YY_RULE_SETUP
#line 467 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return REFERENCING;
          }
        YY_BREAK case 266:
          YY_RULE_SETUP
#line 468 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return REGEXP;
          }
        YY_BREAK case 267:
          YY_RULE_SETUP
#line 469 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return RELATIVE_;
          }
        YY_BREAK case 268:
          YY_RULE_SETUP
#line 470 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return REMOVE;
          }
        YY_BREAK case 269:
          YY_RULE_SETUP
#line 473 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return RENAME;
          }
        YY_BREAK case 270:
          YY_RULE_SETUP
#line 474 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return REORGANIZE;
          }
        YY_BREAK case 271:
          YY_RULE_SETUP
#line 477 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return REPEATABLE;
          }
        YY_BREAK case 272:
          YY_RULE_SETUP
#line 480 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return REPLACE;
          }
        YY_BREAK case 273:
          YY_RULE_SETUP
#line 481 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return RESIGNAL;
          }
        YY_BREAK case 274:
          YY_RULE_SETUP
#line 482 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return RESTRICT;
          }
        YY_BREAK case 275:
          YY_RULE_SETUP
#line 483 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return RETURN;
          }
        YY_BREAK case 276:
          YY_RULE_SETUP
#line 484 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return RETURNS;
          }
        YY_BREAK case 277:
          YY_RULE_SETUP
#line 485 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return REVOKE;
          }
        YY_BREAK case 278:
          YY_RULE_SETUP
#line 486 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return RIGHT;
          }
        YY_BREAK case 279:
          YY_RULE_SETUP
#line 487 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return RLIKE;
          }
        YY_BREAK case 280:
          YY_RULE_SETUP
#line 488 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ROLE;
          }
        YY_BREAK case 281:
          YY_RULE_SETUP
#line 489 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ROLLBACK;
          }
        YY_BREAK case 282:
          YY_RULE_SETUP
#line 490 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ROLLUP;
          }
        YY_BREAK case 283:
          YY_RULE_SETUP
#line 491 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ROUTINE;
          }
        YY_BREAK case 284:
          YY_RULE_SETUP
#line 492 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ROW;
          }
        YY_BREAK case 285:
          YY_RULE_SETUP
#line 493 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ROWNUM;
          }
        YY_BREAK case 286:
          YY_RULE_SETUP
#line 494 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ROWS;
          }
        YY_BREAK case 287:
          YY_RULE_SETUP
#line 495 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SAVEPOINT;
          }
        YY_BREAK case 288:
          YY_RULE_SETUP
#line 496 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SCHEMA;
          }
        YY_BREAK case 289:
          YY_RULE_SETUP
#line 497 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SCOPE;
          }
        YY_BREAK case 290:
          YY_RULE_SETUP
#line 498 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SCROLL;
          }
        YY_BREAK case 291:
          YY_RULE_SETUP
#line 499 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SEARCH;
          }
        YY_BREAK case 292:
          YY_RULE_SETUP
#line 500 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SECOND_;
          }
        YY_BREAK case 293:
          YY_RULE_SETUP
#line 501 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SECOND_MILLISECOND;
          }
        YY_BREAK case 294:
          YY_RULE_SETUP
#line 502 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SECTION;
          }
        YY_BREAK case 295:
          YY_RULE_SETUP
#line 503 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SELECT;
          }
        YY_BREAK case 296:
          YY_RULE_SETUP
#line 504 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SENSITIVE;
          }
        YY_BREAK case 297:
          YY_RULE_SETUP
#line 505 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return SEPARATOR;
          }
        YY_BREAK case 298:
          YY_RULE_SETUP
#line 508 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SEQUENCE;
          }
        YY_BREAK case 299:
          YY_RULE_SETUP
#line 509 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SEQUENCE_OF;
          }
        YY_BREAK case 300:
          YY_RULE_SETUP
#line 510 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SERIALIZABLE;
          }
        YY_BREAK case 301:
          YY_RULE_SETUP
#line 511 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SESSION;
          }
        YY_BREAK case 302:
          YY_RULE_SETUP
#line 512 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SESSION_USER;
          }
        YY_BREAK case 303:
          YY_RULE_SETUP
#line 513 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SET;
          }
        YY_BREAK case 304:
          YY_RULE_SETUP
#line 514 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SHARD;
          }
        YY_BREAK case 305:
          YY_RULE_SETUP
#line 515 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SmallInt;
          }
        YY_BREAK case 306:
          YY_RULE_SETUP
#line 516 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return SHOW;
          }
        YY_BREAK case 307:
          YY_RULE_SETUP
#line 519 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SIMILAR;
          }
        YY_BREAK case 308:
          YY_RULE_SETUP
#line 520 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SIZE_;
          }
        YY_BREAK case 309:
          YY_RULE_SETUP
#line 521 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return SLOTS;
          }
        YY_BREAK case 310:
          YY_RULE_SETUP
#line 524 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return SLOTTED;
          }
        YY_BREAK case 311:
          YY_RULE_SETUP
#line 528 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SQL;
          }
        YY_BREAK case 312:
          YY_RULE_SETUP
#line 529 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SQLCODE;
          }
        YY_BREAK case 313:
          YY_RULE_SETUP
#line 530 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SQLERROR;
          }
        YY_BREAK case 314:
          YY_RULE_SETUP
#line 531 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SQLEXCEPTION;
          }
        YY_BREAK case 315:
          YY_RULE_SETUP
#line 532 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SQLSTATE;
          }
        YY_BREAK case 316:
          YY_RULE_SETUP
#line 533 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SQLWARNING;
          }
        YY_BREAK case 317:
          YY_RULE_SETUP
#line 534 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return STABILITY;
          }
        YY_BREAK case 318:
          YY_RULE_SETUP
#line 537 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return STATEMENT;
          }
        YY_BREAK case 319:
          YY_RULE_SETUP
#line 540 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return STATISTICS;
          }
        YY_BREAK case 320:
          YY_RULE_SETUP
#line 541 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return STATUS;
          }
        YY_BREAK case 321:
          YY_RULE_SETUP
#line 544 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return STDDEV;
          }
        YY_BREAK case 322:
          YY_RULE_SETUP
#line 547 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return STDDEV_POP;
          }
        YY_BREAK case 323:
          YY_RULE_SETUP
#line 550 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return STDDEV_SAMP;
          }
        YY_BREAK case 324:
          YY_RULE_SETUP
#line 553 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return STR_TO_DATE;
          }
        YY_BREAK case 325:
          YY_RULE_SETUP
#line 556 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return SUBDATE;
          }
        YY_BREAK case 326:
          YY_RULE_SETUP
#line 559 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SUBSTRING_;
          }
        YY_BREAK case 327:
          YY_RULE_SETUP
#line 560 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SUM;
          }
        YY_BREAK case 328:
          YY_RULE_SETUP
#line 561 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SYS_DATE;
          }
        YY_BREAK case 329:
          YY_RULE_SETUP
#line 562 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SYS_DATE;
          }
        YY_BREAK case 330:
          YY_RULE_SETUP
#line 563 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SYS_TIME_;
          }
        YY_BREAK case 331:
          YY_RULE_SETUP
#line 564 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SYS_TIME_;
          }
        YY_BREAK case 332:
          YY_RULE_SETUP
#line 565 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SYS_DATETIME;
          }
        YY_BREAK case 333:
          YY_RULE_SETUP
#line 566 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SYS_DATETIME;
          }
        YY_BREAK case 334:
          YY_RULE_SETUP
#line 567 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return SYSTEM;
          }
        YY_BREAK case 335:
          YY_RULE_SETUP
#line 570 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SYSTEM_USER;
          }
        YY_BREAK case 336:
          YY_RULE_SETUP
#line 571 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SmallInt;
          }
        YY_BREAK case 337:
          YY_RULE_SETUP
#line 572 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return String;
          }
        YY_BREAK case 338:
          YY_RULE_SETUP
#line 573 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return TABLE;
          }
        YY_BREAK case 339:
          YY_RULE_SETUP
#line 574 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return TABLES;
          }
        YY_BREAK case 340:
          YY_RULE_SETUP
#line 577 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return TEMPORARY;
          }
        YY_BREAK case 341:
          YY_RULE_SETUP
#line 578 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return TEXT;
          }
        YY_BREAK case 342:
          YY_RULE_SETUP
#line 581 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return THEN;
          }
        YY_BREAK case 343:
          YY_RULE_SETUP
#line 582 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return TIMEOUT;
          }
        YY_BREAK case 344:
          YY_RULE_SETUP
#line 585 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return TIMEZONE_HOUR;
          }
        YY_BREAK case 345:
          YY_RULE_SETUP
#line 586 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return TIMEZONE_MINUTE;
          }
        YY_BREAK case 346:
          YY_RULE_SETUP
#line 587 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return TO;
          }
        YY_BREAK case 347:
          YY_RULE_SETUP
#line 588 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return TRACE;
          }
        YY_BREAK case 348:
          YY_RULE_SETUP
#line 591 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return TRAILING_;
          }
        YY_BREAK case 349:
          YY_RULE_SETUP
#line 592 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return TRANSACTION;
          }
        YY_BREAK case 350:
          YY_RULE_SETUP
#line 593 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return TRANSLATE;
          }
        YY_BREAK case 351:
          YY_RULE_SETUP
#line 594 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return TRANSLATION;
          }
        YY_BREAK case 352:
          YY_RULE_SETUP
#line 595 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return TRIGGER;
          }
        YY_BREAK case 353:
          YY_RULE_SETUP
#line 596 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return TRIM;
          }
        YY_BREAK case 354:
          YY_RULE_SETUP
#line 597 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return Time;
          }
        YY_BREAK case 355:
          YY_RULE_SETUP
#line 598 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return SmallInt;
          }
        YY_BREAK case 356:
          YY_RULE_SETUP
#line 599 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return True;
          }
        YY_BREAK case 357:
          YY_RULE_SETUP
#line 600 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return TRUNCATE;
          }
        YY_BREAK case 358:
          YY_RULE_SETUP
#line 601 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return UCASE;
          }
        YY_BREAK case 359:
          YY_RULE_SETUP
#line 604 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return UNCOMMITTED;
          }
        YY_BREAK case 360:
          YY_RULE_SETUP
#line 607 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return UNIQUE;
          }
        YY_BREAK case 361:
          YY_RULE_SETUP
#line 608 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return UNKNOWN;
          }
        YY_BREAK case 362:
          YY_RULE_SETUP
#line 609 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return UPDATE;
          }
        YY_BREAK case 363:
          YY_RULE_SETUP
#line 610 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return UPPER;
          }
        YY_BREAK case 364:
          YY_RULE_SETUP
#line 611 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return USAGE;
          }
        YY_BREAK case 365:
          YY_RULE_SETUP
#line 612 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return USE;
          }
        YY_BREAK case 366:
          YY_RULE_SETUP
#line 613 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return USER;
          }
        YY_BREAK case 367:
          YY_RULE_SETUP
#line 614 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return USING;
          }
        YY_BREAK case 368:
          YY_RULE_SETUP
#line 615 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return Union;
          }
        YY_BREAK case 369:
          YY_RULE_SETUP
#line 616 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return VALUE;
          }
        YY_BREAK case 370:
          YY_RULE_SETUP
#line 617 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return VALUES;
          }
        YY_BREAK case 371:
          YY_RULE_SETUP
#line 618 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return VAR_POP;
          }
        YY_BREAK case 372:
          YY_RULE_SETUP
#line 621 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return VAR_SAMP;
          }
        YY_BREAK case 373:
          YY_RULE_SETUP
#line 624 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return VARBINARY;
          }
        YY_BREAK case 374:
          YY_RULE_SETUP
#line 625 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return VARCHAR;
          }
        YY_BREAK case 375:
          YY_RULE_SETUP
#line 626 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return VARIANCE;
          }
        YY_BREAK case 376:
          YY_RULE_SETUP
#line 629 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return VARYING;
          }
        YY_BREAK case 377:
          YY_RULE_SETUP
#line 630 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return VIEW;
          }
        YY_BREAK case 378:
          YY_RULE_SETUP
#line 631 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return VOLUME;
          }
        YY_BREAK case 379:
          YY_RULE_SETUP
#line 634 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return WEEK;
          }
        YY_BREAK case 380:
          YY_RULE_SETUP
#line 637 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return WHEN;
          }
        YY_BREAK case 381:
          YY_RULE_SETUP
#line 638 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return WHENEVER;
          }
        YY_BREAK case 382:
          YY_RULE_SETUP
#line 639 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return WHERE;
          }
        YY_BREAK case 383:
          YY_RULE_SETUP
#line 640 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return WHILE;
          }
        YY_BREAK case 384:
          YY_RULE_SETUP
#line 641 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return WITH;
          }
        YY_BREAK case 385:
          YY_RULE_SETUP
#line 642 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return WITHOUT;
          }
        YY_BREAK case 386:
          YY_RULE_SETUP
#line 643 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return WORK;
          }
        YY_BREAK case 387:
          YY_RULE_SETUP
#line 644 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return WRITE;
          }
        YY_BREAK case 388:
          YY_RULE_SETUP
#line 645 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return XOR;
          }
        YY_BREAK case 389:
          YY_RULE_SETUP
#line 646 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return YEAR_;
          }
        YY_BREAK case 390:
          YY_RULE_SETUP
#line 647 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return YEAR_MONTH;
          }
        YY_BREAK case 391:
          YY_RULE_SETUP
#line 648 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return ZONE;
          }
        YY_BREAK case 392:
          YY_RULE_SETUP
#line 651 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return Null;
          }
        YY_BREAK case 393:
          YY_RULE_SETUP
#line 653 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return RIGHT_ARROW;
          }
        YY_BREAK case 394:
          YY_RULE_SETUP
#line 654 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return STRCAT;
          }
        YY_BREAK case 395:
          YY_RULE_SETUP
#line 656 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return COMP_NOT_EQ;
          }
        YY_BREAK case 396:
          YY_RULE_SETUP
#line 657 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return COMP_GE;
          }
        YY_BREAK case 397:
          YY_RULE_SETUP
#line 658 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return COMP_LE;
          }
        YY_BREAK case 398:
          YY_RULE_SETUP
#line 659 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return PARAM_HEADER;
          }
        YY_BREAK case 399:
          YY_RULE_SETUP
#line 660 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return COMP_NOT_EQ;
          }
        YY_BREAK case 400:
          YY_RULE_SETUP
#line 661 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return BITSHIFT_LEFT;
          }
        YY_BREAK case 401:
          YY_RULE_SETUP
#line 662 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return BITSHIFT_RIGHT;
          }
        YY_BREAK case 402:
          YY_RULE_SETUP
#line 663 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return MOD;
          }
        YY_BREAK case 403:
          YY_RULE_SETUP
#line 664 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return COMP_NULLSAFE_EQ;
          }
        YY_BREAK case 404:
          YY_RULE_SETUP
#line 667 "../../src/parser/rsql_lexer.l"
          {
            int i = 0;
            int len = 0;

            begin_token (rsql_yytext);
            len = strlen (rsql_yytext);
            if (len >= 254)
              rsql_yytext[254] = 0;

            /* loop until len - 1, in case of 0000000000000000000000 */
            for (i = 0; i < len - 1 && rsql_yytext[i] == '0'; i++)
              ;

            rsql_yylval.cptr = pt_makename (&rsql_yytext[i]);
            return UNSIGNED_INTEGER;
          }
        YY_BREAK case 405:
          YY_RULE_SETUP
#line 686 "../../src/parser/rsql_lexer.l"
          {
            char buff[256];
            int len;

            begin_token (rsql_yytext);
            len = strlen (rsql_yytext);
            if (len >= 254)
              rsql_yytext[254] = 0;

            if (len < 253 && rsql_yytext[len - 1] == '.')
              {
                strncpy (buff, rsql_yytext, sizeof (buff));
                buff[len] = '0';
                buff[len + 1] = '\0';
                rsql_yylval.cptr = pt_makename (buff);
              }
            else
              {
                rsql_yylval.cptr = pt_makename (rsql_yytext);
              }
            return UNSIGNED_REAL;
          }
        YY_BREAK case 406:
          YY_RULE_SETUP
#line 709 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            if (strlen (rsql_yytext) >= 254)
              rsql_yytext[254] = 0;
            rsql_yylval.cptr = pt_makename (rsql_yytext);
            return IdName;
          }
        YY_BREAK case 407:
          YY_RULE_SETUP
#line 715 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, NULL, rsql_yytext + 2);
            return BIT_STRING;
          }
        YY_BREAK case 408:
          YY_RULE_SETUP
#line 720 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, NULL, rsql_yytext + 2);
            return HEX_STRING;
          }
        YY_BREAK case 409:
          YY_RULE_SETUP
#line 725 "../../src/parser/rsql_lexer.l"
          {
            BEGIN (QUOTED_NCHAR_STRING);
            rsql_yylval.cptr = pt_append_string (this_parser, NULL, "");
          }
        YY_BREAK case 410:
          YY_RULE_SETUP
#line 730 "../../src/parser/rsql_lexer.l"
          {
            BEGIN (QUOTED_BIT_STRING);
            rsql_yylval.cptr = pt_append_string (this_parser, NULL, "");
          }
        YY_BREAK case 411:
          YY_RULE_SETUP
#line 735 "../../src/parser/rsql_lexer.l"
          {
            BEGIN (QUOTED_HEX_STRING);
            rsql_yylval.cptr = pt_append_string (this_parser, NULL, "");
          }
        YY_BREAK case 412:
          YY_RULE_SETUP
#line 740 "../../src/parser/rsql_lexer.l"
          {
            BEGIN (QUOTED_CHAR_STRING);
            rsql_yylval.cptr = pt_append_string (this_parser, NULL, "");
          }
        YY_BREAK case 413:
          YY_RULE_SETUP
#line 745 "../../src/parser/rsql_lexer.l"
          {
            if (prm_get_bool_value (PRM_ID_ANSI_QUOTES))
              {
                BEGIN (DELIMITED_ID_NAME);
              }
            else
              {
                BEGIN (DOUBLY_QUOTED_CHAR_STRING);
              }
            rsql_yylval.cptr = pt_append_string (this_parser, NULL, "");
          }
        YY_BREAK case 414:
          YY_RULE_SETUP
#line 757 "../../src/parser/rsql_lexer.l"
          {
            BEGIN (BRACKET_ID_NAME);
            rsql_yylval.cptr = pt_append_string (this_parser, NULL, "");
          }
        YY_BREAK case 415:
          YY_RULE_SETUP
#line 762 "../../src/parser/rsql_lexer.l"
          {
            BEGIN (BACKTICK_ID_NAME);
            rsql_yylval.cptr = pt_append_string (this_parser, NULL, "");
          }
        YY_BREAK case 416:
          YY_RULE_SETUP
#line 767 "../../src/parser/rsql_lexer.l"
          {
            BEGIN (INITIAL);
            return NCHAR_STRING;
          }
        YY_BREAK case 417:
          YY_RULE_SETUP
#line 772 "../../src/parser/rsql_lexer.l"
          {
            BEGIN (INITIAL);
            return BIT_STRING;
          }
        YY_BREAK case 418:
          YY_RULE_SETUP
#line 777 "../../src/parser/rsql_lexer.l"
          {
            BEGIN (INITIAL);
            return HEX_STRING;
          }
        YY_BREAK case 419:
          YY_RULE_SETUP
#line 782 "../../src/parser/rsql_lexer.l"
          {
            BEGIN (INITIAL);
            return CHAR_STRING;
          }
        YY_BREAK case 420:
          YY_RULE_SETUP
#line 787 "../../src/parser/rsql_lexer.l"
          {
            BEGIN (INITIAL);
            return CHAR_STRING;
          }
        YY_BREAK case 421:
          YY_RULE_SETUP
#line 792 "../../src/parser/rsql_lexer.l"
          {
            BEGIN (INITIAL);
            if (strlen (rsql_yylval.cptr) >= 254)
              {
                rsql_yylval.cptr[254] = 0;
              }
            return DelimitedIdName;
          }
        YY_BREAK case 422:
          YY_RULE_SETUP
#line 801 "../../src/parser/rsql_lexer.l"
          {
            BEGIN (INITIAL);
            if (strlen (rsql_yylval.cptr) >= 254)
              {
                rsql_yylval.cptr[254] = 0;
              }
            return BracketDelimitedIdName;
          }
        YY_BREAK case 423:
          YY_RULE_SETUP
#line 810 "../../src/parser/rsql_lexer.l"
          {
            BEGIN (INITIAL);
            if (strlen (rsql_yylval.cptr) >= 254)
              {
                rsql_yylval.cptr[254] = 0;
              }
            return BacktickDelimitedIdName;
          }
        YY_BREAK case 424:
/* rule 424 can match eol */
          YY_RULE_SETUP
#line 819 "../../src/parser/rsql_lexer.l"
          {
            this_parser->line = yyline++;
            this_parser->column = yycolumn = yycolumn_end = 0;
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, "\n");
          }
        YY_BREAK case YY_STATE_EOF (QUOTED_NCHAR_STRING):
        case YY_STATE_EOF (QUOTED_BIT_STRING):
        case YY_STATE_EOF (QUOTED_HEX_STRING):
        case YY_STATE_EOF (QUOTED_CHAR_STRING):
        case YY_STATE_EOF (DOUBLY_QUOTED_CHAR_STRING):
#line 825 "../../src/parser/rsql_lexer.l"
          {
            BEGIN (INITIAL);
            rsql_yyerror ("unterminated string");
            return UNTERMINATED_STRING;
          }
        YY_BREAK case YY_STATE_EOF (DELIMITED_ID_NAME):
        case YY_STATE_EOF (BRACKET_ID_NAME):
        case YY_STATE_EOF (BACKTICK_ID_NAME):
#line 831 "../../src/parser/rsql_lexer.l"
          {
            BEGIN (INITIAL);
            rsql_yyerror ("unterminated identifier");
            return UNTERMINATED_IDENTIFIER;
          }
        YY_BREAK case 425:
          YY_RULE_SETUP
#line 837 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, rsql_yytext);
          }
        YY_BREAK case 426:
          YY_RULE_SETUP
#line 841 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, rsql_yytext);
          }
        YY_BREAK case 427:
          YY_RULE_SETUP
#line 845 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, rsql_yytext);
          }
        YY_BREAK case 428:
          YY_RULE_SETUP
#line 849 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, rsql_yytext);
          }
        YY_BREAK case 429:
          YY_RULE_SETUP
#line 853 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, rsql_yytext);
          }
        YY_BREAK case 430:
          YY_RULE_SETUP
#line 857 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, rsql_yytext);
          }
        YY_BREAK case 431:
          YY_RULE_SETUP
#line 861 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, "'");
          }
        YY_BREAK case 432:
          YY_RULE_SETUP
#line 865 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, "\"");
          }
        YY_BREAK case 433:
          YY_RULE_SETUP
#line 869 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, "`");
          }
        YY_BREAK case 434:
          YY_RULE_SETUP
#line 875 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, "\\n");
          }
        YY_BREAK case 435:
          YY_RULE_SETUP
#line 879 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, "\\r");
          }
        YY_BREAK case 436:
          YY_RULE_SETUP
#line 883 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, "\\t");
          }
        YY_BREAK case 437:
          YY_RULE_SETUP
#line 887 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, "\\%");
          }
        YY_BREAK case 438:
          YY_RULE_SETUP
#line 891 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, "\\_");
          }
        YY_BREAK case 439:
          YY_RULE_SETUP
#line 895 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, "\\");
            unput (*(rsql_yytext + 1));
            yybuffer_pos--;

          }
        YY_BREAK case 440:
          YY_RULE_SETUP
#line 902 "../../src/parser/rsql_lexer.l"
          {
            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, rsql_yytext);
          }
        YY_BREAK case 441:
/* rule 441 can match eol */
          YY_RULE_SETUP
#line 906 "../../src/parser/rsql_lexer.l"
          {
            this_parser->line = yyline++;
            this_parser->column = yycolumn = yycolumn_end = 0;

            rsql_yylval.cptr = pt_append_string (this_parser, rsql_yylval.cptr, "\\\n");
          }
        YY_BREAK case 442:
          YY_RULE_SETUP
#line 915 "../../src/parser/rsql_lexer.l"
          {
            char *cp = parser_line_hint ();
            if (cp)
              {
                rsql_yylval.cptr = cp;
                return CPP_STYLE_HINT;
              }
          }
        YY_BREAK case 443:
          YY_RULE_SETUP
#line 925 "../../src/parser/rsql_lexer.l"
          {
            char *cp = parser_c_hint ();
            if (cp)
              {
                rsql_yylval.cptr = cp;
                return C_STYLE_HINT;
              }
          }
        YY_BREAK case 444:
          YY_RULE_SETUP
#line 936 "../../src/parser/rsql_lexer.l"
          {
            char *cp = parser_line_hint ();
            if (cp)
              {
                rsql_yylval.cptr = cp;
                return SQL_STYLE_HINT;
              }
          }
        YY_BREAK case 445:
          YY_RULE_SETUP
#line 946 "../../src/parser/rsql_lexer.l"
          {
            begin_token (rsql_yytext);
            return rsql_yytext[0];
          }
        YY_BREAK case 446:
          YY_RULE_SETUP
#line 947 "../../src/parser/rsql_lexer.l"
            ECHO;
          YY_BREAK
#line 4508 "../../src/parser/rsql_lexer.c"
        case YY_STATE_EOF (INITIAL):
          yyterminate ();

        case YY_END_OF_BUFFER:
          {
            /* Amount of text matched not including the EOB char. */
            int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;

            /* Undo the effects of YY_DO_BEFORE_ACTION. */
            *yy_cp = (yy_hold_char);
            YY_RESTORE_YY_MORE_OFFSET if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW)
              {
                /* We're scanning a new file or input source.  It's
                 * possible that this happened because the user
                 * just pointed rsql_yyin at a new source and called
                 * rsql_yylex().  If so, then we have to assure
                 * consistency between YY_CURRENT_BUFFER and our
                 * globals.  Here is the right place to do so, because
                 * this is the first action (other than possibly a
                 * back-up) that will match for the new input source.
                 */
                (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                YY_CURRENT_BUFFER_LVALUE->yy_input_file = rsql_yyin;
                YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
              }

            /* Note that here we test for yy_c_buf_p "<=" to the position
             * of the first EOB in the buffer, since yy_c_buf_p will
             * already have been incremented past the NUL character
             * (since all states make transitions on EOB to the
             * end-of-buffer state).  Contrast this with the test
             * in input().
             */
            if ((yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
              {                 /* This was really a NUL. */
                yy_state_type yy_next_state;

                (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state ();

                /* Okay, we're now positioned to make the NUL
                 * transition.  We couldn't have
                 * yy_get_previous_state() go ahead and do it
                 * for us because it doesn't know how to deal
                 * with the possibility of jamming (and we don't
                 * want to build jamming into it because then it
                 * will run more slowly).
                 */

                yy_next_state = yy_try_NUL_trans (yy_current_state);

                yy_bp = (yytext_ptr) + YY_MORE_ADJ;

                if (yy_next_state)
                  {
                    /* Consume the NUL. */
                    yy_cp = ++(yy_c_buf_p);
                    yy_current_state = yy_next_state;
                    goto yy_match;
                  }

                else
                  {
                    yy_cp = (yy_c_buf_p);
                    goto yy_find_action;
                  }
              }

            else
              switch (yy_get_next_buffer ())
                {
                case EOB_ACT_END_OF_FILE:
                  {
                    (yy_did_buffer_switch_on_eof) = 0;

                    if (rsql_yywrap ())
                      {
                        /* Note: because we've taken care in
                         * yy_get_next_buffer() to have set up
                         * rsql_yytext, we can now set up
                         * yy_c_buf_p so that if some total
                         * hoser (like flex itself) wants to
                         * call the scanner after we return the
                         * YY_NULL, it'll still work - another
                         * YY_NULL will get returned.
                         */
                        (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

                        yy_act = YY_STATE_EOF (YY_START);
                        goto do_action;
                      }

                    else
                      {
                        if (!(yy_did_buffer_switch_on_eof))
                          YY_NEW_FILE;
                      }
                    break;
                  }

                case EOB_ACT_CONTINUE_SCAN:
                  (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

                  yy_current_state = yy_get_previous_state ();

                  yy_cp = (yy_c_buf_p);
                  yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                  goto yy_match;

                case EOB_ACT_LAST_MATCH:
                  (yy_c_buf_p) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

                  yy_current_state = yy_get_previous_state ();

                  yy_cp = (yy_c_buf_p);
                  yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                  goto yy_find_action;
                }
            break;
          }

        default:
          YY_FATAL_ERROR ("fatal flex scanner internal error--no action found");
        }                       /* end of action switch */
    }                           /* end of scanning one token */
}                               /* end of rsql_yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int
yy_get_next_buffer (void)
{
  register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  register char *source = (yytext_ptr);
  register int number_to_move, i;
  int ret_val;

  if ((yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1])
    YY_FATAL_ERROR ("fatal flex scanner internal error--end of buffer missed");

  if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0)
    {                           /* Don't try to fill the buffer, so this is an EOF. */
      if ((yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1)
        {
          /* We matched a single character, the EOB, so
           * treat this as a final EOF.
           */
          return EOB_ACT_END_OF_FILE;
        }

      else
        {
          /* We matched some text prior to the EOB, first
           * process it.
           */
          return EOB_ACT_LAST_MATCH;
        }
    }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;

  for (i = 0; i < number_to_move; ++i)
    *(dest++) = *(source++);

  if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

  else
    {
      int num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

      while (num_to_read <= 0)
        {                       /* Not enough room in the buffer - grow it. */

          /* just a shorter name for the current buffer */
          YY_BUFFER_STATE b = YY_CURRENT_BUFFER;

          int yy_c_buf_p_offset = (int) ((yy_c_buf_p) - b->yy_ch_buf);

          if (b->yy_is_our_buffer)
            {
              int new_size = b->yy_buf_size * 2;

              if (new_size <= 0)
                b->yy_buf_size += b->yy_buf_size / 8;
              else
                b->yy_buf_size *= 2;

              b->yy_ch_buf = (char *)
                /* Include room in for 2 EOB chars. */
                rsql_yyrealloc ((void *) b->yy_ch_buf, b->yy_buf_size + 2);
            }
          else
            /* Can't grow it, we don't own it. */
            b->yy_ch_buf = 0;

          if (!b->yy_ch_buf)
            YY_FATAL_ERROR ("fatal error - scanner input buffer overflow");

          (yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

          num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

        }

      if (num_to_read > YY_READ_BUF_SIZE)
        num_to_read = YY_READ_BUF_SIZE;

      /* Read in more data. */
      YY_INPUT ((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]), (yy_n_chars), (size_t) num_to_read);

      YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
    }

  if ((yy_n_chars) == 0)
    {
      if (number_to_move == YY_MORE_ADJ)
        {
          ret_val = EOB_ACT_END_OF_FILE;
          rsql_yyrestart (rsql_yyin);
        }

      else
        {
          ret_val = EOB_ACT_LAST_MATCH;
          YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
        }
    }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size)
    {
      /* Extend the array by 50%, plus the number we really need. */
      yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
      YY_CURRENT_BUFFER_LVALUE->yy_ch_buf =
        (char *) rsql_yyrealloc ((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, new_size);
      if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
        YY_FATAL_ERROR ("out of dynamic memory in yy_get_next_buffer()");
    }

  (yy_n_chars) += number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

  (yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type
yy_get_previous_state (void)
{
  register yy_state_type yy_current_state;
  register char *yy_cp;

  yy_current_state = (yy_start);

  for (yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp)
    {
      register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI (*yy_cp)] : 1);
      if (yy_accept[yy_current_state])
        {
          (yy_last_accepting_state) = yy_current_state;
          (yy_last_accepting_cpos) = yy_cp;
        }
      while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
        {
          yy_current_state = (int) yy_def[yy_current_state];
          if (yy_current_state >= 1725)
            yy_c = yy_meta[(unsigned int) yy_c];
        }
      yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
    }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
static yy_state_type
yy_try_NUL_trans (yy_state_type yy_current_state)
{
  register int yy_is_jam;
  register char *yy_cp = (yy_c_buf_p);

  register YY_CHAR yy_c = 1;
  if (yy_accept[yy_current_state])
    {
      (yy_last_accepting_state) = yy_current_state;
      (yy_last_accepting_cpos) = yy_cp;
    }
  while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state)
    {
      yy_current_state = (int) yy_def[yy_current_state];
      if (yy_current_state >= 1725)
        yy_c = yy_meta[(unsigned int) yy_c];
    }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
  yy_is_jam = (yy_current_state == 1724);

  return yy_is_jam ? 0 : yy_current_state;
}

static void
yyunput (int c, register char *yy_bp)
{
  register char *yy_cp;

  yy_cp = (yy_c_buf_p);

  /* undo effects of setting up rsql_yytext */
  *yy_cp = (yy_hold_char);

  if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
    {                           /* need to shift things up to make room */
      /* +2 for EOB chars. */
      register int number_to_move = (yy_n_chars) + 2;
      register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
      register char *source = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

      while (source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
        *--dest = *--source;

      yy_cp += (int) (dest - source);
      yy_bp += (int) (dest - source);
      YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

      if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
        YY_FATAL_ERROR ("flex scanner push-back overflow");
    }

  *--yy_cp = (char) c;

  (yytext_ptr) = yy_bp;
  (yy_hold_char) = *yy_cp;
  (yy_c_buf_p) = yy_cp;
}

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int
yyinput (void)
#else
static int
input (void)
#endif
{
  int c;

  *(yy_c_buf_p) = (yy_hold_char);

  if (*(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR)
    {
      /* yy_c_buf_p now points to the character we want to return.
       * If this occurs *before* the EOB characters, then it's a
       * valid NUL; if not, then we've hit the end of the buffer.
       */
      if ((yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
        /* This was really a NUL. */
        *(yy_c_buf_p) = '\0';

      else
        {                       /* need more input */
          int offset = (yy_c_buf_p) - (yytext_ptr);
          ++(yy_c_buf_p);

          switch (yy_get_next_buffer ())
            {
            case EOB_ACT_LAST_MATCH:
              /* This happens because yy_g_n_b()
               * sees that we've accumulated a
               * token and flags that we need to
               * try matching the token before
               * proceeding.  But for input(),
               * there's no matching to consider.
               * So convert the EOB_ACT_LAST_MATCH
               * to EOB_ACT_END_OF_FILE.
               */

              /* Reset buffer status. */
              rsql_yyrestart (rsql_yyin);

             /*FALLTHROUGH*/ case EOB_ACT_END_OF_FILE:
              {
                if (rsql_yywrap ())
                  return EOF;

                if (!(yy_did_buffer_switch_on_eof))
                  YY_NEW_FILE;
#ifdef __cplusplus
                return yyinput ();
#else
                return input ();
#endif
              }

            case EOB_ACT_CONTINUE_SCAN:
              (yy_c_buf_p) = (yytext_ptr) + offset;
              break;
            }
        }
    }

  c = *(unsigned char *) (yy_c_buf_p);  /* cast for 8-bit char's */
  *(yy_c_buf_p) = '\0';         /* preserve rsql_yytext */
  (yy_hold_char) = *++(yy_c_buf_p);

  return c;
}
#endif /* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * 
 * @note This function does not reset the start condition to @c INITIAL .
 */
void
rsql_yyrestart (FILE * input_file)
{

  if (!YY_CURRENT_BUFFER)
    {
      rsql_yyensure_buffer_stack ();
      YY_CURRENT_BUFFER_LVALUE = rsql_yy_create_buffer (rsql_yyin, YY_BUF_SIZE);
    }

  rsql_yy_init_buffer (YY_CURRENT_BUFFER, input_file);
  rsql_yy_load_buffer_state ();
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * 
 */
void
rsql_yy_switch_to_buffer (YY_BUFFER_STATE new_buffer)
{

  /* TODO. We should be able to replace this entire function body
   * with
   *              rsql_yypop_buffer_state();
   *              rsql_yypush_buffer_state(new_buffer);
   */
  rsql_yyensure_buffer_stack ();
  if (YY_CURRENT_BUFFER == new_buffer)
    return;

  if (YY_CURRENT_BUFFER)
    {
      /* Flush out information for old buffer. */
      *(yy_c_buf_p) = (yy_hold_char);
      YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
      YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
    }

  YY_CURRENT_BUFFER_LVALUE = new_buffer;
  rsql_yy_load_buffer_state ();

  /* We don't actually know whether we did this switch during
   * EOF (rsql_yywrap()) processing, but the only time this flag
   * is looked at is after rsql_yywrap() is called, so it's safe
   * to go ahead and always set it.
   */
  (yy_did_buffer_switch_on_eof) = 1;
}

static void
rsql_yy_load_buffer_state (void)
{
  (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
  (yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
  rsql_yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
  (yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * 
 * @return the allocated buffer state.
 */
YY_BUFFER_STATE
rsql_yy_create_buffer (FILE * file, int size)
{
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE) rsql_yyalloc (sizeof (struct yy_buffer_state));
  if (!b)
    YY_FATAL_ERROR ("out of dynamic memory in rsql_yy_create_buffer()");

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char *) rsql_yyalloc (b->yy_buf_size + 2);
  if (!b->yy_ch_buf)
    YY_FATAL_ERROR ("out of dynamic memory in rsql_yy_create_buffer()");

  b->yy_is_our_buffer = 1;

  rsql_yy_init_buffer (b, file);

  return b;
}

/** Destroy the buffer.
 * @param b a buffer created with rsql_yy_create_buffer()
 * 
 */
void
rsql_yy_delete_buffer (YY_BUFFER_STATE b)
{

  if (!b)
    return;

  if (b == YY_CURRENT_BUFFER)   /* Not sure if we should pop here. */
    YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

  if (b->yy_is_our_buffer)
    rsql_yyfree ((void *) b->yy_ch_buf);

  rsql_yyfree ((void *) b);
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a rsql_yyrestart() or at EOF.
 */
static void
rsql_yy_init_buffer (YY_BUFFER_STATE b, FILE * file)
{
  int oerrno = errno;

  rsql_yy_flush_buffer (b);

  b->yy_input_file = file;
  b->yy_fill_buffer = 1;

  /* If b is the current buffer, then rsql_yy_init_buffer was _probably_
   * called from rsql_yyrestart() or through yy_get_next_buffer.
   * In that case, we don't want to reset the lineno or column.
   */
  if (b != YY_CURRENT_BUFFER)
    {
      b->yy_bs_lineno = 1;
      b->yy_bs_column = 0;
    }

  b->yy_is_interactive = 0;

  errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * 
 */
void
rsql_yy_flush_buffer (YY_BUFFER_STATE b)
{
  if (!b)
    return;

  b->yy_n_chars = 0;

  /* We always need two end-of-buffer characters.  The first causes
   * a transition to the end-of-buffer state.  The second causes
   * a jam in that state.
   */
  b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
  b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

  b->yy_buf_pos = &b->yy_ch_buf[0];

  b->yy_at_bol = 1;
  b->yy_buffer_status = YY_BUFFER_NEW;

  if (b == YY_CURRENT_BUFFER)
    rsql_yy_load_buffer_state ();
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  
 */
void
rsql_yypush_buffer_state (YY_BUFFER_STATE new_buffer)
{
  if (new_buffer == NULL)
    return;

  rsql_yyensure_buffer_stack ();

  /* This block is copied from rsql_yy_switch_to_buffer. */
  if (YY_CURRENT_BUFFER)
    {
      /* Flush out information for old buffer. */
      *(yy_c_buf_p) = (yy_hold_char);
      YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
      YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
    }

  /* Only push if top exists. Otherwise, replace top. */
  if (YY_CURRENT_BUFFER)
    (yy_buffer_stack_top)++;
  YY_CURRENT_BUFFER_LVALUE = new_buffer;

  /* copied from rsql_yy_switch_to_buffer. */
  rsql_yy_load_buffer_state ();
  (yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  
 */
void
rsql_yypop_buffer_state (void)
{
  if (!YY_CURRENT_BUFFER)
    return;

  rsql_yy_delete_buffer (YY_CURRENT_BUFFER);
  YY_CURRENT_BUFFER_LVALUE = NULL;
  if ((yy_buffer_stack_top) > 0)
    --(yy_buffer_stack_top);

  if (YY_CURRENT_BUFFER)
    {
      rsql_yy_load_buffer_state ();
      (yy_did_buffer_switch_on_eof) = 1;
    }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void
rsql_yyensure_buffer_stack (void)
{
  int num_to_alloc;

  if (!(yy_buffer_stack))
    {

      /* First allocation is just for 2 elements, since we don't know if this
       * scanner will even need a stack. We use 2 instead of 1 to avoid an
       * immediate realloc on the next call.
       */
      num_to_alloc = 1;
      (yy_buffer_stack) = (struct yy_buffer_state **) rsql_yyalloc (num_to_alloc * sizeof (struct yy_buffer_state *));
      if (!(yy_buffer_stack))
        YY_FATAL_ERROR ("out of dynamic memory in rsql_yyensure_buffer_stack()");

      memset ((yy_buffer_stack), 0, num_to_alloc * sizeof (struct yy_buffer_state *));

      (yy_buffer_stack_max) = num_to_alloc;
      (yy_buffer_stack_top) = 0;
      return;
    }

  if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1)
    {

      /* Increase the buffer to prepare for a possible push. */
      int grow_size = 8 /* arbitrary grow size */ ;

      num_to_alloc = (yy_buffer_stack_max) + grow_size;
      (yy_buffer_stack) = (struct yy_buffer_state **) rsql_yyrealloc
        ((yy_buffer_stack), num_to_alloc * sizeof (struct yy_buffer_state *));
      if (!(yy_buffer_stack))
        YY_FATAL_ERROR ("out of dynamic memory in rsql_yyensure_buffer_stack()");

      /* zero only the new slots. */
      memset ((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof (struct yy_buffer_state *));
      (yy_buffer_stack_max) = num_to_alloc;
    }
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * 
 * @return the newly allocated buffer state object. 
 */
YY_BUFFER_STATE
rsql_yy_scan_buffer (char *base, yy_size_t size)
{
  YY_BUFFER_STATE b;

  if (size < 2 || base[size - 2] != YY_END_OF_BUFFER_CHAR || base[size - 1] != YY_END_OF_BUFFER_CHAR)
    /* They forgot to leave room for the EOB's. */
    return 0;

  b = (YY_BUFFER_STATE) rsql_yyalloc (sizeof (struct yy_buffer_state));
  if (!b)
    YY_FATAL_ERROR ("out of dynamic memory in rsql_yy_scan_buffer()");

  b->yy_buf_size = size - 2;    /* "- 2" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = 0;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  rsql_yy_switch_to_buffer (b);

  return b;
}

/** Setup the input buffer state to scan a string. The next call to rsql_yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * 
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       rsql_yy_scan_bytes() instead.
 */
YY_BUFFER_STATE
rsql_yy_scan_string (yyconst char *yystr)
{

  return rsql_yy_scan_bytes (yystr, strlen (yystr));
}

/** Setup the input buffer state to scan the given bytes. The next call to rsql_yylex() will
 * scan from a @e copy of @a bytes.
 * @param bytes the byte buffer to scan
 * @param len the number of bytes in the buffer pointed to by @a bytes.
 * 
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE
rsql_yy_scan_bytes (yyconst char *yybytes, int _yybytes_len)
{
  YY_BUFFER_STATE b;
  char *buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = _yybytes_len + 2;
  buf = (char *) rsql_yyalloc (n);
  if (!buf)
    YY_FATAL_ERROR ("out of dynamic memory in rsql_yy_scan_bytes()");

  for (i = 0; i < _yybytes_len; ++i)
    buf[i] = yybytes[i];

  buf[_yybytes_len] = buf[_yybytes_len + 1] = YY_END_OF_BUFFER_CHAR;

  b = rsql_yy_scan_buffer (buf, n);
  if (!b)
    YY_FATAL_ERROR ("bad buffer in rsql_yy_scan_bytes()");

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void
yy_fatal_error (yyconst char *msg)
{
  (void) fprintf (stderr, "%s\n", msg);
  exit (YY_EXIT_FAILURE);
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up rsql_yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		rsql_yytext[rsql_yyleng] = (yy_hold_char); \
		(yy_c_buf_p) = rsql_yytext + yyless_macro_arg; \
		(yy_hold_char) = *(yy_c_buf_p); \
		*(yy_c_buf_p) = '\0'; \
		rsql_yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 * 
 */
int
rsql_yyget_lineno (void)
{

  return rsql_yylineno;
}

/** Get the input stream.
 * 
 */
FILE *
rsql_yyget_in (void)
{
  return rsql_yyin;
}

/** Get the output stream.
 * 
 */
FILE *
rsql_yyget_out (void)
{
  return rsql_yyout;
}

/** Get the length of the current token.
 * 
 */
int
rsql_yyget_leng (void)
{
  return rsql_yyleng;
}

/** Get the current token.
 * 
 */

char *
rsql_yyget_text (void)
{
  return rsql_yytext;
}

/** Set the current line number.
 * @param line_number
 * 
 */
void
rsql_yyset_lineno (int line_number)
{

  rsql_yylineno = line_number;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * 
 * @see rsql_yy_switch_to_buffer
 */
void
rsql_yyset_in (FILE * in_str)
{
  rsql_yyin = in_str;
}

void
rsql_yyset_out (FILE * out_str)
{
  rsql_yyout = out_str;
}

int
rsql_yyget_debug (void)
{
  return rsql_yy_flex_debug;
}

void
rsql_yyset_debug (int bdebug)
{
  rsql_yy_flex_debug = bdebug;
}

static int
yy_init_globals (void)
{
  /* Initialization is the same as for the non-reentrant scanner.
   * This function is called from rsql_yylex_destroy(), so don't allocate here.
   */

  (yy_buffer_stack) = 0;
  (yy_buffer_stack_top) = 0;
  (yy_buffer_stack_max) = 0;
  (yy_c_buf_p) = (char *) 0;
  (yy_init) = 0;
  (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
  rsql_yyin = stdin;
  rsql_yyout = stdout;
#else
  rsql_yyin = (FILE *) 0;
  rsql_yyout = (FILE *) 0;
#endif

  /* For future reference: Set errno on error, since we are called by
   * rsql_yylex_init()
   */
  return 0;
}

/* rsql_yylex_destroy is for both reentrant and non-reentrant scanners. */
int
rsql_yylex_destroy (void)
{

  /* Pop the buffer stack, destroying each element. */
  while (YY_CURRENT_BUFFER)
    {
      rsql_yy_delete_buffer (YY_CURRENT_BUFFER);
      YY_CURRENT_BUFFER_LVALUE = NULL;
      rsql_yypop_buffer_state ();
    }

  /* Destroy the stack itself. */
  rsql_yyfree ((yy_buffer_stack));
  (yy_buffer_stack) = NULL;

  /* Reset the globals. This is important in a non-reentrant scanner so the next time
   * rsql_yylex() is called, initialization will occur. */
  yy_init_globals ();

  return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void
yy_flex_strncpy (char *s1, yyconst char *s2, int n)
{
  register int i;
  for (i = 0; i < n; ++i)
    s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int
yy_flex_strlen (yyconst char *s)
{
  register int n;
  for (n = 0; s[n]; ++n)
    ;

  return n;
}
#endif

void *
rsql_yyalloc (yy_size_t size)
{
  return (void *) malloc (size);
}

void *
rsql_yyrealloc (void *ptr, yy_size_t size)
{
  /* The cast to (char *) in the following accommodates both
   * implementations that use char* generic pointers, and those
   * that use void* generic pointers.  It works with the latter
   * because both ANSI C and C++ allow castless assignment from
   * any pointer type to void*, and deal with argument conversions
   * as though doing an assignment.
   */
  return (void *) realloc ((char *) ptr, size);
}

void
rsql_yyfree (void *ptr)
{
  free ((char *) ptr);          /* see rsql_yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#line 947 "../../src/parser/rsql_lexer.l"



#if defined (ENABLE_UNUSED_FUNCTION)
int parser_yyinput_single_mode = 0;
#endif

void
rsql_yyerror_explicit (int line, int column)
{
  rsql_yyerror (NULL);
  msg_ptr = 0;
}


void
rsql_yyerror (const char *s)
{
  char *token_val = NULL;
  char *next_ptr = rsql_yyget_text () + rsql_yyget_leng () + 1;
  char saved_char = yy_hold_char;       /* retain the character following the last
                                         * character of the current token */
  char *end_of_stmt_str = NULL;
  char *context_saved_char_str = NULL;
  int end_statement = 0;
  int free_msg = 0;
  int token_len = rsql_yyget_leng () + 1;
  int next_ptr_len = 0;
  char *buffer = NULL;

  /* make a copy of the token value before the buffer flush */
  if (RSQL_MAXNAME < rsql_yyget_leng () + 1)
    {
      token_len = RSQL_MAXNAME;
    }
  token_val = (char *) rsql_yyalloc (token_len);
  if (token_val == NULL)
    {
      YY_FATAL_ERROR ("out of dynamic memory in rsql_yyerror()");
    }
  snprintf (token_val, token_len, "%s", rsql_yyget_text ());

  end_of_stmt_str = msgcat_message (MSGCAT_CATALOG_RYE, MSGCAT_SET_PARSER_SYNTAX, MSGCAT_SYNTAX_END_OF_STMT);
  context_saved_char_str = msgcat_message (MSGCAT_CATALOG_RYE,
                                           MSGCAT_SET_PARSER_SYNTAX, MSGCAT_SYNTAX_CONTEXT_SAVED_CHAR);

  next_ptr_len = strlen (next_ptr);
  if (next_ptr_len == 0)
    {
      end_statement = 1;
      next_ptr = end_of_stmt_str;
    }
  if (next_ptr_len > MAX_PRINT_ERROR_CONTEXT_LENGTH)
    {
      buffer = (char *) rsql_yyalloc (MAX_PRINT_ERROR_CONTEXT_LENGTH + 1);
      memcpy (buffer, next_ptr, MAX_PRINT_ERROR_CONTEXT_LENGTH - 3);
      strcpy (buffer + MAX_PRINT_ERROR_CONTEXT_LENGTH - 3, "...");
      next_ptr = buffer;
      next_ptr_len = strlen (next_ptr);
    }

  YY_FLUSH_BUFFER;
  parser_statement_OK = 0;

  if (msg_ptr)
    {
      PT_NODE *dummy = parser_new_node (this_parser, PT_EXPR);
      PT_ERRORm (this_parser, dummy, MSGCAT_SET_PARSER_SYNTAX, g_msg[msg_ptr - 1]);
      parser_free_tree (this_parser, dummy);
    }
  else
    {
      const char *cmp_str = msgcat_message (MSGCAT_CATALOG_RYE,
                                            MSGCAT_SET_PARSER_SYNTAX,
                                            MSGCAT_SYNTAX_EXPECTING_BRACKET);
      const char *cmp_str2 = msgcat_message (MSGCAT_CATALOG_RYE,
                                             MSGCAT_SET_PARSER_SYNTAX,
                                             MSGCAT_SYNTAX_EXPECTING_SELECT);

      char *msg = NULL;
      const char *before_token = msgcat_message (MSGCAT_CATALOG_RYE,
                                                 MSGCAT_SET_PARSER_SYNTAX,
                                                 MSGCAT_SYNTAX_YYERROR);
      const char *after_token = strstr (s, msgcat_message (MSGCAT_CATALOG_RYE,
                                                           MSGCAT_SET_PARSER_SYNTAX,
                                                           MSGCAT_SYNTAX_EXPECTING));
      const char *token_type = strstr (s, msgcat_message (MSGCAT_CATALOG_RYE,
                                                          MSGCAT_SET_PARSER_SYNTAX,
                                                          MSGCAT_SYNTAX_UNEXPECTED));
      int len = 0;
      PT_NODE *dummy;

      if ((strlen (s) > strlen (cmp_str)) && (strcmp (&s[strlen (s) - strlen (cmp_str)], cmp_str) == 0))
        {
          *(char *) &s[strlen (s) - strlen (cmp_str)] = 0;
        }
      else if ((strlen (s) > strlen (cmp_str2)) && (strcmp (&s[strlen (s) - strlen (cmp_str2)], cmp_str2) == 0))
        {
          *(char *) &s[strlen (s) - strlen (cmp_str2)] = 0;
        }

      if (strlen (token_val) == 0)
        {
          token_type = NULL;
        }
      if (token_type)
        {
          char *msg_context = NULL;
          int fixed_len = 11 * 2;       /* maximum size of printed line number and
                                           column number */
          int msg_size = fixed_len + next_ptr_len + strlen (before_token) + strlen (token_val) + 4;
          /* 4 = 3 more characters when printing before_token
           * and 'token_val' + the string terminator */

          if (end_statement == 0)
            {
              msg_size += strlen (context_saved_char_str);
              msg_size += 1;    /* one printed char in the message */
            }
          else
            {
              msg_context = msgcat_message (MSGCAT_CATALOG_RYE, MSGCAT_SET_PARSER_SYNTAX, MSGCAT_SYNTAX_CONTEXT);
              msg_size += strlen (msg_context);
            }

          if (after_token)
            {
              msg_size += strlen (after_token);
            }

          msg = (char *) rsql_yyalloc (msg_size);
          if (msg == NULL)
            {
              YY_FATAL_ERROR ("out of dynamic memory in rsql_yyerror()");
              goto end;
            }
          free_msg = 1;
          if (end_statement == 0)
            {
              snprintf (msg, msg_size, context_saved_char_str,
                        rsql_yylloc.first_line, rsql_yylloc.first_column, (saved_char ? saved_char : ' '), next_ptr);
            }
          else
            {
              assert (msg_context != NULL);
              snprintf (msg, msg_size, msg_context, rsql_yylloc.first_line, rsql_yylloc.first_column, next_ptr);
            }

          len = strlen (msg);

          if (msg[len - 3] == '\n')
            {
              msg[len - 3] = ' ';
            }
          sprintf (msg + len, "%s '%s'", before_token, token_val);

          if (after_token)
            {
              strcat (msg, after_token);
            }
        }
      else
        {
          if (strstr (s, "$end"))
            {
              int msg_size;

              next_ptr = end_of_stmt_str;
              msg_size = strlen (before_token) + strlen (next_ptr) + 2;

              msg = (char *) rsql_yyalloc (msg_size);
              if (msg == NULL)
                {
                  YY_FATAL_ERROR ("out of dynamic memory in rsql_yyerror()");
                  goto end;
                }
              snprintf (msg, msg_size, "%s %s", before_token, next_ptr);
              free_msg = 1;
            }
          else
            {
              msg = s;
            }
        }

      dummy = parser_new_node (this_parser, PT_EXPR);
      if (dummy == NULL)
        {
          if (free_msg && msg != NULL)
            {
              rsql_yyfree (msg);
            }
          goto end;
        }
      PT_ERRORf (this_parser, dummy, "%s", msg);
      parser_free_tree (this_parser, dummy);
      if (free_msg && msg != NULL)
        {
          rsql_yyfree (msg);
        }
    }

end:
  if (token_val != NULL)
    {
      rsql_yyfree (token_val);
    }
  if (buffer)
    {
      rsql_yyfree (buffer);
    }
}

int
rsql_yywrap ()
{
  return 1;
}

#if defined (ENABLE_UNUSED_FUNCTION)
static int
parser_yyinput_single_line (char *buff, int max_size)
{
  int c, end;
  int i = 0;

  assert (max_size >= 1);
  do
    {
      c = pt_nextchar ();
      if (c == '\'' || c == '\"')       /* string start */
        {
          buff[i++] = c;
          if (i >= max_size)
            {
              return i;
            }

          end = c;
          do
            {
              c = pt_nextchar ();
              if (c == end)     /* string end */
                {
                  break;
                }

              buff[i++] = c;
              if (i >= max_size)
                {
                  return i;
                }
            }
          while (c != -1);
        }

      if (c == ';')
        {
          buff[i++] = -1;
          buff[i] = 0;
          return i;
        }

      buff[i++] = c;
      if (i >= max_size)
        {
          return i;
        }

    }
  while (c != -1);

  buff[i] = 0;
  parser_yyinput_single_mode = 0;       /* all done */
  return i;
}
#endif

static int
parser_yyinput_multi_line (char *buff, int max_size)
{
  int c;
  int i = 0;

  assert (max_size >= 1);
  for (;;)
    {
      c = pt_nextchar ();
      if (c == -1)
        {
          buff[i] = 0;
          return i;
        }

      buff[i++] = c;
      if (i == max_size)
        {
          buff[i] = 0;
          return i;
        }
    }
}

static int
parser_yyinput (char *buff, int max_size)
{
#if defined (ENABLE_UNUSED_FUNCTION)
  if (!parser_yyinput_single_mode)
    {
      return parser_yyinput_multi_line (buff, max_size);
    }
  else
    {
      return parser_yyinput_single_line (buff, max_size);
    }
#else
  return parser_yyinput_multi_line (buff, max_size);
#endif
}

static int
input_internal ()
{
  int c = input ();
  if (c == '\n')
    {
      this_parser->line = rsql_yylloc.last_line = yyline++;
      this_parser->column = rsql_yylloc.last_column = yycolumn_end = 1;
    }
  else
    {
      this_parser->column = rsql_yylloc.last_column = yycolumn_end++;
    }

  return c;
}

static char *
parser_c_hint ()
{
  int c, c1;
  char buff[RSQL_MAXNAME];
  int i = 0;
  PT_HINT_ENUM hint = PT_HINT_NONE;

  /* column position set */
  yycolumn = yycolumn_end;
  rsql_yylloc.first_column = yycolumn;
  rsql_yylloc.first_line = yyline;
  rsql_yylloc.last_line = yyline;
  rsql_yylloc.last_column = yycolumn_end;

  if (i < (RSQL_MAXNAME - 1) && (c = input_internal ()) == '+')
    {                           /* hint */
      buff[i++] = '+';
      while ((c = input_internal ()) != 0 && c != -1)
        {
          if (c == '*')
            {
              /* peek and check next char */
              c1 = input_internal ();
              if (c1 == '/')
                {
                  break;
                }
              unput (c1);
            }

          if (i >= (RSQL_MAXNAME - 1))
            {
              i++;
              goto consume_comment;
            }

          buff[i++] = c;
        }


      buff[i] = 0;

      yybuffer_pos += i + 2;
      pt_check_hint (buff, parser_hint_table, &hint, false);
      if (hint == PT_HINT_NONE)
        {                       /* comment */
          return NULL;
        }

      return pt_makename (buff);
    }
  else
    {
      unput (c);
    }

consume_comment:
  yybuffer_pos += i;
  i = 0;
  while ((c = input_internal ()) != '*' && c != 0 && c != -1)
    {
      yybuffer_pos++;
    }

  if ((c1 = input_internal ()) != '/' && c != 0 && c != -1)
    {
      unput (c1);
      yybuffer_pos++;
      goto consume_comment;
    }

  yybuffer_pos += 2;

  return NULL;
}


static char *
parser_line_hint (void)
{
  int c;
  char buff[RSQL_MAXNAME];
  int i = 0;
  PT_HINT_ENUM hint = PT_HINT_NONE;


  /* column position set */
  yycolumn = yycolumn_end;
  rsql_yylloc.first_column = yycolumn;
  rsql_yylloc.first_line = yyline;
  rsql_yylloc.last_line = yyline;
  rsql_yylloc.last_column = yycolumn_end;

loop:
  if (i < (RSQL_MAXNAME - 1) && (c = input_internal ()) == '+')
    {                           /* hint */
      buff[i++] = '+';
      while ((c = input_internal ()) != '\r' && c != '\n' && c != 0 && c != -1)
        {
          if (i >= (RSQL_MAXNAME - 1))
            goto loop;
          buff[i++] = c;
        }
      buff[i] = 0;

      yybuffer_pos += i + 1;
      pt_check_hint (buff, parser_hint_table, &hint, false);
      if (hint == PT_HINT_NONE)
        {                       /* comment */
          return NULL;
        }

      return pt_makename (buff);
    }
  else
    {                           /* comment */
      yybuffer_pos += i;
      unput (c);
      while ((c = input_internal ()) != '\r' && c != '\n' && c != 0 && c != -1)
        {
          yybuffer_pos++;
        }
      yybuffer_pos++;

      return NULL;
    }
}


static void
begin_token (char *token)
{
  yycolumn = yycolumn_end;
  yycolumn_end += strlen (token);

  rsql_yylloc.first_line = yyline;
  rsql_yylloc.first_column = yycolumn;
  rsql_yylloc.last_line = yyline;
  rsql_yylloc.last_column = yycolumn_end;
}

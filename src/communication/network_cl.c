/*
 * Copyright (C) 2008 Search Solution Corporation. All rights reserved by Search Solution.
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *
 */

/*
 * network_cl.c - client side support functions.
 */

#ident "$Id$"

#include "config.h"

#include <stdio.h>
#include <string.h>

/* for performance metering */
#include <sys/time.h>
#include <sys/resource.h>

#include "network.h"
#include "network_interface_cl.h"
#include "chartype.h"
#include "connection_cl.h"
#include "server_interface.h"
#include "memory_alloc.h"
#include "databases_file.h"
#include "error_manager.h"
#include "system_parameter.h"
#include "environment_variable.h"
#include "boot_cl.h"
#include "xasl_support.h"
#include "dbtype.h"
#include "release_string.h"
#include "log_comm.h"
#include "file_io.h"
#include "locator.h"
#include "db.h"
#include "client_support.h"
#include "perf_monitor.h"
#include "connection_less.h"
#include "rbl_sync_log.h"
#include "tcp.h"

/*
 * Add instrumentation to the client side to get histogram of network
 * requests
 */

struct net_request_buffer
{
  const char *name;
  int request_count;
  int total_size_sent;
  int total_size_received;
  int elapsed_time;
};
static struct net_request_buffer net_Req_buffer[NET_SERVER_REQUEST_END];

static int net_Histo_setup = 0;
static int net_Histo_setup_mnt = 0;
static int net_Histo_call_count = 0;
static INT64 net_Histo_last_call_time = 0;
static INT64 net_Histo_total_server_time = 0;

/* Contains the name of the current sever host machine.  */
static char net_Server_host[MAXHOSTNAMELEN + 1] = "";
static in_addr_t net_Server_addr = INADDR_NONE;

/* Contains the name of the current server name. */
static char net_Server_name[DB_MAX_IDENTIFIER_LENGTH + 1] = "";

#if defined (ENABLE_UNUSED_FUNCTION)
static void return_error_to_server (char *host, unsigned int eid);
#endif
static int client_capabilities (void);
static int check_server_capabilities (int server_cap, int client_type,
				      int opt_cap);
static int set_server_error (int error);

static void net_histo_setup_names (void);
#if defined(HISTO)
static void net_histo_add_entry (int request, int data_sent);
static void net_histo_request_finished (int request, int data_received);
#endif

static const char *get_capability_string (int cap, int cap_type);

/*
 * Shouldn't know about db_Connect_status at this level, must set this
 * to disable all db_ functions
 */

/*
 * set_server_error -
 *
 * return:
 *   error(in):
 *
 * Note:
 */

static int
set_server_error (int error)
{
  int server_error;

  switch (error)
    {
    case CANT_ALLOC_BUFFER:
      server_error = ER_NET_CANT_ALLOC_BUFFER;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, server_error, 0);
      break;
    case RECORD_TRUNCATED:
      server_error = ER_NET_DATA_TRUNCATED;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, server_error, 0);
      break;
    case REQUEST_REFUSED:
      server_error = er_errid ();
      break;
    case SERVER_ABORTED:
      server_error = er_errid ();
      /* those errors are generated by the net_server_request()
       * so that do not fall to server crash handling */
      switch (server_error)
	{
	case ER_DB_NO_MODIFICATIONS:
	  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, server_error, 0);
	  return (server_error);
	case ER_AU_DBA_ONLY:
	  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, server_error, 1, "");
	  return (server_error);
	}
      /* no break; fall through */
    default:
      server_error = ER_NET_SERVER_CRASHED;
      er_set_with_oserror (ER_ERROR_SEVERITY, ARG_FILE_LINE, server_error, 0);
      break;
    }

  er_log_debug (ARG_FILE_LINE, "set_server_error(%d) server_error %d\n",
		error, server_error);

  db_Connect_status = DB_CONNECTION_STATUS_NOT_CONNECTED;

  if (net_Server_name[0] != '\0')
    {
      net_Server_name[0] = '\0';
      net_Server_host[0] = '\0';
      net_Server_addr = INADDR_NONE;
      boot_server_die_or_changed ();
    }

  return (server_error);
}

#if defined (ENABLE_UNUSED_FUNCTION)
/*
 * return_error_to_server -
 *
 * return:
 *
 *   host(in):
 *   eid(in):
 *
 * Note:
 */
static void
return_error_to_server (char *host, unsigned int eid)
{
  void *area;
  char buffer[1024];
  int length = 1024;

  area = er_get_area_error (buffer, &length);
  if (area != NULL)
    {
      css_send_error_to_server (host, eid, (char *) area, length);
    }
}
#endif

/*
 * client_capabilities -
 *
 * return:
 */
static int
client_capabilities (void)
{
  int capabilities = 0;

  capabilities |= NET_CAP_INTERRUPT_ENABLED;
  if (db_Disable_modifications > 0)
    {
      capabilities |= NET_CAP_UPDATE_DISABLED;
    }

  if (db_get_ignore_repl_delay ())
    {
      capabilities |= NET_CAP_HA_IGNORE_REPL_DELAY;
    }

  return capabilities;
}

/*
 * get_capability_string - for the purpose of error logging,
 *                         it translate cap into a word
 *
 * return:
 */
static const char *
get_capability_string (int cap, int cap_type)
{
  switch (cap_type)
    {
    case NET_CAP_INTERRUPT_ENABLED:
      if (cap & NET_CAP_INTERRUPT_ENABLED)
	{
	  return "enabled";
	}
      return "disabled";
    case NET_CAP_UPDATE_DISABLED:
      if (cap & NET_CAP_UPDATE_DISABLED)
	{
	  return "read only";
	}
      return "read/write";
    default:
      return "-";
    }
}

/*
 * check_server_capabilities -
 *
 * return:
 */
static int
check_server_capabilities (int server_cap, int client_type, int opt_cap)
{
  int client_cap;

  client_cap = client_capabilities ();
  client_cap |= opt_cap;

  /* interrupt-ability should be same */
  if ((client_cap ^ server_cap) & NET_CAP_INTERRUPT_ENABLED)
    {
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE,
	      ER_NET_HS_INCOMPAT_INTERRUPTIBILITY, 3, net_Server_host,
	      get_capability_string (client_cap, NET_CAP_INTERRUPT_ENABLED),
	      get_capability_string (server_cap, NET_CAP_INTERRUPT_ENABLED));
      server_cap ^= NET_CAP_INTERRUPT_ENABLED;
    }

  /* replica only client should check whether the server is replica */
  if (BOOT_REPLICA_ONLY_BROKER_CLIENT_TYPE (client_type))
    {
      if (~server_cap & NET_CAP_HA_REPLICA)
	{
	  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_HS_HA_REPLICA_ONLY,
		  1, net_Server_host);
	  server_cap ^= NET_CAP_HA_REPLICA;
	}
    }
  else
    {
      /* update-ability should be same */
      if ((client_cap ^ server_cap) & NET_CAP_UPDATE_DISABLED)
	{
	  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE,
		  ER_NET_HS_INCOMPAT_RW_MODE, 3, net_Server_host,
		  get_capability_string (client_cap, NET_CAP_UPDATE_DISABLED),
		  get_capability_string (server_cap,
					 NET_CAP_UPDATE_DISABLED));
	  server_cap ^= NET_CAP_UPDATE_DISABLED;

	  db_set_reconnect_reason (DB_RC_MISMATCHED_RW_MODE);
	}
      else
	{
	  db_unset_reconnect_reason (DB_RC_MISMATCHED_RW_MODE);
	}
    }

  /*
   * check HA replication delay
   * if client_cap is on, it checks the server delay status
   * else, it ignores the delay status.
   */
  if (client_cap & NET_CAP_HA_REPL_DELAY & server_cap)
    {
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_HS_HA_REPL_DELAY, 1,
	      net_Server_host);
      server_cap ^= NET_CAP_HA_REPL_DELAY;

      db_set_reconnect_reason (DB_RC_HA_REPL_DELAY);
    }

  return server_cap;
}

/*
 * net_histo_setup_names -
 *
 * return:
 *
 * Note:
 */
static void
net_histo_setup_names (void)
{
  unsigned int i;

  for (i = 0; i < DIM (net_Req_buffer); i++)
    {
      net_Req_buffer[i].name = "";
      net_Req_buffer[i].request_count = 0;
      net_Req_buffer[i].total_size_sent = 0;
      net_Req_buffer[i].total_size_received = 0;
      net_Req_buffer[i].elapsed_time = 0;
    }

  net_Req_buffer[NET_SERVER_BO_INIT_SERVER].name =
    "NET_SERVER_BO_INIT_SERVER";
  net_Req_buffer[NET_SERVER_BO_REGISTER_CLIENT].name =
    "NET_SERVER_BO_REGISTER_CLIENT";
  net_Req_buffer[NET_SERVER_BO_UNREGISTER_CLIENT].name =
    "NET_SERVER_BO_UNREGISTER_CLIENT";
  net_Req_buffer[NET_SERVER_BO_ADD_VOLEXT].name = "NET_SERVER_BO_ADD_VOLEXT";
  net_Req_buffer[NET_SERVER_BO_FIND_NPERM_VOLS].name =
    "NET_SERVER_BO_FIND_NPERM_VOLS";
  net_Req_buffer[NET_SERVER_BO_FIND_NTEMP_VOLS].name =
    "NET_SERVER_BO_FIND_NTEMP_VOLS";
  net_Req_buffer[NET_SERVER_BO_FIND_LAST_TEMP].name =
    "NET_SERVER_BO_FIND_LAST_TEMP";
  net_Req_buffer[NET_SERVER_BO_FIND_NBEST_ENTRIES].name =
    "NET_SERVER_BO_FIND_NBEST_ENTRIES";
  net_Req_buffer[NET_SERVER_BO_GET_SERVER_STATE].name =
    "NET_SERVER_BO_GET_SERVER_STATE";
  net_Req_buffer[NET_SERVER_BO_NOTIFY_HA_APPLY_STATE].name =
    "NET_SERVER_BO_NOTIFY_HA_APPLY_STATE";
  net_Req_buffer[NET_SERVER_BO_GET_LOCALES_INFO].name =
    "NET_SERVER_BO_GET_LOCALES_INFO";

  net_Req_buffer[NET_SERVER_TM_SERVER_COMMIT].name =
    "NET_SERVER_TM_SERVER_COMMIT";
  net_Req_buffer[NET_SERVER_TM_SERVER_ABORT].name =
    "NET_SERVER_TM_SERVER_ABORT";
#if defined (ENABLE_UNUSED_FUNCTION)
  net_Req_buffer[NET_SERVER_TM_SERVER_START_TOPOP].name =
    "NET_SERVER_TM_SERVER_START_TOPOP";
  net_Req_buffer[NET_SERVER_TM_SERVER_END_TOPOP].name =
    "NET_SERVER_TM_SERVER_END_TOPOP";
#endif
  net_Req_buffer[NET_SERVER_TM_SERVER_SAVEPOINT].name =
    "NET_SERVER_TM_SERVER_SAVEPOINT";
  net_Req_buffer[NET_SERVER_TM_SERVER_PARTIAL_ABORT].name =
    "NET_SERVER_TM_SERVER_PARTIAL_ABORT";
  net_Req_buffer[NET_SERVER_TM_SERVER_HAS_UPDATED].name =
    "NET_SERVER_TM_SERVER_HAS_UPDATED";
  net_Req_buffer[NET_SERVER_TM_SERVER_ISACTIVE_AND_HAS_UPDATED].name =
    "NET_SERVER_TM_SERVER_ISACTIVE_AND_HAS_UPDATED";
#if defined (ENABLE_UNUSED_FUNCTION)
  net_Req_buffer[NET_SERVER_TM_ISBLOCKED].name = "NET_SERVER_TM_ISBLOCKED";
#endif
  net_Req_buffer[NET_SERVER_TM_WAIT_SERVER_ACTIVE_TRANS].name =
    "NET_SERVER_TM_WAIT_SERVER_ACTIVE_TRANS";
  net_Req_buffer[NET_SERVER_LOG_CHECKPOINT].name =
    "NET_SERVER_LOG_CHECKPOINT";

  net_Req_buffer[NET_SERVER_LC_FETCH].name = "NET_SERVER_LC_FETCH";
  net_Req_buffer[NET_SERVER_LC_FETCHALL].name = "NET_SERVER_LC_FETCHALL";
  net_Req_buffer[NET_SERVER_LC_FETCH_LOCKSET].name =
    "NET_SERVER_LC_FETCH_LOCKSET";
#if defined (ENABLE_UNUSED_FUNCTION)
  net_Req_buffer[NET_SERVER_LC_GET_CLASS].name = "NET_SERVER_LC_GET_CLASS";
#endif
  net_Req_buffer[NET_SERVER_LC_FIND_CLASSOID].name =
    "NET_SERVER_LC_FIND_CLASSOID";
  net_Req_buffer[NET_SERVER_LC_FORCE].name = "NET_SERVER_LC_FORCE";
  net_Req_buffer[NET_SERVER_LC_RESERVE_CLASSNAME].name =
    "NET_SERVER_LC_RESERVE_CLASSNAME";
  net_Req_buffer[NET_SERVER_LC_DELETE_CLASSNAME].name =
    "NET_SERVER_LC_DELETE_CLASSNAME";
  net_Req_buffer[NET_SERVER_LC_RENAME_CLASSNAME].name =
    "NET_SERVER_LC_RENAME_CLASSNAME";
  net_Req_buffer[NET_SERVER_LC_ASSIGN_OID].name = "NET_SERVER_LC_ASSIGN_OID";
  net_Req_buffer[NET_SERVER_LC_FIND_LOCKHINT_CLASSOIDS].name =
    "NET_SERVER_LC_FIND_LOCKHINT_CLASSOIDS";
  net_Req_buffer[NET_SERVER_LC_FETCH_LOCKHINT_CLASSES].name =
    "NET_SERVER_LC_FETCH_LOCKHINT_CLASSES";
#if defined (ENABLE_UNUSED_FUNCTION)
  net_Req_buffer[NET_SERVER_LC_ASSIGN_OID_BATCH].name =
    "NET_SERVER_LC_ASSIGN_OID_BATCH";
#endif

  net_Req_buffer[NET_SERVER_HEAP_CREATE].name = "NET_SERVER_HEAP_CREATE";
  net_Req_buffer[NET_SERVER_HEAP_DESTROY].name = "NET_SERVER_HEAP_DESTROY";
  net_Req_buffer[NET_SERVER_HEAP_GET_CLASS_NOBJS_AND_NPAGES].name =
    "NET_SERVER_HEAP_GET_CLASS_NOBJS_AND_NPAGES";

  net_Req_buffer[NET_SERVER_LOG_RESET_WAIT_MSECS].name =
    "NET_SERVER_LOG_RESET_WAIT_MSECS";
#if defined (ENABLE_UNUSED_FUNCTION)
  net_Req_buffer[NET_SERVER_LOG_RESET_ISOLATION].name =
    "NET_SERVER_LOG_RESET_ISOLATION";
#endif
  net_Req_buffer[NET_SERVER_LOG_SET_INTERRUPT].name =
    "NET_SERVER_LOG_SET_INTERRUPT";
  net_Req_buffer[NET_SERVER_LOG_DUMP_STAT].name = "NET_SERVER_LOG_DUMP_STAT";
  net_Req_buffer[NET_SERVER_LOG_GETPACK_TRANTB].name =
    "NET_SERVER_LOG_GETPACK_TRANTB";
  net_Req_buffer[NET_SERVER_LOG_DUMP_TRANTB].name =
    "NET_SERVER_LOG_DUMP_TRANTB";
  net_Req_buffer[NET_SERVER_LOG_SET_SUPPRESS_REPL_ON_TRANSACTION].name =
    "NET_SERVER_LOG_SET_SUPPRESS_REPL_ON_TRANSACTION";

  net_Req_buffer[NET_SERVER_LK_DUMP].name = "NET_SERVER_LK_DUMP";

  net_Req_buffer[NET_SERVER_BTREE_ADD_INDEX].name =
    "NET_SERVER_BTREE_ADD_INDEX";
  net_Req_buffer[NET_SERVER_BTREE_DEL_INDEX].name =
    "NET_SERVER_BTREE_DEL_INDEX";
  net_Req_buffer[NET_SERVER_BTREE_LOAD_DATA].name =
    "NET_SERVER_BTREE_LOAD_DATA";
  net_Req_buffer[NET_SERVER_BTREE_FIND_UNIQUE].name =
    "NET_SERVER_BTREE_FIND_UNIQUE";

  net_Req_buffer[NET_SERVER_DISK_GET_PURPOSE_AND_SPACE_INFO].name =
    "NET_SERVER_DISK_GET_PURPOSE_AND_SPACE_INFO";
  net_Req_buffer[NET_SERVER_DISK_VLABEL].name = "NET_SERVER_DISK_VLABEL";

  net_Req_buffer[NET_SERVER_QST_GET_STATISTICS].name =
    "NET_SERVER_QST_GET_STATISTICS";
  net_Req_buffer[NET_SERVER_QST_UPDATE_STATISTICS].name =
    "NET_SERVER_QST_UPDATE_STATISTICS";
  net_Req_buffer[NET_SERVER_QST_UPDATE_ALL_STATISTICS].name =
    "NET_SERVER_QST_UPDATE_ALL_STATISTICS";

  net_Req_buffer[NET_SERVER_QM_QUERY_PREPARE].name =
    "NET_SERVER_QM_QUERY_PREPARE";
  net_Req_buffer[NET_SERVER_QM_QUERY_EXECUTE].name =
    "NET_SERVER_QM_QUERY_EXECUTE";
  net_Req_buffer[NET_SERVER_QM_QUERY_END].name = "NET_SERVER_QM_QUERY_END";
  net_Req_buffer[NET_SERVER_QM_QUERY_DROP_PLAN].name =
    "NET_SERVER_QM_QUERY_DROP_PLAN";
  net_Req_buffer[NET_SERVER_QM_QUERY_DROP_ALL_PLANS].name =
    "NET_SERVER_QM_QUERY_DROP_ALL_PLANS";
  net_Req_buffer[NET_SERVER_QM_GET_QUERY_INFO].name =
    "NET_SERVER_QM_GET_QUERY_INFO";
  net_Req_buffer[NET_SERVER_QM_QUERY_DUMP_PLANS].name =
    "NET_SERVER_QM_QUERY_DUMP_PLANS";

  net_Req_buffer[NET_SERVER_LS_GET_LIST_FILE_PAGE].name =
    "NET_SERVER_LS_GET_LIST_FILE_PAGE";

#if defined (ENABLE_UNUSED_FUNCTION)
  net_Req_buffer[NET_SERVER_MNT_SERVER_START_STATS].name =
    "NET_SERVER_MNT_SERVER_START_STATS";
  net_Req_buffer[NET_SERVER_MNT_SERVER_STOP_STATS].name =
    "NET_SERVER_MNT_SERVER_STOP_STATS";
#endif
  net_Req_buffer[NET_SERVER_MNT_SERVER_COPY_STATS].name =
    "NET_SERVER_MNT_SERVER_COPY_STATS";

  net_Req_buffer[NET_SERVER_CT_CAN_ACCEPT_NEW_REPR].name =
    "NET_SERVER_CT_CAN_ACCEPT_NEW_REPR";

  net_Req_buffer[NET_SERVER_CSS_KILL_TRANSACTION].name =
    "NET_SERVER_CSS_KILL_TRANSACTION";

  net_Req_buffer[NET_SERVER_CSS_DUMP_CS_STAT].name =
    "NET_SERVER_CSS_DUMP_CS_STAT";
  net_Req_buffer[NET_SERVER_CSS_DUMP_SERVER_STAT].name =
    "NET_SERVER_CSS_DUMP_SERVER_STAT";

  net_Req_buffer[NET_SERVER_QPROC_GET_SERVER_INFO].name =
    "NET_SERVER_QPROC_GET_SERVER_INFO";

  net_Req_buffer[NET_SERVER_PRM_SET_PARAMETERS].name =
    "NET_SERVER_PRM_SET_PARAMETERS";
  net_Req_buffer[NET_SERVER_PRM_GET_PARAMETERS].name =
    "NET_SERVER_PRM_GET_PARAMETERS";
  net_Req_buffer[NET_SERVER_PRM_GET_PARAMETERS].name =
    "NET_SERVER_PRM_GET_FORCE_PARAMETERS";
  net_Req_buffer[NET_SERVER_PRM_DUMP_PARAMETERS].name =
    "NET_SERVER_PRM_DUMP_PARAMETERS";

  net_Req_buffer[NET_SERVER_REPL_INFO].name = "NET_SERVER_REPL_INFO";
  net_Req_buffer[NET_SERVER_REPL_LOG_GET_EOF_LSA].name =
    "NET_SERVER_REPL_LOG_GET_EOF_LSA";

  net_Req_buffer[NET_SERVER_LOGWR_GET_LOG_PAGES].name =
    "NET_SERVER_LOGWR_GET_LOG_PAGES";

#if defined (ENABLE_UNUSED_FUNCTION)
  net_Req_buffer[NET_SERVER_TEST_PERFORMANCE].name =
    "NET_SERVER_TEST_PERFORMANCE";
#endif

  net_Req_buffer[NET_SERVER_SHUTDOWN].name = "NET_SERVER_SHUTDOWN";

  net_Req_buffer[NET_SERVER_SES_CHECK_SESSION].name =
    "NET_SERVER_SES_CHECK_SESSION";
  net_Req_buffer[NET_SERVER_SES_END_SESSION].name = "NET_SERVER_END_SESSION";

  net_Req_buffer[NET_SERVER_MIGRATOR_GET_LOG_PAGES].name =
    "NET_SERVER_MIGRATOR_GET_LOG_PAGES";
  net_Req_buffer[NET_SERVER_UPDATE_GROUP_ID].name =
    "NET_SERVER_UPDATE_GROUP_ID";
  net_Req_buffer[NET_SERVER_BLOCK_GLOBAL_DML].name =
    "NET_SERVER_BLOCK_GLOBAL_DML";

  net_Req_buffer[NET_SERVER_BK_PREPARE_BACKUP].name =
    "NET_SERVER_BK_PREPARE_BACKUP";
  net_Req_buffer[NET_SERVER_BK_BACKUP_VOLUME].name =
    "NET_SERVER_BK_BACKUP_VOLUME";
  net_Req_buffer[NET_SERVER_BK_BACKUP_LOG_VOLUME].name =
    "NET_SERVER_BK_BACKUP_LOG_VOLUME";
}

/*
 * net_histo_clear -
 *
 * return:
 *
 * NOTE:
 */
void
net_histo_clear (void)
{
  unsigned int i;

  if (net_Histo_setup_mnt)
    {
      mnt_reset_stats ();
    }

  net_Histo_call_count = 0;
  net_Histo_last_call_time = 0;
  net_Histo_total_server_time = 0;
  for (i = 0; i < DIM (net_Req_buffer); i++)
    {
      net_Req_buffer[i].request_count = 0;
      net_Req_buffer[i].total_size_sent = 0;
      net_Req_buffer[i].total_size_received = 0;
      net_Req_buffer[i].elapsed_time = 0;
    }
}

/*
 * net_histo_print -
 *
 * return:
 *
 * Note:
 */
void
net_histo_print (FILE * stream)
{
  unsigned int i;
  int found = 0, total_requests = 0, total_size_sent = 0;
  int total_size_received = 0;
  float server_time, total_server_time = 0;
  float avg_response_time, avg_client_time;

  if (stream == NULL)
    {
      stream = stdout;
    }

  fprintf (stream, "\nHistogram of client requests:\n");
  fprintf (stream, "%-31s %6s  %10s %10s , %10s \n",
	   "Name", "Rcount", "Sent size", "Recv size", "Server time");
  for (i = 0; i < DIM (net_Req_buffer); i++)
    {
      if (net_Req_buffer[i].request_count)
	{
	  found = 1;
	  server_time = ((float) net_Req_buffer[i].elapsed_time / 1000000 /
			 (float) (net_Req_buffer[i].request_count));
	  fprintf (stream, "%-29s %6d X %10d+%10d b, %10.6f s\n",
		   net_Req_buffer[i].name, net_Req_buffer[i].request_count,
		   net_Req_buffer[i].total_size_sent,
		   net_Req_buffer[i].total_size_received, server_time);
	  total_requests += net_Req_buffer[i].request_count;
	  total_size_sent += net_Req_buffer[i].total_size_sent;
	  total_size_received += net_Req_buffer[i].total_size_received;
	  total_server_time +=
	    (server_time * net_Req_buffer[i].request_count);
	}
    }
  if (!found)
    {
      fprintf (stream, " No server requests made\n");
    }
  else
    {
      fprintf (stream,
	       "-------------------------------------------------------------"
	       "--------------\n");
      fprintf (stream,
	       "Totals:                       %6d X %10d+%10d b  "
	       "%10.6f s\n", total_requests, total_size_sent,
	       total_size_received, total_server_time);
      avg_response_time = total_server_time / total_requests;
      avg_client_time = 0.0;
      fprintf (stream, "\n Average server response time = %6.6f secs \n"
	       " Average time between client requests = %6.6f secs \n",
	       avg_response_time, avg_client_time);
    }
  if (net_Histo_setup_mnt)
    {
      mnt_print_stats (stream);
    }
}

/*
 * net_histo_print_global_stats -
 *
 * return:
 *
 * Note:
 */
void
net_histo_print_global_stats (FILE * stream, bool cumulative,
			      const char *substr, const char *db_name)
{
  if (net_Histo_setup_mnt || db_name != NULL)
    {
      mnt_print_global_stats (stream, cumulative, substr, db_name);
    }
}

/*
 * net_histo_start -
 *
 * return: NO_ERROR or ER_FAILED
 *
 * Note:
 */
int
net_histo_start (bool for_all_trans)
{
  if (net_Histo_setup == 0)
    {
      net_histo_clear ();
      net_histo_setup_names ();
      net_Histo_setup = 1;
    }

  if (net_Histo_setup_mnt == 0)
    {
      if (mnt_start_stats (for_all_trans) != NO_ERROR)
	{
	  return ER_FAILED;
	}
      net_Histo_setup_mnt = 1;
    }

  return NO_ERROR;
}

/*
 * net_histo_stop -
 *
 * return: NO_ERROR or ER_FAILED
 *
 * Note:
 */
int
net_histo_stop (void)
{
  int err = NO_ERROR;

  if (net_Histo_setup_mnt == 1)
    {
      err = mnt_stop_stats ();
      net_Histo_setup_mnt = 0;
    }

  if (net_Histo_setup == 1)
    {
      net_Histo_setup = 0;
    }

  return err;
}

#if defined(HISTO)
/*
 * net_histo_add_entry -
 *
 * return:
 *
 *   request(in):
 *   data_sent(in):
 *
 * Note:
 */
static void
net_histo_add_entry (int request, int data_sent)
{
  struct timeval tp;

  if (request <= NET_SERVER_REQUEST_START
      || request >= NET_SERVER_REQUEST_END)
    {
      return;
    }

  net_Req_buffer[request].request_count++;
  net_Req_buffer[request].total_size_sent += data_sent;
  if (gettimeofday (&tp, NULL) == 0)
    {
      net_Histo_last_call_time = tp.tv_sec * 1000000LL + tp.tv_usec;
    }
  net_Histo_call_count++;
}
#endif

#if defined(HISTO)
/*
 * net_histo_request_finished -
 *
 * return:
 *
 *   request(in):
 *   data_received(in):
 *
 * Note:
 */
static void
net_histo_request_finished (int request, int data_received)
{
  struct timeval tp;
  INT64 current_time;

  net_Req_buffer[request].total_size_received += data_received;

  if (gettimeofday (&tp, NULL) == 0)
    {
      current_time = tp.tv_sec * 1000000LL + tp.tv_usec;
      net_Histo_total_server_time = current_time - net_Histo_last_call_time;
      net_Req_buffer[request].elapsed_time += net_Histo_total_server_time;
    }
}
#endif


/*
 * net_client_get_server_addr () - the inet_addr of the current sever host machine
 *
 * return: in_addr_t
 */
in_addr_t
net_client_get_server_addr (void)
{
  return net_Server_addr;
}

int
net_client_request_send_msg (unsigned int *eid, int request,
			     int num_buffers, ...)
{
  int rc;
  va_list args;

  va_start (args, num_buffers);

  rc = net_client_request_send_msg_v (eid, request, num_buffers, args);

  va_end (args);

  return rc;
}

int
net_client_request_send_msg_v (unsigned int *eid, int request,
			       int num_buffers, va_list args)
{
  if (net_Server_name[0] == '\0')
    {
      /* need to have a more appropriate "unexpected disconnect" message */
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      return ER_NET_SERVER_CRASHED;
    }

  *eid = css_send_request_to_server_v (net_Server_host, request,
				       num_buffers, args);
  if (*eid == 0)
    {
      return set_server_error (css_Errno);
    }

  return NO_ERROR;
}

int
net_client_data_send_msg (unsigned int eid, int num_buffers, ...)
{
  int rc;
  va_list args;

  va_start (args, num_buffers);

  rc = net_client_data_send_msg_v (eid, num_buffers, args);

  va_end (args);

  return rc;
}

int
net_client_data_send_msg_v (unsigned int eid, int num_buffers, va_list args)
{
  int css_error;

  if (net_Server_name[0] == '\0')
    {
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_NET_SERVER_CRASHED, 0);
      return ER_NET_SERVER_CRASHED;
    }

  css_error = css_send_data_to_server_v (net_Server_host,
					 CSS_RID_FROM_EID (eid),
					 num_buffers, args);
  if (css_error != NO_ERRORS)
    {
      return set_server_error (css_error);
    }

  return NO_ERROR;
}

int
net_client_request_recv_msg (CSS_NET_PACKET ** recv_packet, unsigned int eid,
			     int timeout, int num_buffers, ...)
{
  int rc;
  va_list args;

  va_start (args, num_buffers);

  rc = net_client_request_recv_msg_v (recv_packet, eid, timeout,
				      num_buffers, args);

  va_end (args);

  return rc;
}

int
net_client_request_recv_msg_v (CSS_NET_PACKET ** recv_packet,
			       unsigned int eid, UNUSED_ARG int timeout,
			       int num_buffers, va_list args)
{
  int css_error;
  CSS_MAP_ENTRY *entry;
  int rid;

  entry = css_return_entry_from_eid (eid, css_Client_anchor);
  if (entry == NULL)
    {
      return SERVER_WAS_NOT_FOUND;
    }

  rid = CSS_RID_FROM_EID (eid);

  css_error = css_recv_data_from_server_v (recv_packet, entry->conn, rid, -1,
					   num_buffers, args);

  if (css_error != NO_ERRORS)
    {
      return set_server_error (css_error);
    }

  return NO_ERROR;
}

bool
net_client_is_server_in_transaction ()
{
  CSS_MAP_ENTRY *entry;

  entry = css_return_open_entry (net_Server_host, &css_Client_anchor);
  if (entry == NULL)
    {
      return true;
    }

  return (entry->conn->is_server_in_tran ? true : false);
}

short
net_client_server_shard_nodeid ()
{
  CSS_MAP_ENTRY *entry;

  entry = css_return_open_entry (net_Server_host, &css_Client_anchor);
  if (entry == NULL)
    {
      return -1;
    }

  return (entry->conn->server_shard_nodeid);
}

bool
net_client_reset_on_commit ()
{
  CSS_MAP_ENTRY *entry;
  bool reset_on_commit;

  entry = css_return_open_entry (net_Server_host, &css_Client_anchor);
  if (entry == NULL)
    {
      return false;
    }

  reset_on_commit = entry->conn->conn_reset_on_commit;
  entry->conn->conn_reset_on_commit = 0;

  return (reset_on_commit ? true : false);
}

void
net_client_set_ro_tran (bool ro_tran)
{
  CSS_MAP_ENTRY *entry;

  entry = css_return_open_entry (net_Server_host, &css_Client_anchor);
  if (entry != NULL)
    {
      entry->conn->is_client_ro_tran = ro_tran;
    }
}

/*
 * net_client_request
 *
 * return: error status
 *
 *   request(in): server request id
 *   argbuf(in): argument buffer (small)
 *   argsize(in): byte size of argbuf
 *   replybuf(in): reply argument buffer (small)
 *   replysize(in): size of reply argument buffer
 *
 */
int
net_client_request (int request, CSS_NET_PACKET ** recv_packet,
		    int num_send_buffers, int num_recv_buffers, ...)
{
  unsigned int eid;
  va_list args, tmp_args;
  int error;
  int i;

#if defined(HISTO)
  if (net_Histo_setup)
    {
      net_histo_add_entry (request, argsize + datasize);
    }
#endif /* HISTO */

  va_start (args, num_recv_buffers);

  error = net_client_request_send_msg_v (&eid, request,
					 num_send_buffers, args);
  va_end (args);


  va_start (tmp_args, num_recv_buffers);

  for (i = 0; i < num_send_buffers; i++)
    {
      va_arg (tmp_args, char *);
      va_arg (tmp_args, int);
    }

  if (error == NO_ERROR)
    {
      error = net_client_request_recv_msg_v (recv_packet, eid, -1,
					     num_recv_buffers, tmp_args);
    }

  va_end (tmp_args);

#if defined(HISTO)
  if (net_Histo_setup)
    {
      net_histo_request_finished (request, 0);
    }
#endif /* HISTO */

  return (error);
}

/*
 * net_client_request_with_callback -
 *
 * return: error status
 *
 *   request(in): server request id
 *   argbuf(in): argument buffer (small)
 *   argsize(in): byte size of argbuf
 *   databuf1(in): first data buffer to send (large)
 *   datasize1(in): size of first data buffer
 *   databuf2(in): second data buffer to send (large)
 *   datasize2(in): size of second data buffer
 *   replybuf(in): reply argument buffer (small)
 *   replysize(in): size of reply argument buffer
 *
 * Note: This is one of the functions that is called to perform a server
 *    request.
 *    This is similar to net_client_request2, but the first
 *    field in the reply argument buffer is a request code which can
 *    cause the client to perform actions such as call methods.  When
 *    the actions are completed, a reply is sent to the server.  Eventually
 *    the server responds to the original request with a request code
 *    that indicates that the request is complete and this routine
 *    returns.
 */
int
net_client_request_with_callback (int request, char *argbuf, int argsize,
				  char *reply, int replysize,
				  CSS_NET_PACKET ** recv_packet)
{
  unsigned int eid;
  char *ptr;
  QUERY_SERVER_REQUEST server_request;
  int server_request_num;
  CSS_NET_PACKET *tmp_recv_packet = NULL;
  int error;

  error = 0;

#if defined(HISTO)
  if (net_Histo_setup)
    {
      net_histo_add_entry (request, argsize + datasize1 + datasize2);
    }
#endif /* HISTO */

  error = net_client_request_send_msg (&eid, request, 1, argbuf, argsize);
  if (error != NO_ERROR)
    {
      return error;
    }

  do
    {
      error = net_client_request_recv_msg (&tmp_recv_packet, eid, -1,
					   1, reply, replysize);
      if (error != NO_ERROR)
	{
	  return error;
	}

      ptr = or_unpack_int (reply, &server_request_num);
      server_request = (QUERY_SERVER_REQUEST) server_request_num;

      switch (server_request)
	{
	case QUERY_END:
	case END_CALLBACK:
	  if (recv_packet)
	    {
	      *recv_packet = tmp_recv_packet;
	      tmp_recv_packet = NULL;
	    }
	  break;

	default:
	  error = ER_NET_SERVER_DATA_RECEIVE;
	  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
	  server_request = QUERY_END;
	  break;
	}

      css_net_packet_free (tmp_recv_packet);
    }
  while (server_request != END_CALLBACK && server_request != QUERY_END);

#if defined(HISTO)
  if (net_Histo_setup)
    {
      net_histo_request_finished (request,
				  replysize + *replydatasize_listid +
				  *replydatasize_page + *replaydatasize_plan);
    }
#endif /* HISTO */
  return (error);
}

/*
 * net_client_get_log_header -
 *
 * return:
 * Note:
 */
int
net_client_get_log_header (LOGWR_CONTEXT * ctx_ptr,
			   char *argbuf, int argsize,
			   char *replybuf, int replysize,
			   char **logpg_area_buf)
{
  unsigned int eid;
  char *ptr;
  int error = NO_ERROR;
  int request = NET_SERVER_LOGWR_GET_LOG_PAGES;
  QUERY_SERVER_REQUEST server_request;
  int server_request_num;
  CSS_NET_PACKET *recv_packet = NULL;

  if (ctx_ptr->rc == -1)
    {
      /* HEADER PAGE REQUEST */
      error = net_client_request_send_msg (&eid, request, 1, argbuf, argsize);
      if (error != NO_ERROR)
	{
	  return error;
	}

      ctx_ptr->rc = eid;
    }
  else
    {
      /* END PROTOCOL */
      eid = ctx_ptr->rc;
      error = net_client_data_send_msg (eid, 1, argbuf, argsize);
      if (error != NO_ERROR)
	{
	  return error;
	}
    }

  error = net_client_request_recv_msg (&recv_packet, eid, -1, 1,
				       replybuf, replysize);
  if (error != NO_ERROR)
    {
      return (error);
    }

  ptr = or_unpack_int (replybuf, &server_request_num);
  server_request = (QUERY_SERVER_REQUEST) server_request_num;

  switch (server_request)
    {
    case GET_NEXT_LOG_PAGES:
      {
	int length;
	INT64 pageid;
	int num_page, file_status, server_status;
	char *logpg_area;
	bool is_zipped = false;

	ptr = or_unpack_int (ptr, (int *) (&length));
	ptr = or_unpack_int64 (ptr, &pageid);
	ptr = or_unpack_int (ptr, &num_page);
	ptr = or_unpack_int (ptr, &file_status);
	ptr = or_unpack_int (ptr, &server_status);
#if 1
	if (ZIP_CHECK (length))
	  {
	    is_zipped = true;
	    length = (int) GET_ZIP_LEN (length);
	  }
#endif

	if (length <= 0)
	  {
	    er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE,
		    ER_NET_SERVER_CRASHED, 0);
	    error = ER_NET_SERVER_CRASHED;
	  }
	else
	  {
	    logpg_area = css_net_packet_get_buffer (recv_packet, 1,
						    length, true);
	    if (logpg_area == NULL)
	      {
		error = ER_NET_SERVER_DATA_RECEIVE;
		er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
	      }
	    else
	      {
#if 1
		if (is_zipped)
		  {
		    LOG_ZIP *unzip_logpg_area;

		    unzip_logpg_area = log_zip_alloc (LOG_PAGESIZE, false);
		    if (unzip_logpg_area == NULL)
		      {
			assert (false);	/* TODO - */
			error = ER_NET_SERVER_DATA_RECEIVE;
			er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
		      }
		    else
		      {
			if (!log_unzip (unzip_logpg_area, length, logpg_area))
			  {
			    assert (false);	/* TODO - */
			    error = ER_NET_SERVER_DATA_RECEIVE;
			    er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error,
				    0);
			  }
			else
			  {
			    assert (unzip_logpg_area->data_length <=
				    LOG_PAGESIZE);

			    free_and_init (logpg_area);
			    logpg_area =
			      malloc (unzip_logpg_area->data_length);
			    if (logpg_area == NULL)
			      {
				assert (false);	/* TODO - */
				error = ER_NET_SERVER_DATA_RECEIVE;
				er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE,
					error, 0);
			      }
			    else
			      {
				memcpy (logpg_area,
					unzip_logpg_area->log_data,
					(int) unzip_logpg_area->data_length);
				length = unzip_logpg_area->data_length;
			      }
			  }

			log_zip_free (unzip_logpg_area);
			unzip_logpg_area = NULL;
		      }
		  }
#endif

		*logpg_area_buf = logpg_area;
	      }
	  }
      }
      break;
    case END_CALLBACK:
      error = NO_ERROR;
      break;
    default:
      error = ER_NET_SERVER_DATA_RECEIVE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
      break;
    }

  css_net_packet_free (recv_packet);

  return error;
}

/*
 * net_client_request_with_rbl_context -
 *
 * return:
 * Note:
 */
int
net_client_request_with_rbl_context (RBL_SYNC_CONTEXT * ctx_ptr,
				     char *argbuf, int argsize,
				     char *replybuf, int replysize)
{
  unsigned int eid;
  int error;
  int length;
  bool is_zipped = false;
  int data_recv_size;
  CSS_NET_PACKET *recv_packet = NULL;

  error =
    net_client_request_send_msg (&eid, NET_SERVER_MIGRATOR_GET_LOG_PAGES, 1,
				 argbuf, argsize);

  if (error != NO_ERROR)
    {
      return error;
    }

  error = net_client_request_recv_msg (&recv_packet, eid, -1, 2,
				       replybuf, replysize,
				       ctx_ptr->logpg_area,
				       ctx_ptr->logpg_area_size);
  if (error != NO_ERROR)
    {
      return error;
    }

  (void) or_unpack_int (replybuf, &length);

#if 1
  if (ZIP_CHECK (length))
    {
      length = (int) GET_ZIP_LEN (length);
      is_zipped = true;
    }
#endif

  data_recv_size = css_net_packet_get_recv_size (recv_packet, 1);

  if (data_recv_size < length || ctx_ptr->logpg_area_size < length)
    {
      error = ER_NET_SERVER_CRASHED;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
    }
  else
    {
#if 1
      if (is_zipped)
	{
	  if (!log_unzip (ctx_ptr->unzip_area, length, ctx_ptr->logpg_area))
	    {
	      assert (false);	/* TODO - */
	      error = ER_NET_SERVER_CRASHED;
	      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
	    }
	  else
	    {
	      memcpy (ctx_ptr->logpg_area,
		      ctx_ptr->unzip_area->log_data,
		      (int) ctx_ptr->unzip_area->data_length);

	      length = ctx_ptr->unzip_area->data_length;
	    }
	}
#endif

      ctx_ptr->logpg_fill_size = length;
    }

  css_net_packet_free (recv_packet);

  return error;
}

/*
 * net_client_logwr_send_end_msg
 *
 * return:
 * note:
 */
int
net_client_logwr_send_end_msg (unsigned int eid, int error)
{
  OR_ALIGNED_BUF (OR_INT_SIZE * 2 + OR_INT64_SIZE) a_request;
  char *request;
  char *ptr;

  request = OR_ALIGNED_BUF_START (a_request);

  /* END REQUEST */
  ptr = or_pack_int64 (request, LOGPB_HEADER_PAGE_ID);
  ptr = or_pack_int (ptr, LOGWR_MODE_ASYNC);
  ptr = or_pack_int (ptr, error);

  return (net_client_data_send_msg (eid, 1,
				    request,
				    OR_ALIGNED_BUF_SIZE (a_request)));
}

/*
 * net_client_request_recv_stream -
 *
 * return:
 *
 *   request(in):
 *   argbuf(in):
 *   argsize(in):
 *   replybuf(in):
 *   replybuf_size(in):
 *   databuf(in):
 *   datasize(in):
 *   outfp(in):
 *
 * Note:
 */
int
net_client_request_recv_stream (int request,
				char *argbuf, int argsize,
				char *replybuf, int replybuf_size,
				char *databuf, int datasize, FILE * outfp)
{
  unsigned int eid;
  int size;
  int error;
  char *send_argbuffer = NULL;
  int send_argsize;
  char *recv_replybuf = NULL;
  int recv_replybuf_size;
  char reply_streamdata[100];
  int reply_streamdata_size = 100;
  int file_size;

  error = NO_ERROR;

  send_argsize = argsize + OR_INT_SIZE;
  recv_replybuf_size = replybuf_size + OR_INT_SIZE;

  send_argbuffer = (char *) malloc (send_argsize);
  if (send_argbuffer == NULL)
    {
      error = ER_NET_CANT_ALLOC_BUFFER;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
      goto end;
    }

  or_pack_int (send_argbuffer, reply_streamdata_size);

  if (argsize > 0)
    {
      memcpy (send_argbuffer + OR_INT_SIZE, argbuf, argsize);
    }

  recv_replybuf = (char *) malloc (recv_replybuf_size);
  if (recv_replybuf == NULL)
    {
      error = ER_NET_CANT_ALLOC_BUFFER;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
      goto end;
    }

#if defined(HISTO)
  if (net_Histo_setup)
    {
      net_histo_add_entry (request, send_argsize + datasize);
    }
#endif /* HISTO */

  error = net_client_request_send_msg (&eid, request, 2,
				       send_argbuffer, send_argsize,
				       databuf, datasize);

  if (error != NO_ERROR)
    {
      goto end;
    }

  error = net_client_request_recv_msg (NULL, eid, -1, 1,
				       recv_replybuf, recv_replybuf_size);
  if (error != NO_ERROR)
    {
      goto end;
    }

  /* Get total size of file to transfered */
  or_unpack_int (recv_replybuf, &file_size);

  if (replybuf)
    {
      memcpy (replybuf, recv_replybuf + OR_INT_SIZE,
	      recv_replybuf_size - OR_INT_SIZE);
    }

#if defined(HISTO)
  if (net_Histo_setup)
    {
      net_histo_request_finished (request, recv_replybuf_size + file_size);
    }
#endif /* HISTO */

  while (file_size > 0 && error == NO_ERROR)
    {
      CSS_NET_PACKET *recv_packet = NULL;

      error = net_client_request_recv_msg (&recv_packet, eid, -1, 1,
					   reply_streamdata,
					   reply_streamdata_size);

      if (error != NO_ERROR)
	{
	  /* TODO: set_server_error ??? */
	  goto end;
	}

      size = css_net_packet_get_recv_size (recv_packet, 0);

      if (size > reply_streamdata_size)
	{
	  error = ER_NET_DATASIZE_MISMATCH;
	  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE,
		  error, 2, reply_streamdata_size, size);
	  goto end;
	}
      else
	{
	  fwrite (reply_streamdata, 1, size, outfp);
	  file_size -= size;
	}

      css_net_packet_free (recv_packet);
    }

end:

  if (send_argbuffer)
    {
      free_and_init (send_argbuffer);
    }
  if (recv_replybuf)
    {
      free_and_init (recv_replybuf);
    }

  return (error);
}

/*
 * net_client_ping_server -ping the server
 *
 * return:
 */

int
net_client_ping_server (int client_val, int *server_val,
			UNUSED_ARG int timeout)
{
  OR_ALIGNED_BUF (OR_INT_SIZE) a_request;
  char *request = OR_ALIGNED_BUF_START (a_request);
  OR_ALIGNED_BUF (OR_INT_SIZE) a_reply;
  char *reply_buf = OR_ALIGNED_BUF_START (a_reply);
  int error;

  er_log_debug (ARG_FILE_LINE, "The net_client_ping_server() is calling.");

  /* you can envelope something useful into the request */
  or_pack_int (request, client_val);

  error = net_client_request (NET_SERVER_PING, NULL, 1, 1,
			      request, OR_INT_SIZE, reply_buf, OR_INT_SIZE);

  if (error != NO_ERROR)
    {
      return error;
    }

  /* you can get something useful from the server */
  if (server_val)
    {
      or_unpack_int (reply_buf, server_val);
    }

  return error;
}

/*
 * net_client_ping_server_with_handshake -
 *
 * return:
 */
int
net_client_ping_server_with_handshake (int client_type,
				       bool check_capabilities, int opt_cap,
				       RYE_VERSION * server_version)
{
  const char *server_host;
  char *ptr;
  int error = NO_ERROR;
  OR_ALIGNED_BUF (OR_VERSION_SIZE + (OR_INT_SIZE * 3) +
		  MAXHOSTNAMELEN) a_request;
  char *request = OR_ALIGNED_BUF_START (a_request);
  OR_ALIGNED_BUF (OR_VERSION_SIZE + (OR_INT_SIZE * 2) +
		  MAXHOSTNAMELEN) a_reply;
  char *reply = OR_ALIGNED_BUF_START (a_reply);
  int reply_size = OR_ALIGNED_BUF_SIZE (a_reply);
  int request_size, server_capabilities, server_bit_platform;
  int strlen2;
  RYE_VERSION client_version = rel_cur_version ();

  if (net_Server_host[0] == '\0' || net_Server_name[0] == '\0')
    {
      error = ER_NET_NO_SERVER_HOST;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 0);
      return error;
    }

  request_size = (OR_VERSION_SIZE) + (OR_INT_SIZE * 3) +
    or_packed_string_length (boot_Host_name, &strlen2);
  ptr = or_pack_version (request, &client_version);
  ptr = or_pack_int (ptr, client_capabilities ());
  ptr = or_pack_int (ptr, rel_bit_platform ());
  ptr = or_pack_int (ptr, client_type);
  ptr = or_pack_string_with_length (ptr, boot_Host_name, strlen2);

  error = net_client_request (NET_SERVER_PING_WITH_HANDSHAKE, NULL, 1, 1,
			      request, request_size, reply, reply_size);
  if (error != NO_ERROR)
    {
      error = ER_NET_CANT_CONNECT_SERVER;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 2,
	      net_Server_name, net_Server_host);
      return error;
    }

  ptr = or_unpack_version (reply, server_version);
  ptr = or_unpack_int (ptr, &server_capabilities);
  ptr = or_unpack_int (ptr, &server_bit_platform);
  ptr = or_unpack_string_nocopy (ptr, &server_host);

  /* check bits model */
  if (server_bit_platform != rel_bit_platform ())
    {
      error = ER_NET_DIFFERENT_BIT_PLATFORM;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 2,
	      server_bit_platform, rel_bit_platform ());
      return error;
    }

  /*
   * 1. get the result of compatibility check.
   * 2. check if the both capabilities of client and server are compatible.
   * 3. check if the server has a capability to make it compatible.
   */
  if (rel_check_net_compatible (&client_version,
				server_version) == REL_NOT_COMPATIBLE)
    {
      char buf1[REL_MAX_VERSION_LENGTH];
      char buf2[REL_MAX_VERSION_LENGTH];

      rel_version_to_string (server_version, buf1, sizeof (buf1));
      rel_version_to_string (&client_version, buf2, sizeof (buf2));

      error = ER_NET_DIFFERENT_RELEASE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 2, buf1, buf2);
      return error;
    }

  if (check_capabilities == true &&
      check_server_capabilities (server_capabilities, client_type,
				 opt_cap) != server_capabilities)
    {
      error = ER_NET_SERVER_HAND_SHAKE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 1, net_Server_host);
      return error;
    }

  return error;
}

/*
 * net_client_init -
 *
 * return: error code
 *
 *   dbname(in): server name
 *   hostname(in): server host name
 *
 * Note: This is called during startup to initialize the client side
 *    communications. It sets up CSS and verifies connection with the server.
 */
int
net_client_init (const char *dbname, const char *hostname)
{
  int error = NO_ERROR;

  /* don't really need to do this every time but bruce says its ok -
     we probably need to guarentee that a css_terminate is always
     called before this */
  error = css_client_init (prm_get_integer_value (PRM_ID_TCP_PORT_ID),
			   dbname, hostname);
  if (error != NO_ERROR)
    {
      goto end;
    }

  /* since urgent_message_handler() doesn't do anything yet, just
     use the default handler provided by css which writes things
     to the system console */

  /* set our host/server names for further css communication */
  if (hostname != NULL && strlen (hostname) <= MAXHOSTNAMELEN)
    {
      strcpy (net_Server_host, hostname);
      net_Server_addr = hostname_to_ip (hostname);
      assert (net_Server_addr != INADDR_NONE);

      if (dbname != NULL && strlen (dbname) <= DB_MAX_IDENTIFIER_LENGTH)
	{
	  strcpy (net_Server_name, dbname);
	}
      else
	{
	  error = ER_NET_INVALID_SERVER_NAME;
	  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 1, dbname);
	}
    }
  else
    {
      error = ER_NET_INVALID_HOST_NAME;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error, 1, hostname);
    }

  /* On error, flush any state that may have been initialized by css.
   * This is important for the PC's since we must shutdown Winsock
   * after it has been opened by css_client_init.
   */
end:
  if (error)
    {
      css_terminate (false);
    }

  return (error);
}

/*
 * net_client_final -
 *
 * return: error cod
 *
 * Note: This is called during shutdown to close the communication interface.
 */
int
net_client_final (void)
{
  css_terminate (false);
  return (NO_ERROR);
}

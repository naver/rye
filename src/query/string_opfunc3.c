/*
 * Copyright (C) 2008 Search Solution Corporation. All rights reserved by Search Solution.
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 *
 */

/*
 * string_opfunc.c - Routines that manipulate arbitrary strings
 */

#ident "$Id$"

/* This includes bit strings, character strings, and national character strings
 */

#include "config.h"

#include <assert.h>
#include <string.h>
#include <errno.h>
#include <math.h>
#include <sys/timeb.h>

#include "chartype.h"
#include "system_parameter.h"
#include "intl_support.h"
#include "error_code.h"
#include "db.h"
#include "memory_alloc.h"
#include "language_support.h"
#include "query_evaluator.h"
#if defined(SERVER_MODE)
#include "thread.h"
#endif

#include "misc_string.h"
#include "md5.h"
#include "porting.h"
#include "crypt_opfunc.h"
#include "base64.h"

/* this must be the last header file included!!! */
#include "dbval.h"

#define UINT64_MAX_HEX_DIGITS 16
#define UINT64_MAX_BIN_DIGITS 64

static int db_get_next_like_pattern_character (const char *const pattern,
					       const int length,
					       const bool has_escape_char,
					       const char *escape_str,
					       int *const position,
					       char **crt_char_p,
					       bool * const is_escaped);
static bool is_safe_last_char_for_like_optimization (const char *chr,
						     const bool is_escaped);
static bool is_valid_ip_slice (const char *ipslice);

/*
 * db_get_date_dayofyear () - compute day of year from a date type value
 *
 * Arguments:
 *	  src_date: datetime from which to compute the day of year
 *
 * Returns: int
 */
int
db_get_date_dayofyear (const DB_VALUE * src_date, DB_VALUE * result)
{
  int month = 0, day = 0, year = 0;
  int second = 0, minute = 0, hour = 0;
  int ms = 0;
  int day_of_year = 0;
  int retval;

  assert (src_date != result);

  if (DB_IS_NULL (src_date))
    {
      DB_MAKE_NULL (result);
      return NO_ERROR;
    }
  /* get the date/time information from src_date */
  retval = db_get_datetime_from_dbvalue (src_date, &year, &month, &day,
					 &hour, &minute, &second, &ms, NULL);
  if (retval != NO_ERROR
      || (year == 0 && month == 0 && day == 0
	  && hour == 0 && minute == 0 && second == 0 && ms == 0))
    {
      /* This function should return NULL if src_date is an invalid parameter
       * or Zero date.
       * Clear the error generated by the function call and return null.
       */
      er_clear ();
      DB_MAKE_NULL (result);
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_DATE_CONVERSION, 0);

      return ER_DATE_CONVERSION;
    }

  day_of_year = db_get_day_of_year (year, month, day);
  DB_MAKE_INT (result, day_of_year);

  return NO_ERROR;
}

/*
 * db_get_date_weekday () - compute day of week from a date type value
 *
 * Arguments:
 *	  src_date: datetime from which to compute the week day
 *	  mode	  : the mode in which week days are numbered
 *		    0 = Monday, ..., 6 = Sunday or
 *		    1 = Sunday, ..., 7 = Saturday
 *
 * Returns: int
 */
int
db_get_date_weekday (const DB_VALUE * src_date, const int mode,
		     DB_VALUE * result)
{
  int month = 0, day = 0, year = 0;
  int second = 0, minute = 0, hour = 0;
  int ms = 0;
  int day_of_week = 0;
  int retval;

  assert (src_date != result);

  if (DB_IS_NULL (src_date))
    {
      DB_MAKE_NULL (result);
      return NO_ERROR;
    }

  /* get the date/time information from src_date */
  retval = db_get_datetime_from_dbvalue (src_date, &year, &month, &day,
					 &hour, &minute, &second, &ms, NULL);
  if (retval != NO_ERROR
      || (year == 0 && month == 0 && day == 0
	  && hour == 0 && minute == 0 && second == 0 && ms == 0))
    {
      /* This function should return NULL if src_date is an invalid parameter
       * or zero date.
       * Clear the error generated by the function call and return null.
       */
      er_clear ();
      DB_MAKE_NULL (result);
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_DATE_CONVERSION, 0);

      return ER_DATE_CONVERSION;
    }

  /* 0 = Sunday, 1 = Monday, etc */
  day_of_week = db_get_day_of_week (year, month, day);

  switch (mode)
    {
    case PT_WEEKDAY:
      /* 0 = Monday, 1 = Tuesday, ..., 6 = Sunday */
      if (day_of_week == 0)
	{
	  day_of_week = 6;
	}
      else
	{
	  day_of_week--;
	}
      DB_MAKE_INT (result, day_of_week);
      break;

    case PT_DAYOFWEEK:
      /* 1 = Sunday, 2 = Monday, ..., 7 = Saturday */
      day_of_week++;
      DB_MAKE_INT (result, day_of_week);
      break;

    default:
      assert (false);
      DB_MAKE_NULL (result);
      break;
    }

  return NO_ERROR;
}

/*
 * db_get_date_quarter () - compute quarter from a date type value
 *
 * Arguments:
 *	  src_date: datetime from which to compute the quarter
 *
 * Returns: int
 */
int
db_get_date_quarter (const DB_VALUE * src_date, DB_VALUE * result)
{
  int month = 0, day = 0, year = 0;
  int second = 0, minute = 0, hour = 0;
  int ms = 0;
  char const *endp = NULL;
  int retval;

  assert (src_date != result);

  if (DB_IS_NULL (src_date))
    {
      DB_MAKE_NULL (result);
      return NO_ERROR;
    }
  /* get the date/time information from src_date */
  retval = db_get_datetime_from_dbvalue (src_date, &year, &month, &day,
					 &hour, &minute, &second, &ms, &endp);
  if (retval != NO_ERROR || (endp && *endp && !char_isspace (*endp)))
    {
      er_clear ();
      DB_MAKE_NULL (result);
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_DATE_CONVERSION, 0);

      return ER_DATE_CONVERSION;
    }

  if (year == 0 && month == 0 && day == 0
      && hour == 0 && minute == 0 && second == 0 && ms == 0)
    {
      /* This function should return 0 if src_date is zero date */
      DB_MAKE_INT (result, 0);
    }
  /* db_datetime_decode returned NO_ERROR so we can calculate the quarter */
  else if (month == 0)
    {
      assert (false);
      DB_MAKE_INT (result, 0);
    }
  else if (month < 0 || month > 12)
    {
      assert (false);
      DB_MAKE_NULL (result);
    }
  else
    {
      const int quarter = (month - 1) / 3 + 1;
      DB_MAKE_INT (result, quarter);
    }

  return NO_ERROR;
}

/*
 * db_get_date_totaldays () - compute the number of days from the date 0 AD
 *			      until the day represented by src_date
 *
 * Arguments:
 *	  src_date: datetime from which to compute the number of days
 *
 * Returns: int
 */
int
db_get_date_totaldays (const DB_VALUE * src_date, DB_VALUE * result)
{
  int month = 0, day = 0, year = 0;
  int second = 0, minute = 0, hour = 0;
  int ms = 0;
  int leap_years = 0, total_days = 0, days_this_year = 0;
  int retval;

  assert (src_date != result);

  if (DB_IS_NULL (src_date))
    {
      DB_MAKE_NULL (result);
      return NO_ERROR;
    }

  /* get the date/time information from src_date */
  retval = db_get_datetime_from_dbvalue (src_date, &year, &month, &day,
					 &hour, &minute, &second, &ms, NULL);
  if (retval != NO_ERROR
      || (year == 0 && month == 0 && day == 0
	  && hour == 0 && minute == 0 && second == 0 && ms == 0))
    {
      er_clear ();
      DB_MAKE_NULL (result);
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_DATE_CONVERSION, 0);

      return ER_DATE_CONVERSION;
    }

  leap_years = count_leap_years_up_to (year - 1);
  days_this_year = db_get_day_of_year (year, month, day);
  total_days = year * 365 + leap_years + days_this_year;
  DB_MAKE_INT (result, total_days);

  return NO_ERROR;
}

/*
 * db_get_date_from_days () - computes a date by adding the number of days
 *			      represented by src to the year 0 AD
 *
 * Arguments:
 *	  src: number from which to compute the date
 *
 * Returns: date
 */
int
db_get_date_from_days (const DB_VALUE * src, DB_VALUE * result)
{
  int year = 0;
  int month = 0;
  int day = 0;
  int week = 0;
  int int_value = 0;
  int julian_day = 0;

  assert (src != result);

  if (DB_IS_NULL (src))
    {
      DB_MAKE_NULL (result);
      return NO_ERROR;
    }

  if (db_round_dbvalue_to_int (src, &int_value) != NO_ERROR)
    {
      goto exit_on_error;
    }

  /* The count should start from day 0001-01-01.
   * Because year 0 is considered special,
   * this function should return 0000-00-00 for less than 366 days
   */
  if (int_value < 366)
    {
      DB_MAKE_DATE (result, 0, 0, 0);
      return NO_ERROR;
    }

  julian_day = julian_encode (1, 1, 1);

  /* Subtract 364 from the Julian Day to start counting from 0001-01-01 */
  julian_day += int_value - 364;

  julian_decode (julian_day, &month, &day, &year, &week);

  if (year > 9999)
    {
      DB_MAKE_DATE (result, 0, 0, 0);
      return NO_ERROR;
    }

  DB_MAKE_DATE (result, month, day, year);
  return NO_ERROR;

exit_on_error:
  DB_MAKE_NULL (result);
  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_DATE_CONVERSION, 0);

  return ER_DATE_CONVERSION;
}

/*
 * db_add_days_to_year () - computes a date by adding the number of days
 *			    contained in src_days to the date 01/01/src_year
 *
 * Arguments:
 *	  src_year: the year to add days to
 *	  src_days: the number of days to add
 *
 * Returns: date
 */
int
db_add_days_to_year (const DB_VALUE * src_year, const DB_VALUE * src_days,
		     DB_VALUE * result)
{
  int year_value = 0;
  int days_value = 0;
  int julian_day = 0;
  int year = 0, month = 0, day = 0, week = 0;

  assert (src_year != result);
  assert (src_days != result);

  if (DB_IS_NULL (src_year) || DB_IS_NULL (src_days))
    {
      DB_MAKE_NULL (result);
      return NO_ERROR;
    }

  if (db_round_dbvalue_to_int (src_year, &year_value) != NO_ERROR)
    {
      goto error;
    }

  if (db_round_dbvalue_to_int (src_days, &days_value) != NO_ERROR)
    {
      goto error;
    }

  /*days<=0 or year_value <0 are invalid values */
  if (days_value <= 0 || year_value < 0)
    {
      goto error;
    }

  /* correct the year value by applying the following rules:
     - if  0 <= year <= 69 then consider year as 20yy (e.g.: 33 is 2033)
     - if 70 <= year <= 99 then consider year as 19yy (e.g.: 71 is 1971)
   */
  if (year_value < 70)
    {
      year_value += 2000;
    }
  else if (year_value >= 70 && year_value < 100)
    {
      year_value += 1900;
    }

  julian_day = julian_encode (1, 1, year_value);
  julian_day += days_value - 1;
  julian_decode (julian_day, &month, &day, &year, &week);

  if (year > 9999)
    {
      goto error;
    }

  DB_MAKE_DATE (result, month, day, year);
  return NO_ERROR;

error:
  DB_MAKE_NULL (result);
  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_DATE_CONVERSION, 0);

  return ER_DATE_CONVERSION;
}

/*
 * db_convert_to_time () - creates a time value from the given hour, minute,
 *			   second
 *
 * Arguments:
 *	  src_hour: the hour
 *	  src_minute: the minute
 *	  src_second: the second
 *
 * Returns: date
 */
int
db_convert_to_time (const DB_VALUE * src_hour,
		    const DB_VALUE * src_minute,
		    const DB_VALUE * src_second, DB_VALUE * result)
{
  int hour = 0, minute = 0, second = 0;

  assert (src_hour != result);
  assert (src_minute != result);
  assert (src_second != result);

  if (DB_IS_NULL (src_hour) || DB_IS_NULL (src_minute)
      || DB_IS_NULL (src_second))
    {
      DB_MAKE_NULL (result);
      return NO_ERROR;
    }

  if (db_round_dbvalue_to_int (src_hour, &hour) != NO_ERROR
      || db_round_dbvalue_to_int (src_minute, &minute) != NO_ERROR
      || db_round_dbvalue_to_int (src_second, &second) != NO_ERROR)
    {
      goto error;
    }

  if (minute >= 60 || minute < 0 || second >= 60 || second < 0
      || hour >= 24 || hour < 0)
    {
      goto error;
    }

  DB_MAKE_TIME (result, hour, minute, second);
  return NO_ERROR;

error:
  DB_MAKE_NULL (result);
  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_TIME_CONVERSION, 0);

  return ER_TIME_CONVERSION;
}

/*
 * db_convert_sec_to_time() - convert a value that represents a number of
 *			      seconds into a time value
 *			      (hours:minutes:seconds)
 *
 * Arguments:
 *	  src : value to be converted to the time value
 *
 * Returns: int
 *
 * Note:
 *  This function returns values in the interval 00:00:00, 23:59:59. If the
 *  value passed as argument does not fall in this interval then this function
 *  returns the nearest interval limit.
 *
 */
int
db_convert_sec_to_time (const DB_VALUE * src, DB_VALUE * result)
{
  int hours = 0;
  int minutes = 0;
  int seconds = 0;
  int int_value = 0;
  int err;

  assert (src != result);

  if (DB_IS_NULL (src))
    {
      DB_MAKE_NULL (result);
      return NO_ERROR;
    }

  err = db_round_dbvalue_to_int (src, &int_value);
  if (err != NO_ERROR)
    {
      goto error;
    }

  if (int_value < 0 || err == ER_OUT_OF_VIRTUAL_MEMORY)
    {
      goto error;
    }

  hours = int_value / 3600;
  minutes = (int_value - hours * 3600) / 60;
  seconds = int_value % 60;

  if (hours > 23)
    {
      goto error;
    }

  DB_MAKE_TIME (result, hours, minutes, seconds);
  return NO_ERROR;

error:
  DB_MAKE_NULL (result);
  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_TIME_CONVERSION, 0);

  return ER_TIME_CONVERSION;
}

/*
 * db_convert_time_to_sec () - compute the number of seconds that have elapsed
 *			       since 00:00:00 to a given time
 *
 * Arguments:
 *	  src_date: time from which to compute the number of seconds
 *
 * Returns: int
 */
int
db_convert_time_to_sec (const DB_VALUE * src_date, DB_VALUE * result)
{
  int error_status = NO_ERROR;
  int second = 0, minute = 0, hour = 0, millisecond = 0;
  int total_seconds = 0;

  assert (src_date != result);

  if (DB_IS_NULL (src_date))
    {
      DB_MAKE_NULL (result);
      return NO_ERROR;
    }

  error_status = db_get_time_from_dbvalue (src_date, &hour, &minute, &second,
					   &millisecond);
  if (error_status != NO_ERROR)
    {
      er_clear ();
      DB_MAKE_NULL (result);
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_TIME_CONVERSION, 0);

      return ER_TIME_CONVERSION;
    }

  total_seconds = hour * 3600 + minute * 60 + second;
  DB_MAKE_INT (result, total_seconds);

  return NO_ERROR;
}

/*
 * db_round_dbvalue_to_int() - converts a db value to an integer rounding the
 *			       value to the nearest integer
 *
 * Arguments:
 *	  src : value to be converted to int
 * Return: NO_ERROR or error code.
 * Note: for string source values the function will return the converted
 *  number or 0 otherwise.
 */
int
db_round_dbvalue_to_int (const DB_VALUE * src, int *result)
{
  DB_TYPE src_type = DB_VALUE_DOMAIN_TYPE (src);

  switch (src_type)
    {
    case DB_TYPE_INTEGER:
      *result = DB_GET_INT (src);
      return NO_ERROR;

    case DB_TYPE_DOUBLE:
      {
	double x = DB_GET_DOUBLE (src);
	*result = (int) ((x) > 0 ? ((x) + .5) : ((x) - .5));
	return NO_ERROR;
      }

    case DB_TYPE_NUMERIC:
      {
	double x = 0;
	numeric_coerce_num_to_double (db_locate_numeric ((DB_VALUE *) src),
				      DB_VALUE_SCALE (src), &x);
	*result = (int) ((x) > 0 ? ((x) + .5) : ((x) - .5));
	return NO_ERROR;
      }

    case DB_TYPE_BIGINT:
      *result = (int) DB_GET_BIGINT (src);
      return NO_ERROR;

    case DB_TYPE_VARCHAR:
      {
	double x;
	DB_VALUE val;
	int error_status = tp_value_string_to_double (src, &val);

	if (error_status != NO_ERROR)
	  {
	    return error_status;
	  }

	x = DB_GET_DOUBLE (&val);
	*result = (int) ((x) > 0 ? ((x) + .5) : ((x) - .5));
	return NO_ERROR;
      }

    default:
      *result = 0;
      return ER_FAILED;
    }

  *result = 0;
  return ER_FAILED;
}

/*
 * db_get_date_week () - compute the week number of a given date time
 *
 * Arguments:
 *	  src_date: datetime from which to compute the week number
 *	  mode: specifies the mode in which to count the weeks
 *
 * Returns: int
 */
int
db_get_date_week (const DB_VALUE * src_date, const DB_VALUE * mode,
		  DB_VALUE * result)
{
  int month = 0, day = 0, year = 0;
  int second = 0, minute = 0, hour = 0;
  int ms = 0;
  int calc_mode = 0;		/* default */
  int week_number = 0;
  int retval;

  assert (src_date != result);
  assert (mode != result);

  if (DB_IS_NULL (src_date))
    {
      DB_MAKE_NULL (result);
      return NO_ERROR;
    }

  /* get the date/time information from src_date */
  retval = db_get_datetime_from_dbvalue (src_date, &year, &month, &day,
					 &hour, &minute, &second, &ms, NULL);
  if (retval != NO_ERROR
      || (year == 0 && month == 0 && day == 0
	  && hour == 0 && minute == 0 && second == 0 && ms == 0))
    {
      goto error;
    }

  if (DB_IS_NULL (mode))
    {
      calc_mode = 0;		/* default */
    }
  else
    {
      if (db_round_dbvalue_to_int (mode, &calc_mode) != NO_ERROR)
	{
	  goto error;
	}
    }
  /* check boundaries for calc_mode */
  if (calc_mode < 0 || calc_mode > 7)
    {
      goto error;
    }

  week_number = db_get_week_of_year (year, month, day, calc_mode);

  DB_MAKE_INT (result, week_number);
  return NO_ERROR;

error:
  er_clear ();
  DB_MAKE_NULL (result);
  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_DATE_CONVERSION, 0);

  return ER_DATE_CONVERSION;
}

/*
 * db_get_date_item () - compute an item from a datetime value
 *
 * Arguments:
 *	  src_date: datetime from which to calculate the item
 *	  item_type: one of year, month, day
 *
 * Returns: int
 */
int
db_get_date_item (const DB_VALUE * src_date, const int item_type,
		  DB_VALUE * result)
{
  int month = 0, day = 0, year = 0;
  int second = 0, minute = 0, hour = 0;
  int ms = 0;

  assert (src_date != result);

  if (DB_IS_NULL (src_date))
    {
      DB_MAKE_NULL (result);
      return NO_ERROR;
    }

  /* get the date/time information from src_date */
  if (db_get_datetime_from_dbvalue (src_date, &year, &month, &day, &hour,
				    &minute, &second, &ms, NULL) != NO_ERROR)
    {
      /* This function should return NULL if src_date is an invalid parameter.
         Clear the error generated by the function call and return null.
       */
      er_clear ();
      DB_MAKE_NULL (result);
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_DATE_CONVERSION, 0);

      return ER_DATE_CONVERSION;
    }

  switch (item_type)
    {
    case PT_YEARF:
      DB_MAKE_INT (result, year);
      break;
    case PT_MONTHF:
      DB_MAKE_INT (result, month);
      break;
    case PT_DAYF:
      DB_MAKE_INT (result, day);
      break;
    default:
      assert (false);
      DB_MAKE_NULL (result);
      break;
    }

  return NO_ERROR;
}

/*
 * db_get_time_item () - compute an item from a datetime value
 *
 * Arguments:
 *	  src_date: datetime from which to calculate the item
 *	  item_type: one of hour, minute, second
 *
 * Returns: int
 */
int
db_get_time_item (const DB_VALUE * src_date, const int item_type,
		  DB_VALUE * result)
{
  int second = 0, minute = 0, hour = 0, millisecond = 0;

  assert (src_date != result);

  if (DB_IS_NULL (src_date))
    {
      DB_MAKE_NULL (result);
      return NO_ERROR;
    }

  if (db_get_time_from_dbvalue (src_date, &hour, &minute, &second,
				&millisecond) != NO_ERROR)
    {
      er_clear ();
      DB_MAKE_NULL (result);
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_TIME_CONVERSION, 0);

      return ER_TIME_CONVERSION;
    }

  switch (item_type)
    {
    case PT_HOURF:
      DB_MAKE_INT (result, hour);
      break;
    case PT_MINUTEF:
      DB_MAKE_INT (result, minute);
      break;
    case PT_SECONDF:
      DB_MAKE_INT (result, second);
      break;
    default:
      assert (false);
      DB_MAKE_NULL (result);
      break;
    }

  return NO_ERROR;
}

/*
 * db_last_day () -
 */
int
db_last_day (const DB_VALUE * src_date, DB_VALUE * result_day)
{
  int error_status = NO_ERROR;
  DB_VALUE tmp_src_date;
  int month, day, year;
  int lastday;

  assert (src_date != (DB_VALUE *) NULL);
  assert (result_day != (DB_VALUE *) NULL);
  assert (src_date != result_day);

  /* arg init tmp ***********************************************************
   */
  DB_MAKE_NULL_NARGS (1, &tmp_src_date);

  /* arg check null *********************************************************
   */
  if (DB_IS_NULL_NARGS (1, src_date))
    {
      DB_MAKE_NULL (result_day);
      goto done;
    }

  /* arg cast type **********************************************************
   */

  src_date =
    db_value_cast_arg (src_date, &tmp_src_date, DB_TYPE_DATE, &error_status);

  if (error_status != NO_ERROR)
    {
      assert (er_errid () != NO_ERROR);
      goto exit_on_error;
    }

  /* start main body ********************************************************
   */

  db_date_decode ((DB_DATE *) & src_date->data.date, &month, &day, &year);

  if (month == 0 && day == 0 && year == 0)
    {
      error_status = ER_DATE_CONVERSION;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_DATE_CONVERSION, 0);
      goto exit_on_error;
    }

  lastday = get_last_day (month, year);

  DB_MAKE_DATE (result_day, month, lastday, year);

  if (error_status != NO_ERROR)
    {
      goto exit_on_error;
    }

done:
  assert (error_status == NO_ERROR);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (1, &tmp_src_date);

  return error_status;

exit_on_error:
  assert (error_status != NO_ERROR);

  if (er_errid () == NO_ERROR)
    {
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OBJ_INVALID_ARGUMENTS, 0);
    }

  DB_MAKE_NULL (result_day);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (1, &tmp_src_date);

  return error_status;
}

/*
 * db_months_between () -
 */
int
db_months_between (const DB_VALUE * start_mon,
		   const DB_VALUE * end_mon, DB_VALUE * result_mon)
{
  int error_status = NO_ERROR;
  DB_VALUE tmp_start_mon, tmp_end_mon;
  double result_double;
  int start_month, start_day, start_year;
  int end_month, end_day, end_year;
  UNUSED_VAR DB_DATE *start_date, *end_date;

  assert (start_mon != (DB_VALUE *) NULL);
  assert (end_mon != (DB_VALUE *) NULL);
  assert (result_mon != (DB_VALUE *) NULL);
  assert (start_mon != result_mon);
  assert (end_mon != result_mon);

  /* now return null */

  /* arg init tmp ***********************************************************
   */
  DB_MAKE_NULL_NARGS (2, &tmp_start_mon, &tmp_end_mon);

  /* arg check null *********************************************************
   */
  if (DB_IS_NULL_NARGS (2, start_mon, end_mon))
    {
      DB_MAKE_NULL (result_mon);
      goto done;
    }

  /* arg cast type **********************************************************
   */
  start_mon =
    db_value_cast_arg (start_mon, &tmp_start_mon, DB_TYPE_DATE,
		       &error_status);
  end_mon =
    db_value_cast_arg (end_mon, &tmp_end_mon, DB_TYPE_DATE, &error_status);

  if (error_status != NO_ERROR)
    {
      assert (er_errid () != NO_ERROR);
      goto exit_on_error;
    }

  /* start main body ********************************************************
   */

  db_date_decode ((DB_DATE *) & start_mon->data.date, &start_month,
		  &start_day, &start_year);
  db_date_decode ((DB_DATE *) & end_mon->data.date, &end_month, &end_day,
		  &end_year);

  if (start_day == end_day
      || (start_day == get_last_day (start_month, start_year)
	  && end_day == get_last_day (end_month, end_year)))
    {
      result_double = (double) (start_year * 12 + start_month -
				end_year * 12 - end_month);
    }
  else
    {
      start_date = DB_GET_DATE (start_mon);
      end_date = DB_GET_DATE (end_mon);

      result_double = (double) ((start_year - end_year) * 12.0) +
	(double) (start_month - end_month) +
	(double) ((start_day - end_day) / 31.0);
    }

  DB_MAKE_DOUBLE (result_mon, result_double);

  if (error_status != NO_ERROR)
    {
      goto exit_on_error;
    }

done:
  assert (error_status == NO_ERROR);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (2, &tmp_start_mon, &tmp_end_mon);

  return error_status;

exit_on_error:
  assert (error_status != NO_ERROR);

  if (er_errid () == NO_ERROR)
    {
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OBJ_INVALID_ARGUMENTS, 0);
    }

  DB_MAKE_NULL (result_mon);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (2, &tmp_start_mon, &tmp_end_mon);

  return error_status;
}

#if defined (ENABLE_UNUSED_FUNCTION)
/*
 * db_sys_date () -
 */
int
db_sys_date (DB_VALUE * result_date)
{
  int error_status = NO_ERROR;
  time_t tloc;
  struct tm *c_time_struct, tm_val;

  assert (result_date != (DB_VALUE *) NULL);

  /* now return null */
  db_value_domain_init (result_date, DB_TYPE_DATE, DB_DEFAULT_PRECISION,
			DB_DEFAULT_SCALE);

  /* Need checking error */

  if (time (&tloc) == -1)
    {
      error_status = ER_SYSTEM_DATE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      return error_status;
    }

  c_time_struct = localtime_r (&tloc, &tm_val);
  if (c_time_struct == NULL)
    {
      error_status = ER_SYSTEM_DATE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      return error_status;
    }

  DB_MAKE_DATE (result_date, c_time_struct->tm_mon + 1,
		c_time_struct->tm_mday, c_time_struct->tm_year + 1900);

  return error_status;
}

/*
 * db_sys_time () -
 */
int
db_sys_time (DB_VALUE * result_time)
{
  int error_status = NO_ERROR;
  time_t tloc;
  struct tm *c_time_struct, tm_val;

  assert (result_time != (DB_VALUE *) NULL);

  /* now return null */
  db_value_domain_init (result_time, DB_TYPE_TIME, DB_DEFAULT_PRECISION,
			DB_DEFAULT_SCALE);

  /* Need checking error */

  if (time (&tloc) == -1)
    {
      error_status = ER_SYSTEM_DATE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      return error_status;
    }

  c_time_struct = localtime_r (&tloc, &tm_val);
  if (c_time_struct == NULL)
    {
      error_status = ER_SYSTEM_DATE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      return error_status;
    }

  DB_MAKE_TIME (result_time, c_time_struct->tm_hour, c_time_struct->tm_min,
		c_time_struct->tm_sec);

  return error_status;
}
#endif

/*
 * db_sys_datetime () -
 */
int
db_sys_datetime (DB_VALUE * result_datetime)
{
  int error_status = NO_ERROR;
  DB_DATETIME datetime;

  struct timeb tloc;
  struct tm *c_time_struct, tm_val;

  assert (result_datetime != (DB_VALUE *) NULL);

  /* now return null */
  db_value_domain_init (result_datetime, DB_TYPE_DATETIME,
			DB_DEFAULT_PRECISION, DB_DEFAULT_SCALE);

  if (ftime (&tloc) != 0)
    {
      error_status = ER_SYSTEM_DATE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      return error_status;
    }

  c_time_struct = localtime_r (&tloc.time, &tm_val);
  if (c_time_struct == NULL)
    {
      error_status = ER_SYSTEM_DATE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      return error_status;
    }

  db_datetime_encode (&datetime, c_time_struct->tm_mon + 1,
		      c_time_struct->tm_mday, c_time_struct->tm_year + 1900,
		      c_time_struct->tm_hour, c_time_struct->tm_min,
		      c_time_struct->tm_sec, tloc.millitm);
  DB_MAKE_DATETIME (result_datetime, &datetime);

  return error_status;
}

/*
 * This function return the current timezone , as an integer representing
 * the minutes away from GMT
 */
int
db_sys_timezone (DB_VALUE * result_timezone)
{
  int error_status = NO_ERROR;
  struct timeb tloc;

  assert (result_timezone != (DB_VALUE *) NULL);

  /* now return null */
  db_value_domain_init (result_timezone, DB_TYPE_INTEGER,
			DB_DEFAULT_PRECISION, DB_DEFAULT_SCALE);

  /* Need checking error                  */

  if (ftime (&tloc) == -1)
    {
      error_status = ER_SYSTEM_DATE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      return error_status;
    }

  DB_MAKE_INTEGER (result_timezone, tloc.timezone);
  return NO_ERROR;
}

/*
 * get_last_day () -
 */
int
get_last_day (int month, int year)
{
  int lastday = 0;

  if (year >= 1700)
    {
      switch (month)
	{
	case 1:
	case 3:
	case 5:
	case 7:
	case 8:
	case 10:
	case 12:
	  lastday = 31;
	  break;
	case 4:
	case 6:
	case 9:
	case 11:
	  lastday = 30;
	  break;
	case 2:
	  if (year % 4 == 0)
	    {
	      if (year % 100 == 0)
		{
		  if (year % 400 == 0)
		    {
		      lastday = 29;
		    }
		  else
		    {
		      lastday = 28;
		    }
		}
	      else
		{
		  lastday = 29;
		}
	    }
	  else
	    {
	      lastday = 28;
	    }
	  break;
	default:
	  break;		/*  Need Error Checking          */
	}
    }
  else
    {
      switch (month)
	{
	case 1:
	case 3:
	case 5:
	case 7:
	case 8:
	case 10:
	case 12:
	  lastday = 31;
	  break;
	case 4:
	case 6:
	case 9:
	case 11:
	  lastday = 30;
	  break;
	case 2:
	  if (year % 4 == 0)
	    {
	      lastday = 29;
	    }
	  else
	    {
	      lastday = 28;
	    }
	  break;
	default:
	  break;		/*  Need Error Checking          */
	}
    }
  return lastday;
}

/*
 * db_string_reverse () - reverse the source DB_VALUE string
 *
 *   return:
 *   src_str(in): source DB_VALUE string
 *   result_str(in/out): result DB_VALUE string
 */
int
db_string_reverse (const DB_VALUE * src_str, DB_VALUE * result_str)
{
  int error_status = NO_ERROR;
  DB_VALUE tmp_src_str;
  char *res = NULL;

  /*
   *  Assert that DB_VALUE structures have been allocated.
   */
  assert (src_str != (DB_VALUE *) NULL);
  assert (result_str != (DB_VALUE *) NULL);
  assert (src_str != result_str);

  /* arg init tmp ***********************************************************
   */
  DB_MAKE_NULL_NARGS (1, &tmp_src_str);

  /* arg check null *********************************************************
   */
  if (DB_IS_NULL_NARGS (1, src_str))
    {
      DB_MAKE_NULL (result_str);
      goto done;
    }

  /* arg cast type **********************************************************
   */
  src_str =
    db_value_cast_arg (src_str, &tmp_src_str, DB_TYPE_VARCHAR, &error_status);

  if (error_status != NO_ERROR)
    {
      assert (er_errid () != NO_ERROR);
      goto exit_on_error;
    }

  /* start main body ********************************************************
   */

  /*
   *  If the input parameters have been properly validated, then
   *  we are ready to operate.
   */

  res = (char *) malloc (DB_GET_STRING_SIZE (src_str) + 1);
  if (res == NULL)
    {
      error_status = ER_OUT_OF_VIRTUAL_MEMORY;
      goto exit_on_error;
    }

  memset (res, 0, DB_GET_STRING_SIZE (src_str) + 1);
  intl_reverse_string ((unsigned char *) DB_PULL_STRING (src_str),
		       (unsigned char *) res,
		       DB_GET_STRING_LENGTH (src_str),
		       DB_GET_STRING_SIZE (src_str));

  DB_MAKE_VARCHAR (result_str, DB_GET_STRING_PRECISION (src_str),
		   res, DB_GET_STRING_SIZE (src_str),
		   DB_GET_STRING_COLLATION (src_str));

  result_str->need_clear = true;

  if (error_status != NO_ERROR)
    {
      pr_clear_value (result_str);
      goto exit_on_error;
    }

done:
  assert (error_status == NO_ERROR);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (1, &tmp_src_str);

  return error_status;

exit_on_error:
  assert (error_status != NO_ERROR);

  if (er_errid () == NO_ERROR)
    {
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OBJ_INVALID_ARGUMENTS, 0);
    }

  DB_MAKE_NULL (result_str);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (1, &tmp_src_str);

  return error_status;
}

/*
 * db_time_dbval () - extract the time from input parameter.
 *   return: NO_ERROR, or error code
 *   result(out) : resultant db_value
 *   datetime_value(in) : time, timestamp or datetime expression
 */
int
db_time_dbval (DB_VALUE * result, const DB_VALUE * datetime_value)
{
  DB_TYPE type;
  char *res_s;
  int hour = 0, min = 0, sec = 0, milisec = 0;
  int size;

  assert (result != datetime_value);

  if (DB_IS_NULL (datetime_value))
    {
      DB_MAKE_NULL (result);
      return NO_ERROR;
    }

  type = DB_VALUE_TYPE (datetime_value);

  if (db_get_time_from_dbvalue (datetime_value, &hour, &min, &sec, &milisec)
      != NO_ERROR)
    {
      DB_MAKE_NULL (result);
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_TIME_CONVERSION, 0);

      return ER_TIME_CONVERSION;
    }

  if (milisec != 0)
    {
      size = 12 + 1;		/* HH:MM:SS.MMM */
    }
  else
    {
      size = 8 + 1;		/* HH:MM:SS */
    }

  res_s = (char *) malloc (size);
  if (res_s == NULL)
    {
      return ER_OUT_OF_VIRTUAL_MEMORY;
    }

  if (milisec != 0)
    {
      sprintf (res_s, "%02d:%02d:%02d.%03d", hour, min, sec, milisec);
    }
  else
    {
      sprintf (res_s, "%02d:%02d:%02d", hour, min, sec);
    }

  switch (type)
    {
    case DB_TYPE_VARCHAR:
      DB_MAKE_VARCHAR (result, TP_FLOATING_PRECISION_VALUE, res_s,
		       strlen (res_s),
		       DB_GET_STRING_COLLATION (datetime_value));
      break;

    default:
      DB_MAKE_STRING (result, res_s);
      break;
    }

  result->need_clear = true;

  return NO_ERROR;
}

/*
 * db_date_dbval () - extract the date from input parameter.
 *   return: NO_ERROR, or ER_code
 *   result(out) : resultant db_value
 *   date_value(in) : date or datetime expression
 */
int
db_date_dbval (DB_VALUE * result, const DB_VALUE * date_value)
{
  DB_TYPE type;
  char *res_s;
  int y, m, d, hour, min, sec, ms;
  int error_status = NO_ERROR;
  int collation_id;

  assert (result != date_value);

  if (date_value == NULL || result == NULL)
    {
      return ER_FAILED;
    }

  y = m = d = 0;

  type = DB_VALUE_DOMAIN_TYPE (date_value);
  if (type == DB_TYPE_NULL || DB_IS_NULL (date_value))
    {
      DB_MAKE_NULL (result);
      return NO_ERROR;
    }

  if (db_get_datetime_from_dbvalue
      (date_value, &y, &m, &d, &hour, &min, &sec, &ms, NULL) != NO_ERROR)
    {
      DB_MAKE_NULL (result);
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_DATE_CONVERSION, 0);

      return ER_DATE_CONVERSION;
    }

  res_s = (char *) malloc (10 + 1);	/* MM/DD/YYYY */
  if (res_s == NULL)
    {
      return ER_OUT_OF_VIRTUAL_MEMORY;
    }

  sprintf (res_s, "%02d/%02d/%04d", m, d, y);

  if (TP_IS_CHAR_BIT_TYPE (DB_VALUE_TYPE (date_value)))
    {
      collation_id = DB_GET_STRING_COLLATION (date_value);
    }
  else
    {
      collation_id = LANG_SYS_COLLATION;
    }

  DB_MAKE_STRING (result, res_s);
  if (result != NULL && TP_IS_CHAR_TYPE (DB_VALUE_DOMAIN_TYPE (result)))
    {
      db_string_put_cs_and_collation (result, collation_id);
    }

  result->need_clear = true;

  return error_status;
}

/*
 *  count_leap_years_up_to - count the leap years up to year
 *  return: the counted value
 *  year(in) : the last year to evaluate
 */
int
count_leap_years_up_to (int year)
{
  return (year / 4 - year / 100 + year / 400);
}

/*
 *  count_nonleap_years_up_to - count the non leap years up to year
 *  return: the counted value
 *  year(in) : the last year to evaluate
 */
int
count_nonleap_years_up_to (int year)
{
  return (year - count_leap_years_up_to (year));
}

/*
 * db_date_diff () - expr1 ?? expr2 expressed as a value in days from
 *		     one date to the other.
 *   return: int
 *   result(out) : resultant db_value
 *   date_value1(in)   : first date
 *   date_value2(in)   : second date
 */
int
db_date_diff (const DB_VALUE * date_value1, const DB_VALUE * date_value2,
	      DB_VALUE * result)
{
  DB_TYPE type1, type2;
  int y1 = 0, m1 = 0, d1 = 0;
  int y2 = 0, m2 = 0, d2 = 0;
  int hour, min, sec, ms;
  int cly1, cly2, cnly1, cnly2, cdpm1, cdpm2, cdpy1, cdpy2, diff, i, cd1, cd2;
  int m_days[13] = { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
  int error_status = NO_ERROR;
  int retval;

  assert (date_value1 != result);
  assert (date_value2 != result);

  if (date_value1 == NULL || date_value2 == NULL || result == NULL)
    {
      error_status = ER_FAILED;
      goto error;
    }

  type1 = DB_VALUE_DOMAIN_TYPE (date_value1);
  if (type1 == DB_TYPE_NULL || DB_IS_NULL (date_value1))
    {
      DB_MAKE_NULL (result);
      goto error;
    }

  type2 = DB_VALUE_DOMAIN_TYPE (date_value2);
  if (type2 == DB_TYPE_NULL || DB_IS_NULL (date_value2))
    {
      DB_MAKE_NULL (result);
      goto error;
    }

  retval = db_get_datetime_from_dbvalue
    (date_value1, &y1, &m1, &d1, &hour, &min, &sec, &ms, NULL);
  if (retval != NO_ERROR)
    {
      error_status = ER_DATE_CONVERSION;
      DB_MAKE_NULL (result);
      goto error;
    }

  retval = db_get_datetime_from_dbvalue
    (date_value2, &y2, &m2, &d2, &hour, &min, &sec, &ms, NULL);
  if (retval != NO_ERROR)
    {
      error_status = ER_DATE_CONVERSION;
      DB_MAKE_NULL (result);
      goto error;
    }

  if ((y1 == 0 && m1 == 0 && d1 == 0
       && hour == 0 && min == 0 && sec == 0 && ms == 0)
      || (y2 == 0 && m2 == 0 && d2 == 0
	  && hour == 0 && min == 0 && sec == 0 && ms == 0))
    {
      er_clear ();
      DB_MAKE_NULL (result);
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_DATE_CONVERSION, 0);

      return ER_DATE_CONVERSION;
    }

  cly1 = count_leap_years_up_to (y1 - 1);
  cnly1 = count_nonleap_years_up_to (y1 - 1);
  cdpy1 = cly1 * 366 + cnly1 * 365;
  m_days[2] = LEAP (y1) ? 29 : 28;
  cdpm1 = 0;
  for (i = 1; i < m1; i++)
    {
      cdpm1 += m_days[i];
    }

  cly2 = count_leap_years_up_to (y2 - 1);
  cnly2 = count_nonleap_years_up_to (y2 - 1);
  cdpy2 = cly2 * 366 + cnly2 * 365;
  m_days[2] = LEAP (y2) ? 29 : 28;
  cdpm2 = 0;
  for (i = 1; i < m2; i++)
    {
      cdpm2 += m_days[i];
    }

  cd1 = cdpy1 + cdpm1 + d1;
  cd2 = cdpy2 + cdpm2 + d2;
  diff = cd1 - cd2;

  DB_MAKE_INTEGER (result, diff);

error:
  return error_status;
}

int
db_from_unixtime (const DB_VALUE * src_value, const DB_VALUE * format,
		  const DB_VALUE * date_lang, DB_VALUE * result)
{
  int error_status = NO_ERROR;
  DB_VALUE tmp_src_value, tmp_format;
  time_t unix_timestamp;
  DB_DATETIME result_datetime = { 0, 0 };
  DB_VALUE dt_val;
  DB_VALUE default_date_lang;

  assert (src_value != NULL);
  assert (src_value != result);
  assert (format != result);
  assert (date_lang != result);

  /* arg init tmp ***********************************************************
   */
  DB_MAKE_NULL_NARGS (2, &tmp_src_value, &tmp_format);

  /* arg check null *********************************************************
   */
  if (DB_IS_NULL (src_value) || (format != NULL && DB_IS_NULL (format)))
    {
      DB_MAKE_NULL (result);
      goto done;
    }

  /* arg cast type **********************************************************
   */
  src_value =
    db_value_cast_arg (src_value, &tmp_src_value, DB_TYPE_INTEGER,
		       &error_status);
  if (format != NULL)
    {
      format =
	db_value_cast_arg (format, &tmp_format, DB_TYPE_VARCHAR,
			   &error_status);
    }

  if (error_status != NO_ERROR)
    {
      assert (er_errid () != NO_ERROR);
      goto exit_on_error;
    }

  /* start main body ********************************************************
   */

  unix_timestamp = DB_GET_INT (src_value);
  if (unix_timestamp < 0)
    {
      error_status = ER_DATETIME_CONVERSION;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      goto exit_on_error;
    }

  if (format == NULL)
    {
      /* if unix_timestamp is called without a format argument, return the
         datetime */
      db_localdatetime (&unix_timestamp, &result_datetime);
      DB_MAKE_DATETIME (result, &result_datetime);

      assert (error_status == NO_ERROR);
      goto done;
    }

  db_localdatetime (&unix_timestamp, &result_datetime);
  DB_MAKE_DATETIME (&dt_val, &result_datetime);

  if (date_lang == NULL || DB_IS_NULL (date_lang))
    {
      /* use date_lang for en_US */
      DB_MAKE_INTEGER (&default_date_lang, 0);
      date_lang = &default_date_lang;
    }

  error_status = db_date_format (&dt_val, format, date_lang, result);

  if (error_status != NO_ERROR)
    {
      pr_clear_value (result);
      goto exit_on_error;
    }

done:
  assert (error_status == NO_ERROR);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (2, &tmp_src_value, &tmp_format);

  return error_status;

exit_on_error:
  assert (error_status != NO_ERROR);

  if (er_errid () == NO_ERROR)
    {
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OBJ_INVALID_ARGUMENTS, 0);
    }

  DB_MAKE_NULL (result);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (2, &tmp_src_value, &tmp_format);

  return error_status;
}

/*
 * db_time_diff () - return the difference between TIME values val1 and val2,
 *		     expressed as a TIME value
 *   return: NO_ERROR or error code
 *   result(out) : resultant db_value
 *   val1(in)    : first date/time value
 *   val2(in)    : second date/time value
 */
int
db_time_diff (const DB_VALUE * val1, const DB_VALUE * val2, DB_VALUE * result)
{
  int y1 = 0, m1 = 0, d1 = 0, hour1 = 0, min1 = 0, sec1 = 0;
  int y2 = 0, m2 = 0, d2 = 0, hour2 = 0, min2 = 0, sec2 = 0;
  int error_status = NO_ERROR;
  int leap_years1, leap_years2, days_this_year1, days_this_year2;
  int total_days1, total_days2;
  int total_seconds1, total_seconds2, time_diff, date_diff = 0;
  int min_res, sec_res, hour_res;
  int ret_int, ms;
  DB_TYPE val1_type = DB_TYPE_TIME, val2_type = DB_TYPE_TIME;
  int hour_aux, min_aux, sec_aux, ms_aux;

  assert (val1 != NULL);
  assert (val2 != NULL);
  assert (val1 != result);
  assert (val2 != result);

  if (DB_IS_NULL (val1) || DB_IS_NULL (val2))
    {
      DB_MAKE_NULL (result);
      return NO_ERROR;
    }

  /* get date/time information from val1 */
  if (db_get_time_from_dbvalue (val1, &hour1, &min1, &sec1, &ms) == NO_ERROR)
    {
      if (db_get_datetime_from_dbvalue (val1, &y1, &m1, &d1, &hour_aux,
					&min_aux, &sec_aux, &ms_aux, NULL)
	  == NO_ERROR)
	{
	  if (hour_aux != hour1 || min_aux != min1 || sec_aux != sec1)
	    {
	      y1 = 0;
	      m1 = 0;
	      d1 = 0;
	    }
	  else
	    {
	      val1_type = DB_TYPE_DATETIME;
	    }
	}
    }
  else
    {
      /* val1 may be Date type, try it here */
      if (db_get_datetime_from_dbvalue (val1, &y1, &m1, &d1, &hour_aux,
					&min_aux, &sec_aux, &ms_aux, NULL)
	  == NO_ERROR)
	{
	  val1_type = DB_TYPE_DATE;
	}
      else
	{
	  error_status = ER_TIME_CONVERSION;
	  goto error;
	}
    }

  /* get date/time information from val2 */
  if (db_get_time_from_dbvalue (val2, &hour2, &min2, &sec2, &ms) == NO_ERROR)
    {
      if (db_get_datetime_from_dbvalue (val2, &y2, &m2, &d2, &hour_aux,
					&min_aux, &sec_aux, &ms_aux, NULL)
	  == NO_ERROR)
	{
	  if (hour_aux != hour2 || min_aux != min2 || sec_aux != sec2)
	    {
	      y2 = 0;
	      m2 = 0;
	      d2 = 0;
	    }
	  else
	    {
	      val2_type = DB_TYPE_DATETIME;
	    }
	}
    }
  else
    {
      /* val2 may be Date type, try it here */
      if (db_get_datetime_from_dbvalue (val2, &y2, &m2, &d2, &hour_aux,
					&min_aux, &sec_aux, &ms_aux, NULL)
	  == NO_ERROR)
	{
	  val2_type = DB_TYPE_DATE;
	}
      else
	{
	  error_status = ER_TIME_CONVERSION;
	  goto error;
	}
    }

  if (val1_type != val2_type)
    {
      error_status = ER_QPROC_INVALID_PARAMETER;
      goto error;
    }

  if (val1_type != DB_TYPE_TIME)
    {
      /* convert dates to days */
      leap_years1 = count_leap_years_up_to (y1 - 1);
      days_this_year1 = db_get_day_of_year (y1, m1, d1);
      total_days1 = y1 * 365 + leap_years1 + days_this_year1;

      leap_years2 = count_leap_years_up_to (y2 - 1);
      days_this_year2 = db_get_day_of_year (y2, m2, d2);
      total_days2 = y2 * 365 + leap_years2 + days_this_year2;

      date_diff = total_days1 - total_days2;
    }

  total_seconds1 = sec1 + min1 * 60 + hour1 * 3600;
  total_seconds2 = sec2 + min2 * 60 + hour2 * 3600;
  time_diff = total_seconds1 - total_seconds2;

  date_diff = date_diff * 3600 * 24 + time_diff;

  hour_res = (date_diff / 3600);
  min_res = (date_diff % 3600) / 60;
  sec_res = date_diff - 3600 * hour_res - 60 * min_res;

  DB_MAKE_TIME (result, hour_res, min_res, sec_res);
  ret_int = (int) *(DB_GET_TIME (result));

  /* check time overflow on result */
  if (ret_int < 0)
    {
      error_status = ER_TIME_CONVERSION;
      goto error;
    }

  return NO_ERROR;

error:
  DB_MAKE_NULL (result);
  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);

  return error_status;
}

/*
 * db_get_datetime_from_dbvalue () - splits a generic DB_VALUE to
 *				     year, month, day, hour, minute, second
 * Arguments:
 *         src_date(in) : db_value to split
 *         year(out)	  : year
 *         month(out)	  : month
 *         day(out)	  : day
 *         hour(out)	  : hour
 *         minute(out)  : minute
 *         second(out)  : second
 *	   millisecond(out) : millisecond
 *	   endp(out)	: end pointer into src_date after parsing string
 * Returns: int
 * Note: Callers should not use the global error mechanism.
 *       This function returns ER_FAILED without setting the global error info
 */
int
db_get_datetime_from_dbvalue (const DB_VALUE * src_date,
			      int *year, int *month, int *day,
			      int *hour, int *minute, int *second,
			      int *millisecond, const char **endp)
{
  DB_TYPE arg_type = DB_TYPE_NULL;

  if (DB_IS_NULL (src_date))
    {
      /* return error if src_date is null */
      return ER_FAILED;
    }

  arg_type = DB_VALUE_DOMAIN_TYPE (src_date);
  switch (arg_type)
    {
    case DB_TYPE_VARCHAR:
      {
	DB_DATETIME db_datetime;
	int str_len;
	char *strp;

	strp = DB_PULL_STRING (src_date);
	str_len = DB_GET_STRING_SIZE (src_date);
	if (db_date_parse_datetime_parts
	    (strp, str_len, &db_datetime, NULL, endp) != NO_ERROR)
	  {
	    return ER_FAILED;
	  }

	return db_datetime_decode (&db_datetime, month, day,
				   year, hour, minute, second, millisecond);
      }

    case DB_TYPE_DATE:
      {
	*hour = 0;
	*minute = 0;
	*second = 0;
	*millisecond = 0;
	db_date_decode (DB_GET_DATE (src_date), month, day, year);

	return NO_ERROR;
      }
    case DB_TYPE_DATETIME:
      {
	return db_datetime_decode (DB_GET_DATETIME (src_date), month, day,
				   year, hour, minute, second, millisecond);
      }

    default:
      return ER_FAILED;
    }

  return ER_FAILED;
}

/*
 * db_get_time_from_dbvalue () - splits a generic DB_VALUE to
 *				 hour, minute, second , millisecond
 * Arguments:
 *         src_date(in) : db_value to split
 *         hour(out)	: hour
 *         minute(out)  : minute
 *         second(out)  : second
 *         millisecond(out) : millisecond
 * Returns: int
 *
 * Note: Callers should not use the global error mechanism.
 *       This function returns ER_FAILED without setting the global error info
 */
int
db_get_time_from_dbvalue (const DB_VALUE * src_date, int *hour,
			  int *minute, int *second, int *millisecond)
{
  DB_TYPE arg_type = DB_TYPE_UNKNOWN;

  *millisecond = 0;

  if (DB_IS_NULL (src_date))
    {
      return ER_FAILED;
    }

  arg_type = DB_VALUE_DOMAIN_TYPE (src_date);
  switch (arg_type)
    {
    case DB_TYPE_DATE:
      {
	/* set all to 0 because we don't have any time information */
	*hour = 0;
	*minute = 0;
	*second = 0;
	return NO_ERROR;
      }

    case DB_TYPE_VARCHAR:
      {
	DB_TIME db_time;
	int str_len;
	char *strp;

	strp = DB_GET_STRING (src_date);
	if (strp == NULL)
	  {
	    assert (false);
	    return ER_FAILED;
	  }

	str_len = DB_GET_STRING_SIZE (src_date);
	if (db_date_parse_time (strp, str_len, &db_time, millisecond)
	    != NO_ERROR)
	  {
	    return ER_FAILED;
	  }

	db_time_decode (&db_time, hour, minute, second);
	return NO_ERROR;
      }

    case DB_TYPE_DATETIME:
      {
	int month = 0, day = 0, year = 0;
	return db_datetime_decode (DB_GET_DATETIME (src_date), &month, &day,
				   &year, hour, minute, second, millisecond);
      }

    case DB_TYPE_TIME:
      {
	db_time_decode (DB_GET_TIME (src_date), hour, minute, second);
	return NO_ERROR;
      }

    default:
      return ER_FAILED;
    }

  return ER_FAILED;
}

/*
 * db_get_next_like_pattern_character () - Iterates through a LIKE pattern
 *
 * returns: NO_ERROR or error code
 *
 * pattern(in): the pattern that will be iterated upon
 * length(in): the length of the pattern (bytes)
 * has_escape_char(in): whether the LIKE pattern can use an escape character
 * escape_str(in): if has_escape_char is true this is the escaping character
 *                 used in the pattern, otherwise the parameter has no
 *                 meaning and should have the value NULL
 * position(in/out): pointer to the pattern position counter. The initial
 *                   value of the counter should be 0, meaning no characters
 *                   have yet been iterated. When (*position == length) the
 *                   iteration has come to an end. While iterating the pattern
 *                   the position value should not be changed by the callers
 *                   of this function.
 * crt_char_p(out): when the function returns this is the current character in
 *                  the pattern
 * is_escaped(out): whether the current character pointed to by "character"
 *                  is escaped in the pattern
 */
static int
db_get_next_like_pattern_character (const char *const pattern,
				    const int length,
				    const bool has_escape_char,
				    const char *escape_str,
				    int *const position,
				    char **crt_char_p,
				    bool * const is_escaped)
{
  int error_code = NO_ERROR;
  int char_size = 1;

  if (pattern == NULL || length < 0 || position == NULL || crt_char_p == NULL
      || is_escaped == NULL || *position < 0 || *position >= length)
    {
      error_code = ER_OBJ_INVALID_ARGUMENTS;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_code, 0);
      goto error_exit;
    }

  assert (has_escape_char ^ (escape_str == NULL));

  *crt_char_p = NULL;
  *is_escaped = false;

  if (has_escape_char
      && intl_cmp_char (&(pattern[*position]),
			(unsigned char *) escape_str, &char_size) == 0)
    {
      *position += char_size;
      if (*position >= length)
	{
	  /* To keep MySQL compatibility, when the last character
	   * is escape char, do not return error.*/
	  *crt_char_p = (char *) (&(pattern[*position - char_size]));
	  return error_code;
	}
      *is_escaped = true;
    }

  *crt_char_p = (char *) (&(pattern[*position]));
  intl_char_size ((unsigned char *) *crt_char_p, 1, &char_size);
  *position += char_size;

  return error_code;

error_exit:
  return error_code;
}

/*
 * is_safe_last_char_for_like_optimization () -
 *
 * return: whether a character can be the last one in the string for LIKE
 *         index optimization. See db_get_info_for_like_optimization for
 *         details.
 *
 * chr(in) : the character to consider
 * is_escaped(in) : whether the character is escaped in the LIKE pattern
 */
static bool
is_safe_last_char_for_like_optimization (const char *chr,
					 const bool is_escaped)
{
  assert (chr != NULL);

  if (!is_escaped && QSTR_IS_LIKE_WILDCARD_CHAR (*chr))
    {
      return false;
    }

  if (intl_is_max_bound_chr ((const unsigned char *) chr) ||
      intl_is_min_bound_chr ((const unsigned char *) chr))
    {
      return false;
    }
  return true;
}

/*
 * db_get_info_for_like_optimization () - Gathers the information required for
 *                                        performing the LIKE index
 *                                        optimization
 *
 * returns: NO_ERROR or error code
 *
 * pattern(in): the LIKE pattern
 * has_escape_char(in): whether the LIKE pattern can use an escape character
 * escape_str(in): if has_escape_char is true this is the escaping character
 *                 used in the pattern, otherwise the parameter has no
 *                 meaning and should have the value NULL
 * num_logical_chars(out): the number of logical characters in the pattern.
 *                         This is equal to the pattern length minus the
 *                         escaping characters.
 * last_safe_logical_pos(out): the last character that can be used for the
 *                             string in the predicate rewrite or a negative
 *                             value if that particular rewrite cannot be
 *                             performed
 * num_match_many(out): the number of LIKE_WILDCARD_MATCH_MANY logical
 *                      characters (not escaped '%' characters)
 * num_match_one(out): the number of LIKE_WILDCARD_MATCH_ONE logical
 *                     characters (not escaped '_' characters)
 *
 * Note: db_compress_like_pattern should be applied on the pattern before
 *       calling this function.
 *
 * Note: This function can be used for rewriting a LIKE predicate in order to
 *       maximize the chance of using an index scan. The possible rewrites for
 *       "expr LIKE pattern [ESCAPE escape]" are the following:
 *
 * 1)
 * if the pattern is '%' we match any non-null value; we can rewrite to:
 *      expr IS NOT NULL
 *
 * 2)
 * if the pattern has no wildcards (num_match_many == 0 && num_match_one == 0)
 * and there are no comparison issues caused by trailing pattern whitespace,
 * we can rewrite to a simple equality predicate:
 *      expr = remove_escaping (pattern [, escape])
 *
 * 3.1)
 * in most other cases we can rewrite to:
 *      expr >= like_lower_bound ( like_prefix (pattern [, escape]) ) &&
 *      expr <  like_upper_bound ( like_prefix (pattern [, escape]) ) &&
 *      expr LIKE pattern [ESCAPE escape]
 * The first two predicates provide early filtering of possible matches and
 * can be optimized through index scans. The last predicate provides an extra
 * filter to ensure that the expression actually matches the original pattern.
 *
 * This rewrite is only possible if there exist strings S_lower and S_upper
 * such that all LIKE matches are "BETWEEN S_lower GE_LT S_upper". We can
 * compute these strings (see db_get_like_optimization_bounds) based on the
 * longest prefix that does not contain a '%' character. The prefix itself can
 * generally serve as S_lower while the prefix with the last character
 * incremented by one can serve as S_upper. However, this imposes some
 * restrictions on the last character in the prefix: it must have a succesor
 * (it must not be the character 255), it must not cause issues during index
 * scans (the space character might cause such issues because of its collation
 * properties for VARCHAR). The special '_' wildcard can become the smallest
 * possible character of the collation in S_lower (a space character) and the
 * highest possible character in S_upper (character 255). Because of these
 * properties, the '_' wildcard cannot be the last character in the prefix.
 * Also see the is_safe_last_char_for_like_optimization function that codes
 * this logic used to compute the last_safe_logical_pos parameter value.
 *
 * 3.2)
 * If (pattern == like_prefix (pattern) + '%') and if the pattern does not
 * contain additional wildcards ('_') then we can exclude the LIKE predicate
 * and rewrite to:
 *      expr >= like_lower_bound ( like_prefix (pattern [, escape]) ) &&
 *      expr <  like_upper_bound ( like_prefix (pattern [, escape]) )
 *
 * 3.3)
 * If the rewrite 3.1 cannot be performed we can still use an index scan if
 * like_lower_bound would returns negative infinity and like_upper_bound
 * returns positive infinity, leading to:
 *      expr >= -infinity &&
 *      expr <  +infinity &&
 *      expr LIKE pattern [ESCAPE escape]
 * See db_get_like_optimization_bounds for details.
 *
 * Rewrite 3.1 (combined with the special case 3.3) is the most general,
 * covering all the possible combinations, although it might result in slower
 * execution than the alternatives.
 */
int
db_get_info_for_like_optimization (const DB_VALUE * const pattern,
				   const bool has_escape_char,
				   const char *escape_str,
				   int *const num_logical_chars,
				   int *const last_safe_logical_pos,
				   int *const num_match_many,
				   int *const num_match_one)
{
  int i = 0;
  int error_code = NO_ERROR;
  const char *pattern_str = NULL;
  int pattern_size = 0;

  if (pattern == NULL || num_logical_chars == NULL ||
      last_safe_logical_pos == NULL || num_match_many == NULL ||
      num_match_one == NULL)
    {
      error_code = ER_OBJ_INVALID_ARGUMENTS;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_code, 0);
      goto error_exit;
    }

  assert (has_escape_char ^ (escape_str == NULL));

  if (DB_IS_NULL (pattern) || !QSTR_IS_CHAR (DB_VALUE_DOMAIN_TYPE (pattern)))
    {
      error_code = ER_TP_CANT_COERCE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_code, 2,
	      pr_type_name (DB_VALUE_DOMAIN_TYPE (pattern)),
	      pr_type_name (DB_TYPE_VARCHAR));
      goto error_exit;
    }

  *num_logical_chars = 0;
  *last_safe_logical_pos = -22;
  *num_match_many = 0;
  *num_match_one = 0;
  pattern_str = DB_GET_STRING (pattern);
  pattern_size = DB_GET_STRING_SIZE (pattern);

  for (i = 0; i < pattern_size;)
    {
      char *crt_char_p = NULL;
      bool is_escaped = false;

      error_code =
	db_get_next_like_pattern_character (pattern_str, pattern_size,
					    has_escape_char, escape_str, &i,
					    &crt_char_p, &is_escaped);
      if (error_code != NO_ERROR)
	{
	  goto error_exit;
	}

      if (!is_escaped)
	{
	  if (*crt_char_p == LIKE_WILDCARD_MATCH_MANY)
	    {
	      ++(*num_match_many);
	    }
	  else if (*crt_char_p == LIKE_WILDCARD_MATCH_ONE)
	    {
	      ++(*num_match_one);
	    }
	}

      if (*num_match_many == 0
	  && is_safe_last_char_for_like_optimization (crt_char_p, is_escaped))
	{
	  *last_safe_logical_pos = *num_logical_chars;
	}

      ++(*num_logical_chars);
    }

  return error_code;

error_exit:
  return error_code;
}

/*
 * db_get_like_optimization_bounds () - Computes the bounding limits required
 *                                      for performing the LIKE index
 *                                      optimization
 *
 * returns: NO_ERROR or error code
 *
 * pattern(in): the LIKE pattern
 * bound(out): the computed upper or lower bound.
 * has_escape_char(in): whether the LIKE pattern can use an escape character
 * escape_str(in): if has_escape_char is true this is the escaping character
 *                 used in the pattern, otherwise the parameter has no
 *                 meaning and should have the value NULL
 * compute_lower_bound(in): whether to compute the upper or the lower bound
 * last_safe_logical_pos(in): the last character that can be used for the
 *                             string in the predicate rewrite or a negative
 *                             value if that particular rewrite cannot be
 *                             performed.
 *
 * Note: See the comments on db_get_info_for_like_optimization for details
 *       on what this function computes.
 *
 * Note: If last_safe_logical_pos is negative the lower bound of the index
 *       scan is negative infinity (equivalent to the empty string or the
 *       string ' ' for the CHAR/VARCHAR default collation) and the upper
 *       bound is positive infinity (currently approximated by a string of
 *       one character code 255).
 */
int
db_get_like_optimization_bounds (const DB_VALUE * const pattern,
				 DB_VALUE * bound,
				 const bool has_escape_char,
				 const char *escape_str,
				 const bool compute_lower_bound,
				 const int last_safe_logical_pos)
{
  int error_code = NO_ERROR;
  const char *original = NULL;
  int original_size = 0;
  char *result = NULL;
  int result_length = 0;
  int result_size = 0;
  int i = 0;
  int alloc_size;
  int char_count;
  int collation_id;

  if (pattern == NULL || bound == NULL)
    {
      error_code = ER_OBJ_INVALID_ARGUMENTS;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_code, 0);
      goto error_exit;
    }

  assert (has_escape_char ^ (escape_str == NULL));

  if (DB_IS_NULL (pattern))
    {
      DB_MAKE_NULL (bound);
      goto fast_exit;
    }

  collation_id = DB_GET_STRING_COLLATION (pattern);

  if (!QSTR_IS_CHAR (DB_VALUE_DOMAIN_TYPE (pattern)))
    {
      error_code = ER_TP_CANT_COERCE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_code, 2,
	      pr_type_name (DB_VALUE_DOMAIN_TYPE (pattern)),
	      pr_type_name (DB_TYPE_VARCHAR));
      goto error_exit;
    }

  if (last_safe_logical_pos < 0)
    {
      if (compute_lower_bound)
	{
	  error_code =
	    db_value_domain_min (bound, DB_TYPE_VARCHAR,
				 DB_VALUE_PRECISION (pattern),
				 DB_VALUE_SCALE (pattern), collation_id);
	  if (error_code != NO_ERROR)
	    {
	      goto error_exit;
	    }
	}
      else
	{
	  error_code =
	    db_value_domain_max (bound, DB_TYPE_VARCHAR,
				 DB_VALUE_PRECISION (pattern),
				 DB_VALUE_SCALE (pattern), collation_id);
	  if (error_code != NO_ERROR)
	    {
	      goto error_exit;
	    }
	}

      goto fast_exit;
    }

  original = DB_PULL_STRING (pattern);
  original_size = DB_GET_STRING_SIZE (pattern);

  /* assume worst case scenario : all characters in output bound string are
   * stored on the maximum character size */
  intl_char_count ((unsigned char *) original, original_size, &char_count);
  alloc_size = LOC_MAX_UCA_CHARS_SEQ * char_count * INTL_CODESET_MULT;
  assert (alloc_size >= original_size);

  result = (char *) malloc (alloc_size + 1);
  if (result == NULL)
    {
      error_code = er_errid ();
      goto error_exit;
    }

  assert (last_safe_logical_pos < char_count);

  for (i = 0, result_length = 0, result_size = 0;
       result_length <= last_safe_logical_pos;)
    {
      char *crt_char_p = NULL;
      bool is_escaped = false;

      error_code =
	db_get_next_like_pattern_character (original, original_size,
					    has_escape_char, escape_str, &i,
					    &crt_char_p, &is_escaped);
      if (error_code != NO_ERROR)
	{
	  goto error_exit;
	}

      if (result_length == last_safe_logical_pos)
	{
	  assert (is_safe_last_char_for_like_optimization
		  (crt_char_p, is_escaped));
	}

      if (!is_escaped && *crt_char_p == LIKE_WILDCARD_MATCH_ONE)
	{
	  assert (result_length < last_safe_logical_pos);
	  if (compute_lower_bound)
	    {
	      result_size += intl_set_min_bound_chr (result + result_size);
	    }
	  else
	    {
	      result_size += intl_set_max_bound_chr (result + result_size);
	    }
	  result_length++;
	}
      else
	{
	  if (result_length == last_safe_logical_pos && !compute_lower_bound)
	    {
	      char *next_alpha_char_p = result + result_size;
	      int next_len = 0;

	      result_size +=
		QSTR_NEXT_ALPHA_CHAR (collation_id,
				      (unsigned char *) crt_char_p,
				      original + original_size - crt_char_p,
				      (unsigned char *) next_alpha_char_p,
				      &next_len);
	      result_length += next_len;
	    }
	  else
	    {
	      result_size += intl_put_char ((unsigned char *) result +
					    result_size,
					    (unsigned char *) crt_char_p);
	      result_length++;
	    }

	}
    }

  assert (result_size <= alloc_size);
  qstr_make_typed_string (DB_TYPE_VARCHAR, bound,
			  DB_VALUE_PRECISION (pattern), result, result_size,
			  collation_id);
  result[result_size] = 0;
  bound->need_clear = true;

fast_exit:
  return error_code;

error_exit:
  if (result != NULL)
    {
      free_and_init (result);
    }
  return error_code;
}

/*
 * db_compress_like_pattern () - Optimizes a LIKE pattern for faster execution
 *                               and easier processing.
 *
 * returns: NO_ERROR or error code
 *
 * pattern(in): the LIKE pattern to be compressed
 * compressed_pattern(out): the optimized pattern (should be cleared before
 *                          being passed to this function)
 * has_escape_char(in): whether the LIKE pattern can use an escape character
 * escape_str(in): if has_escape_char is true this is the escaping character
 *                 used in the pattern, otherwise the parameter has no
 *                 meaning and should have the value NULL
 *
 * Note: This function removes all the unnecessary escape characters in
 *       order to ease subsequent processing of the pattern. Currently there
 *       are no such unnecessary escape sequences, but there might be in the
 *       future if supporting MySQL semantics. See the comments in
 *       db_get_next_like_pattern_character.
 */
/* TODO This function could perform an extra optimization. The pattern
 *      'a%___%b' can be compressed to either 'a___%b' or 'a%___b'. The first
 *      form is prefferable as it should execute faster than the second.
 *      Also, if 'a%___b' is initially present, it can be changed to 'a___%b'.
 */
int
db_compress_like_pattern (const DB_VALUE * const pattern,
			  DB_VALUE * compressed_pattern,
			  const bool has_escape_char, const char *escape_str)
{
  int error_code = NO_ERROR;
  const char *original = NULL;
  int original_size = 0;
  char *result = NULL;
  int result_length = 0;
  int result_size = 0;
  int i = 0;
  int alloc_size;
  bool in_percent_sequence = false;

  if (pattern == NULL || compressed_pattern == NULL)
    {
      error_code = ER_OBJ_INVALID_ARGUMENTS;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_code, 0);
      goto error_exit;
    }

  assert (has_escape_char ^ (escape_str == NULL));

  if (DB_IS_NULL (pattern))
    {
      DB_MAKE_NULL (compressed_pattern);
      goto fast_exit;
    }

  if (!QSTR_IS_CHAR (DB_VALUE_DOMAIN_TYPE (pattern)))
    {
      error_code = ER_TP_CANT_COERCE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_code, 2,
	      pr_type_name (DB_VALUE_DOMAIN_TYPE (pattern)),
	      pr_type_name (DB_TYPE_VARCHAR));
      goto error_exit;
    }

  original = DB_PULL_STRING (pattern);
  original_size = DB_GET_STRING_SIZE (pattern);

  if (has_escape_char)
    {
      int char_count;

      intl_char_count ((unsigned char *) original, original_size,
		       &char_count);
      /* assume worst case : each character in the compressed pattern is
       * precedeed by the escape char */
      alloc_size = original_size + char_count * strlen (escape_str);
    }
  else
    {
      alloc_size = original_size;
    }

  result = (char *) malloc (alloc_size + 1);
  if (result == NULL)
    {
      error_code = er_errid ();
      goto error_exit;
    }

  for (i = 0, result_length = 0, result_size = 0, in_percent_sequence = false;
       i < original_size;)
    {
      char *crt_char_p = NULL;
      bool keep_crt_char = false;
      bool needs_escape = false;
      bool is_escaped = false;

      error_code =
	db_get_next_like_pattern_character (original, original_size,
					    has_escape_char,
					    escape_str, &i, &crt_char_p,
					    &is_escaped);
      if (error_code != NO_ERROR)
	{
	  goto error_exit;
	}

      if (is_escaped)
	{
	  needs_escape = true;
	}

      assert (crt_char_p != NULL);

      if (!is_escaped && *crt_char_p == LIKE_WILDCARD_MATCH_MANY &&
	  in_percent_sequence)
	{
	  keep_crt_char = false;
	}
      else
	{
	  keep_crt_char = true;
	}

      if (keep_crt_char)
	{
	  if (needs_escape)
	    {
	      assert (has_escape_char);
	      result_size += intl_put_char ((unsigned char *) result +
					    result_size,
					    (unsigned char *) escape_str);
	      result_length++;
	    }
	  result_size +=
	    intl_put_char ((unsigned char *) result + result_size,
			   (unsigned char *) crt_char_p);
	  result_length++;
	}

      if (!is_escaped && *crt_char_p == LIKE_WILDCARD_MATCH_MANY)
	{
	  in_percent_sequence = true;
	}
      else
	{
	  in_percent_sequence = false;
	}
    }

  assert (result_length <= alloc_size);
  result[result_size] = 0;
  DB_MAKE_VARCHAR (compressed_pattern, TP_FLOATING_PRECISION_VALUE,
		   result, result_size, DB_GET_STRING_COLLATION (pattern));
  compressed_pattern->need_clear = true;

fast_exit:
  return error_code;

error_exit:
  if (result != NULL)
    {
      free_and_init (result);
    }
  return error_code;
}

/*
 * db_like_bound () - Computes the bounding limits required for performing the
 *                    LIKE index optimization
 *
 * returns: NO_ERROR or error code
 *
 * src_pattern(in): the LIKE pattern
 * src_escape(in): the escape character or NULL if there is no escaping
 * result_bound(out): the computed upper or lower bound.
 * compute_lower_bound(in): whether to compute the upper or the lower bound
 *
 * Note: See the comments on db_get_info_for_like_optimization for details
 *       on what this function computes.
 */
int
db_like_bound (const DB_VALUE * src_pattern,
	       const DB_VALUE * src_escape,
	       DB_VALUE * const result_bound, const bool compute_lower_bound)
{
  int error_status = NO_ERROR;
  DB_VALUE tmp_pattern, tmp_escape;
  DB_TYPE pattern_type, escape_type;
  bool has_escape_char = false;
  DB_VALUE compressed_pattern;
  int num_logical_chars = 0;
  int last_safe_logical_pos = 0;
  int num_match_many = 0;
  int num_match_one = 0;
  const char *escape_str = NULL;

  assert (src_pattern != result_bound);
  assert (src_escape != result_bound);

  if (result_bound == NULL)
    {
      assert (false);		/* is impossible */
      return ER_FAILED;
    }

  DB_MAKE_NULL (&compressed_pattern);

  if (src_pattern == NULL || result_bound == NULL)
    {
      error_status = ER_OBJ_INVALID_ARGUMENTS;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      goto exit_on_error;
    }

  /* arg init tmp ***********************************************************
   */
  DB_MAKE_NULL_NARGS (2, &tmp_pattern, &tmp_escape);

  /* arg check null *********************************************************
   */
  if (DB_IS_NULL_NARGS (1, src_pattern))
    {
      DB_MAKE_NULL (result_bound);
      goto done;
    }

  /* arg cast type **********************************************************
   */
  pattern_type = DB_VALUE_DOMAIN_TYPE (src_pattern);

  if (!QSTR_IS_CHAR (pattern_type))
    {
      src_pattern =
	db_value_cast_arg (src_pattern, &tmp_pattern, DB_TYPE_VARCHAR,
			   &error_status);
    }

  if (error_status != NO_ERROR)
    {
      assert (er_errid () != NO_ERROR);
      goto exit_on_error;
    }

  if (src_escape == NULL)
    {
      has_escape_char = false;
    }
  else
    {
      if (DB_IS_NULL (src_escape))
	{
	  /* a LIKE b ESCAPE NULL means use the default escape character
	   * '\\' */
	  has_escape_char = true;
	  escape_str = "\\";
	}
      else
	{
	  escape_type = DB_VALUE_DOMAIN_TYPE (src_escape);

	  if (!QSTR_IS_CHAR (escape_type))
	    {
	      src_escape =
		db_value_cast_arg (src_escape, &tmp_escape, DB_TYPE_VARCHAR,
				   &error_status);
	    }

	  if (error_status != NO_ERROR)
	    {
	      assert (er_errid () != NO_ERROR);
	      goto exit_on_error;
	    }

	  escape_str = DB_PULL_STRING (src_escape);

	  if (DB_GET_STRING_LENGTH (src_escape) != 1 || escape_str[0] == 0)
	    {
	      error_status = ER_QSTR_INVALID_ESCAPE_CHARACTER;
	      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
	      goto exit_on_error;
	    }

	  has_escape_char = true;
	}
    }

  /* start main body ********************************************************
   */

  error_status = db_compress_like_pattern (src_pattern, &compressed_pattern,
					   has_escape_char, escape_str);
  if (error_status != NO_ERROR)
    {
      goto exit_on_error;
    }

  error_status =
    db_get_info_for_like_optimization (&compressed_pattern, has_escape_char,
				       escape_str, &num_logical_chars,
				       &last_safe_logical_pos,
				       &num_match_many, &num_match_one);
  if (error_status != NO_ERROR)
    {
      goto exit_on_error;
    }

  error_status =
    db_get_like_optimization_bounds (&compressed_pattern, result_bound,
				     has_escape_char, escape_str,
				     compute_lower_bound,
				     last_safe_logical_pos);
  if (error_status != NO_ERROR)
    {
      pr_clear_value (result_bound);
      goto exit_on_error;
    }

done:
  assert (error_status == NO_ERROR);

  pr_clear_value (&compressed_pattern);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (2, &tmp_pattern, &tmp_escape);

  return error_status;

exit_on_error:
  assert (error_status != NO_ERROR);

  if (er_errid () == NO_ERROR)
    {
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OBJ_INVALID_ARGUMENTS, 0);
    }

  DB_MAKE_NULL (result_bound);

  pr_clear_value (&compressed_pattern);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (2, &tmp_pattern, &tmp_escape);

  return error_status;
}

/*
 * db_hex() - return hexadecimal representation
 *  returns: error code or NO_ERROR
 *   param(in): parameter to turn to hex
 *   result(out): varchar db_value with hex representation
 *
 * Note:
 *  If param is a generic string, the hex representation will be the
 *  concatenation of hex values of each byte.
 *  If param is a generic numeric, the hex representation will be that of
 *  param casted to bigint (64bit unsigned integer). if value exceeds UINT64
 *  capacity, the return value is 'FFFFFFFFFFFFFFFF'.
 */
int
db_hex (const DB_VALUE * param, DB_VALUE * result)
{
  /* String length limits for numeric values of param. When param is numeric,
   * it will be cast to BIGINT db type and then internally to UINT64.
   * hex_lenght_limits[i] is the upper limit of the closed set of integers
   * that can be represented in hex on i digits. */
  const UINT64 hex_length_limits[UINT64_MAX_HEX_DIGITS + 1] = {
    0x0, 0xF, 0xFF, 0xFFF, 0xFFFF,
    0xFFFFF, 0xFFFFFF, 0xFFFFFFF,
    0xFFFFFFFF, 0xFFFFFFFFF,
    0xFFFFFFFFFF, 0xFFFFFFFFFFF,
    0xFFFFFFFFFFFF, 0xFFFFFFFFFFFFF,
    0xFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFF,
    0xFFFFFFFFFFFFFFFF
  };

  /* hex digits */
  const char hex_digit[] = "0123456789ABCDEF";

  /* other variables */
  DB_TYPE param_type = DB_TYPE_UNKNOWN;
  char *str = NULL, *hexval = NULL;
  int str_size = 0, hexval_len = 0, i = 0, error_code = NO_ERROR;

  assert (param != result);

  /* check parameters for NULL values */
  if (param == NULL || result == NULL)
    {
      error_code = ER_OBJ_INVALID_ARGUMENTS;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_code, 0);
      goto error;
    }

  if (DB_IS_NULL (param))
    {
      DB_MAKE_NULL (result);
      return NO_ERROR;
    }

  /* compute hex representation */
  param_type = DB_VALUE_DOMAIN_TYPE (param);

  if (TP_IS_CHAR_TYPE (param_type))
    {
      /* retrieve source string */
      str = DB_PULL_STRING (param);
      str_size = DB_GET_STRING_SIZE (param);

      /* allocate hex string */
      hexval_len = str_size * 2;
      hexval = (char *) malloc (hexval_len + 1);
      if (hexval == NULL)
	{
	  error_code = ER_OUT_OF_VIRTUAL_MEMORY;
	  goto error;
	}
      hexval[hexval_len] = 0;

      /* compute hex representation */
      for (i = 0; i < str_size; i++)
	{
	  hexval[i * 2] = hex_digit[(str[i] >> 4) & 0xF];
	  hexval[i * 2 + 1] = hex_digit[str[i] & 0xF];
	}

      /* set return string */
      DB_MAKE_STRING (result, hexval);
      result->need_clear = true;
    }
  else if (TP_IS_NUMERIC_TYPE (param_type))
    {
      DB_VALUE param_db_bigint;
      TP_DOMAIN *domain;
      UNUSED_VAR TP_DOMAIN *param_domain;
      UINT64 param_bigint;

      DB_MAKE_NULL (&param_db_bigint);

      /* try to convert to bigint */
      param_domain = tp_domain_resolve_default (param_type);
      domain = tp_domain_resolve_default (DB_TYPE_BIGINT);
      /* don't mind error code here, we need to know if param is
       * out of range */
      (void) tp_value_coerce (param, &param_db_bigint, domain);
      if (DB_IS_NULL (&param_db_bigint))
	{
	  /* param is out of range, set it to max */
	  param_bigint = hex_length_limits[UINT64_MAX_HEX_DIGITS];
	}
      else
	{
	  param_bigint = (UINT64) DB_GET_BIGINT (&param_db_bigint);
	}

      /* compute hex representation length */
      hexval_len = 1;
      while (hexval_len < UINT64_MAX_HEX_DIGITS
	     && param_bigint > hex_length_limits[hexval_len])
	{
	  hexval_len++;
	}

      /* allocate memory */
      hexval = (char *) malloc (hexval_len + 1);
      if (hexval == NULL)
	{
	  error_code = ER_OUT_OF_VIRTUAL_MEMORY;
	  goto error;
	}
      hexval[hexval_len] = 0;

      /* compute hex representation */
      for (i = hexval_len - 1; i >= 0; --i)
	{
	  hexval[i] = hex_digit[param_bigint & 0xF];
	  param_bigint >>= 4;
	}

      /* set return string */
      DB_MAKE_STRING (result, hexval);
      result->need_clear = true;
    }
  else
    {
      error_code = ER_OBJ_INVALID_ARGUMENTS;
      goto error;
    }

  /* all ok */
  return NO_ERROR;

error:
  if (result)
    {
      DB_MAKE_NULL (result);
    }

  if (er_errid () == NO_ERROR)
    {
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_code, 0);
    }

  return error_code;
}


/*
 * db_ascii() - return ASCII code of first character in string
 *  returns: error code or NO_ERROR
 *   param(in): string
 *   result(out): smallint db_value of ASCII code
 *
 * Note:
 *  If param is a zero-length string, result should be zero.
 *  If param is DB null, result should be DB null
 */
int
db_ascii (const DB_VALUE * param, DB_VALUE * result)
{
  int error_status = NO_ERROR;
  DB_VALUE tmp_param;
  char *str = NULL;
  int str_size = 0;

  assert (param != result);

  /* check parameters for NULL values */
  if (param == NULL || result == NULL)
    {
      error_status = ER_OBJ_INVALID_ARGUMENTS;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      return error_status;
    }

  /* arg init tmp ***********************************************************
   */
  DB_MAKE_NULL_NARGS (1, &tmp_param);

  /* arg check null *********************************************************
   */
  if (DB_IS_NULL_NARGS (1, param))
    {
      DB_MAKE_NULL (result);
      goto done;
    }

  /* arg cast type **********************************************************
   */

  param =
    db_value_cast_arg (param, &tmp_param, DB_TYPE_VARCHAR, &error_status);

  if (error_status != NO_ERROR)
    {
      assert (er_errid () != NO_ERROR);
      goto exit_on_error;
    }

  /* start main body ********************************************************
   */

  /* get ASCII value */

  /* get string and length */
  str = DB_PULL_STRING (param);
  str_size = DB_GET_STRING_SIZE (param);

  /* return first character */
  if (str_size > 0)
    {
      DB_MAKE_INT (result, (unsigned char) str[0]);	/* TODO - */
    }
  else
    {
      DB_MAKE_INT (result, 0);
    }

  if (error_status != NO_ERROR)
    {
      goto exit_on_error;
    }

done:
  assert (error_status == NO_ERROR);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (1, &tmp_param);

  return error_status;

exit_on_error:
  assert (error_status != NO_ERROR);

  if (er_errid () == NO_ERROR)
    {
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OBJ_INVALID_ARGUMENTS, 0);
    }

  DB_MAKE_NULL (result);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (1, &tmp_param);

  return error_status;
}

/*
 * db_conv() - convert number form one base to another
 *  returns: error code or NO_ERROR
 *   num(in): number to convert
 *   from_base(in): base of num
 *   to_base(in): base to convert num to
 *   result(out): string db_value with number in new base
 *
 * Note:
 *  From_base and to_base should satisfy 2 <= abs(base) <= 36
 */
int
db_conv (const DB_VALUE * num, const DB_VALUE * from_base,
	 const DB_VALUE * to_base, DB_VALUE * result)
{
  int error_status = NO_ERROR;
  DB_VALUE tmp_num, tmp_from_base, tmp_to_base;

  /* digit value lookup table vars */
  const unsigned char base_digits[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

  /* type checking vars */
  DB_TYPE num_type = DB_TYPE_UNKNOWN;

  /* sign flags */
  bool num_is_signed = false, res_is_signed = false;
  bool res_has_minus = false;

  /* string representations of input number and result; size of buffer is
     maximum computable value in base 2 (64 digits) + sign (1 digit) + NULL
     terminator (1 byte) */
  unsigned char num_str[UINT64_MAX_BIN_DIGITS + 2] = { 0 };
  unsigned char res_str[UINT64_MAX_BIN_DIGITS + 2] = { 0 };
  char *num_p_str = (char *) num_str, *res_p_str = NULL;
  unsigned char swap = 0;
  int res_size = 0;

  /* auxiliary variables */
  UINT64 base10 = 0;
  int from_base_int = 0, to_base_int = 0, i = 0;

  assert (num != result);
  assert (from_base != result);
  assert (to_base != result);

  /* check parameters for NULL values */
  if (num == NULL || from_base == NULL || to_base == NULL || result == NULL)
    {
      error_status = ER_OBJ_INVALID_ARGUMENTS;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      goto exit_on_error;
    }

  /* arg init tmp ***********************************************************
   */
  DB_MAKE_NULL_NARGS (3, &tmp_num, &tmp_from_base, &tmp_to_base);

  /* arg check null *********************************************************
   */
  if (DB_IS_NULL_NARGS (3, num, from_base, to_base))
    {
      DB_MAKE_NULL (result);
      goto done;
    }

  /* arg cast type **********************************************************
   */

  /* cast (num) *//* go ahead */

  from_base =
    db_value_cast_arg (from_base, &tmp_from_base, DB_TYPE_INTEGER,
		       &error_status);
  to_base =
    db_value_cast_arg (to_base, &tmp_to_base, DB_TYPE_INTEGER, &error_status);

  if (error_status != NO_ERROR)
    {
      assert (er_errid () != NO_ERROR);
      goto exit_on_error;
    }

  /* start main body ********************************************************
   */

  /* type checking; do not check num_type here, we will do it later on */
  num_type = DB_VALUE_DOMAIN_TYPE (num);

  /* from_base and to_base bounds checking */
  from_base_int = DB_GET_INT (from_base);
  to_base_int = DB_GET_INT (to_base);
  num_is_signed = (from_base_int < 0);
  res_is_signed = (to_base_int < 0);
  from_base_int = ABS (from_base_int);
  to_base_int = ABS (to_base_int);

  if (from_base_int < 2 || from_base_int > 36 || to_base_int < 2
      || to_base_int > 36)
    {
      DB_MAKE_NULL (result);
      goto done;
    }

  /* compute input number string from either generic NUMERIC or generic
     STRING types */
  if (TP_IS_NUMERIC_TYPE (num_type))
    {
      /* generic number -> string */
      switch (num_type)
	{
	case DB_TYPE_INTEGER:
	  snprintf (num_p_str, UINT64_MAX_BIN_DIGITS + 1, "%d",
		    DB_GET_INT (num));
	  break;

	case DB_TYPE_BIGINT:
	  snprintf (num_p_str, UINT64_MAX_BIN_DIGITS + 1, "%lld",
		    (long long int) DB_GET_BIGINT (num));
	  break;

	case DB_TYPE_NUMERIC:
	  num_p_str = numeric_db_value_print ((DB_VALUE *) num);
	  break;

	case DB_TYPE_DOUBLE:
	  snprintf (num_p_str, UINT64_MAX_BIN_DIGITS + 1, "%.0f",
		    DB_GET_DOUBLE (num));
	  break;

	default:
	  assert (false);	/* is impossible */
	  goto exit_on_error;
	  break;
	}
    }
  else if (TP_IS_CHAR_TYPE (num_type))
    {
      /* copy into a null-terminated string */
      int str_size = DB_GET_STRING_SIZE (num);

      if (str_size >= 0)
	{
	  str_size = MIN (str_size, sizeof (num_str) - 1);
	}
      else
	{
	  str_size = sizeof (num_str) - 1;
	}
      strncpy (num_str, DB_PULL_STRING (num), str_size);
      num_str[str_size] = '\0';
      num_p_str = num_str;
    }
  else
    {
      /* we cannot process the input in any way */
      error_status = ER_OBJ_INVALID_ARGUMENTS;
      goto exit_on_error;
    }

  /* convert from string to INT64/UINT64 */
  errno = 0;
  if (num_is_signed)
    {
      base10 = (UINT64) strtoll (num_p_str, NULL, from_base_int);
    }
  else
    {
      base10 = (UINT64) strtoull (num_p_str, NULL, from_base_int);
    }

  /* compute signed part of number */
  if (res_is_signed && base10 > DB_BIGINT_MAX)
    {
      /* result should be signed and we DO have a negative INT64; compute
         complement and remember to add minus sign to string */
      base10 = ~base10;
      ++base10;
      res_has_minus = true;
    }

  /* convert base 10 -> to_base */
  if (base10 == 0)
    {
      /* number is zero? display it as such */
      res_str[res_size++] = '0';
      res_has_minus = false;
    }

  while (base10 > 0)
    {
      /* convert another digit */
      res_str[res_size++] = base_digits[base10 % to_base_int];
      base10 /= to_base_int;
    }

  if (res_has_minus)
    {
      /* add minus sign to number string */
      res_str[res_size++] = '-';
    }

  /* reverse string (duh!) */
  res_str[res_size] = 0;
  for (i = 0; i < res_size / 2; i++)
    {
      swap = res_str[i];
      res_str[i] = res_str[res_size - i - 1];
      res_str[res_size - i - 1] = swap;
    }

  /* return string */
  res_p_str = (char *) malloc (res_size + 1);
  if (res_p_str == NULL)
    {
      error_status = ER_OUT_OF_VIRTUAL_MEMORY;
      goto exit_on_error;
    }

  memcpy (res_p_str, res_str, res_size);
  res_p_str[res_size] = '\0';
  DB_MAKE_STRING (result, res_p_str);

  result->need_clear = true;

  if (error_status != NO_ERROR)
    {
      pr_clear_value (result);
      goto exit_on_error;
    }

done:
  assert (error_status == NO_ERROR);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (3, &tmp_num, &tmp_from_base, &tmp_to_base);

  return error_status;

exit_on_error:
  assert (error_status != NO_ERROR);

  if (er_errid () == NO_ERROR)
    {
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OBJ_INVALID_ARGUMENTS, 0);
    }

  if (result)
    {
      DB_MAKE_NULL (result);
    }

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (3, &tmp_num, &tmp_from_base, &tmp_to_base);

  return error_status;
}

/*
 * db_inet_aton () - convert a string formatted IPv4 address
 *                    to a number formatted IPv4 address
 * Arguments:
 *  string (in)                 : source ip string
 *  result_numbered_ip (in/out) : result number
 *
 * Returns: int
 *	error code or NO_ERROR
 *
 * Errors:
 *      ER_OBJ_INVALID_ARGUMENTS
 *      ER_OPFUNC_INET_NTOA_ARG
 *      ER_OUT_OF_VIRTUAL_MEMORY
 *
 * Note: the ip "226.000.000.037" is 226.0.0.31, not 226.0.0.37
 *       support "0x3d.037.12.25" format
 */
int
db_inet_aton (DB_VALUE * result_numbered_ip, const DB_VALUE * string)
{
  int error_status = NO_ERROR;
  DB_VALUE tmp_string;
  DB_BIGINT numbered_ip = (DB_BIGINT) 0;
  char *ip_string = NULL;
  char *local_ipstring = NULL;
  char *local_ipslice = NULL;
  char *local_pivot = NULL;
  int slice = 0;
  int result = 0;
  const int ipsegmax = 256;
  DB_BIGINT ipbase;
  int slice_count = 0;
  int len;
  char *temp_tok;

  assert (result_numbered_ip != string);

  if (string == NULL || result_numbered_ip == NULL)
    {
      error_status = ER_OBJ_INVALID_ARGUMENTS;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      goto exit_on_error;
    }

  /* arg init tmp ***********************************************************
   */
  DB_MAKE_NULL_NARGS (1, &tmp_string);

  /* arg check null *********************************************************
   */
  if (DB_IS_NULL_NARGS (1, string))
    {
      DB_MAKE_NULL (result_numbered_ip);
      goto done;
    }

  /* arg cast type **********************************************************
   */
  string =
    db_value_cast_arg (string, &tmp_string, DB_TYPE_VARCHAR, &error_status);

  if (error_status != NO_ERROR)
    {
      assert (er_errid () != NO_ERROR);
      goto exit_on_error;
    }

  /* start main body ********************************************************
   */

  ip_string = DB_GET_STRING (string);
  if (ip_string == NULL)
    {
      assert (false);
      error_status = ER_OBJ_INVALID_ARGUMENTS;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      goto exit_on_error;
    }

  len = DB_GET_STRING_SIZE (string);
  local_ipstring = (char *) malloc (len + 1);
  if (local_ipstring == NULL)
    {
      error_status = ER_OUT_OF_VIRTUAL_MEMORY;
      goto exit_on_error;
    }

  memcpy (local_ipstring, ip_string, len);
  local_ipstring[len] = '\0';

  ipbase = (DB_BIGINT) ipsegmax *ipsegmax * ipsegmax;
  for (temp_tok = local_ipstring;; temp_tok = NULL)
    {
      /* use ". \t" to be more tolerable of input format. */
      local_ipslice = strtok_r (temp_tok, ". \t", &local_pivot);
      if (local_ipslice == NULL)
	{
	  break;
	}

      if (!is_valid_ip_slice (local_ipslice))
	{
	  error_status = ER_OPFUNC_INET_ATON_ARG;
	  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 1,
		  ip_string);
	  goto exit_on_error;
	}

      result = parse_int (&slice, local_ipslice, 0);
      if (result != 0 || slice < 0 || slice >= ipsegmax)
	{
	  error_status = ER_OPFUNC_INET_ATON_ARG;
	  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 1,
		  ip_string);
	  goto exit_on_error;
	}
      numbered_ip += slice * ipbase;
      ipbase /= ipsegmax;
      slice_count++;
    }
  if (numbered_ip < 0
      || numbered_ip > (DB_BIGINT) ipsegmax * ipsegmax * ipsegmax * ipsegmax
      || slice_count != 4)
    {
      error_status = ER_OPFUNC_INET_ATON_ARG;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 1, ip_string);
      goto exit_on_error;
    }

  free_and_init (local_ipstring);
  DB_MAKE_BIGINT (result_numbered_ip, numbered_ip);

  if (error_status != NO_ERROR)
    {
      goto exit_on_error;
    }

done:
  assert (error_status == NO_ERROR);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (1, &tmp_string);

  return error_status;

exit_on_error:
  assert (error_status != NO_ERROR);

  if (er_errid () == NO_ERROR)
    {
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OBJ_INVALID_ARGUMENTS, 0);
    }

  if (result_numbered_ip != NULL)
    {
      DB_MAKE_NULL (result_numbered_ip);
    }

  if (local_ipstring != NULL)
    {
      free_and_init (local_ipstring);
    }

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (1, &tmp_string);

  return error_status;
}

/*
 * db_inet_ntoa () - convert a number formatted IPv4 address
 *                    to a string formatted IPv4 address
 * Arguments:
 *  number (in)               : source numbered ip
 *  result_ip_string (in/out) : result ip string
 *
 * Returns: int
 *	error code or NO_ERROR
 *
 * Errors:
 *      ER_OBJ_INVALID_ARGUMENTS
 *      ER_OPFUNC_INET_NTOA_ARG
 *
 * Note:
 */
int
db_inet_ntoa (DB_VALUE * result_ip_string, const DB_VALUE * number)
{
  int error_status = NO_ERROR;
  DB_VALUE tmp_number;
  DB_BIGINT ip_number = 0;
  char ip_string[16] = { '\0' };
  char ip_seg_string[4] = { '\0' };
  const int ip_seg_string_cnt = 4;
  const DB_BIGINT ipmax = (DB_BIGINT) 256 * 256 * 256 * 256;
  const unsigned int ipv4_mask[] = { 0xFF000000, 0xFF0000, 0xFF00, 0xFF };
  const unsigned int ipfactor[] = { 256 * 256 * 256, 256 * 256, 256, 1 };
  unsigned int slice;
  int i;
  int ret_string_len;
  char *res_p_str;

  assert (result_ip_string != number);

  if (number == NULL || result_ip_string == NULL)
    {
      error_status = ER_OBJ_INVALID_ARGUMENTS;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      goto exit_on_error;
    }

  /* arg init tmp ***********************************************************
   */
  DB_MAKE_NULL_NARGS (1, &tmp_number);

  /* arg check null *********************************************************
   */
  if (DB_IS_NULL_NARGS (1, number))
    {
      DB_MAKE_NULL (result_ip_string);
      goto done;
    }

  /* arg cast type **********************************************************
   */
  number =
    db_value_cast_arg (number, &tmp_number, DB_TYPE_BIGINT, &error_status);

  if (error_status != NO_ERROR)
    {
      assert (er_errid () != NO_ERROR);
      goto exit_on_error;
    }

  /* start main body ********************************************************
   */

  ip_number = DB_GET_BIGINT (number);
  if (ip_number > ipmax || ip_number < 0)
    {
      error_status = ER_OPFUNC_INET_NTOA_ARG;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 1,
	      (long long int) ip_number);
      goto exit_on_error;
    }

  for (i = 0; i < 4; i++)
    {
      slice = (ip_number & ipv4_mask[i]) / ipfactor[i];
      snprintf (ip_seg_string, ip_seg_string_cnt, "%u", slice);
      ip_seg_string[ip_seg_string_cnt - 1] = '\0';
      /* safe to use strcat rather than strncat */
      strcat (ip_string, ip_seg_string);
      if (i != 3)
	{
	  strcat (ip_string, ".");
	}
    }

  /* return string */
  ret_string_len = strlen (ip_string);
  assert (ret_string_len < 16);
  res_p_str = (char *) malloc (ret_string_len + 1);
  if (res_p_str == NULL)
    {
      error_status = ER_OUT_OF_VIRTUAL_MEMORY;
      goto exit_on_error;
    }

  memcpy (res_p_str, ip_string, ret_string_len);
  res_p_str[ret_string_len] = '\0';
  DB_MAKE_STRING (result_ip_string, res_p_str);
  result_ip_string->need_clear = true;

  if (error_status != NO_ERROR)
    {
      goto exit_on_error;
    }

done:
  assert (error_status == NO_ERROR);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (1, &tmp_number);

  return error_status;

exit_on_error:
  assert (error_status != NO_ERROR);

  if (er_errid () == NO_ERROR)
    {
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OBJ_INVALID_ARGUMENTS, 0);
    }

  if (result_ip_string != NULL)
    {
      DB_MAKE_NULL (result_ip_string);
    }

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (1, &tmp_number);

  return error_status;
}

/*
 * is_valid_ip_slice () - check whether ip slice is valid
 *
 * Arguments:
 *  ipslice (in) : IP slice
 *
 * Returns: true or false
 */
static bool
is_valid_ip_slice (const char *ipslice)
{
  int pos = 0;
  int base_type = 10;		/* base type can be 8(oct), 10(dec), 16(hex) */

  assert (ipslice != NULL);
  if (ipslice[0] == '\0')
    {
      return false;
    }

  if (ipslice[0] == '0')
    {
      if (char_tolower (ipslice[1]) == 'x')
	{
	  if (ipslice[2] == '\0')
	    {
	      return false;
	    }
	  base_type = 16;
	  pos = 2;
	}
      else if (ipslice[1] != '\0')
	{
	  base_type = 8;
	  pos = 1;
	}
    }

  while (ipslice[pos] != '\0')
    {
      if (base_type == 10)
	{
	  if (!char_isdigit (ipslice[pos]))
	    {
	      return false;
	    }
	}
      else if (base_type == 8)
	{
	  if (!('0' <= ipslice[pos] && ipslice[pos] <= '7'))
	    {
	      return false;
	    }
	}
      else
	{			/* base_type = 16 */
	  if (!char_isxdigit (ipslice[pos]))
	    {
	      return false;
	    }
	}
      pos++;
    }

  return true;
}

/*
 * db_string_index_prefix () -
 */
int
db_string_index_prefix (const DB_VALUE * string1,
			const DB_VALUE * string2,
			const DB_VALUE * index_type, DB_VALUE * prefix_index)
{
  int error_status = NO_ERROR;
  bool is_desc = false;

  assert (string1 != (DB_VALUE *) NULL);
  assert (string2 != (DB_VALUE *) NULL);
  assert (index_type != (DB_VALUE *) NULL);
  assert (string1 != prefix_index);
  assert (string2 != prefix_index);
  assert (index_type != prefix_index);

  if (DB_IS_NULL (string1) || DB_IS_NULL (string2) || DB_IS_NULL (index_type))
    {
      error_status =
	db_value_domain_init (prefix_index, DB_TYPE_VARCHAR,
			      DB_DEFAULT_PRECISION, DB_DEFAULT_SCALE);
      return error_status;
    }

  if (!QSTR_IS_CHAR (DB_VALUE_DOMAIN_TYPE (string1))
      || !QSTR_IS_CHAR (DB_VALUE_DOMAIN_TYPE (string2))
      || !is_char_string (index_type))
    {
      error_status = ER_OBJ_INVALID_ARGUMENTS;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      return error_status;
    }

  if ((qstr_get_category (string1) != qstr_get_category (string2)))
    {
      error_status = ER_QSTR_INCOMPATIBLE_CODE_SETS;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      return error_status;
    }

  if (strncasecmp (DB_PULL_STRING (index_type), "d", 1) == 0)
    {
      is_desc = true;
    }

  error_status =
    db_string_unique_prefix (string1, string2, (const bool) is_desc,
			     prefix_index);

  return error_status;
}

/*
 *  db_string_to_base64 () - Using base64 to encode arbitrary input
 *   return: int(NO_ERROR if successful, other error status if fail)
 *   src(in):       source which holds plain-text string
 *   result(in/out): dest which holds encoded buffer
 *
 *   Note: handling of special cases:
 *         1. source string is NULL, result is NULL
 *         2. source string is empty string, result is empty string
 */
int
db_string_to_base64 (DB_VALUE const *src, DB_VALUE * result)
{
  int error_status = NO_ERROR;
  DB_VALUE tmp_src;
  int encode_len, src_len;
  const unsigned char *src_buf = NULL;
  unsigned char *encode_buf = NULL;

  assert (src != (DB_VALUE *) NULL);
  assert (result != (DB_VALUE *) NULL);
  assert (src != result);

  /* arg init tmp ***********************************************************
   */
  DB_MAKE_NULL_NARGS (1, &tmp_src);

  /* arg check null *********************************************************
   */
  if (DB_IS_NULL_NARGS (1, src))
    {
      DB_MAKE_NULL (result);
      goto done;
    }

  /* arg cast type **********************************************************
   */
  src = db_value_cast_arg (src, &tmp_src, DB_TYPE_VARCHAR, &error_status);

  if (error_status != NO_ERROR)
    {
      assert (er_errid () != NO_ERROR);
      goto exit_on_error;
    }

  /* start main body ********************************************************
   */

  src_buf = (const unsigned char *) DB_PULL_STRING (src);

  /* length in bytes */
  src_len = DB_GET_STRING_SIZE (src);

  assert (src_len >= 0);

  /* if input is empty string, output is also empty string */
  if (src_len == 0)
    {
      db_string_make_empty_typed_string (NULL, result, DB_TYPE_VARCHAR, 0,
					 DB_GET_STRING_COLLATION (src));
      goto done;
    }

  /* currently base64_encode always returns NO_ERROR except
   * for memory buffer allocation fail */
  error_status = base64_encode (src_buf, src_len, &encode_buf, &encode_len);

  if (error_status == NO_ERROR)
    {
      qstr_make_typed_string (DB_TYPE_VARCHAR, result, encode_len,
			      (const DB_C_VARCHAR) encode_buf, encode_len,
			      DB_GET_STRING_COLLATION (src));

      result->need_clear = true;
    }

  if (error_status != NO_ERROR)
    {
      pr_clear_value (result);
      goto exit_on_error;
    }

done:
  assert (error_status == NO_ERROR);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (1, &tmp_src);

  return error_status;

exit_on_error:
  assert (error_status != NO_ERROR);

  if (er_errid () == NO_ERROR)
    {
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OBJ_INVALID_ARGUMENTS, 0);
    }

  DB_MAKE_NULL (result);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (1, &tmp_src);

  return error_status;
}

/*
 *  db_string_from_base64 () - Convert a buffer into plain-text by base64 decoding
 *                             There is no assumption the input is base64 encoded,
 *                             in this case, result is NULL
 *   return:   int(NO_ERROR if successful, other error status if fail)
 *   src(in):       source which holds encoded buffer
 *   result(in/out): dest which holds plain-text string
 *
 *   Note: handling of special cases:
 *         1. source string is NULL, result is NULL
 *         2. source string is empty string, result is empty string
 *         3. source string contains invalid base64 encoded character,
 *            result is NULL
 *         4. source string has insufficient length even some bytes have been
 *            decoded, result is NULL
 */
int
db_string_from_base64 (DB_VALUE const *src, DB_VALUE * result)
{
  int error_status = NO_ERROR;
  DB_VALUE tmp_src;
  int err, decode_len, src_len;
  const unsigned char *src_buf = NULL;
  unsigned char *decode_buf = NULL;

  assert (src != (DB_VALUE *) NULL);
  assert (result != (DB_VALUE *) NULL);
  assert (src != result);

  /* arg init tmp ***********************************************************
   */
  DB_MAKE_NULL_NARGS (1, &tmp_src);

  /* arg check null *********************************************************
   */
  if (DB_IS_NULL_NARGS (1, src))
    {
      DB_MAKE_NULL (result);
      goto done;
    }

  /* arg cast type **********************************************************
   */
  src = db_value_cast_arg (src, &tmp_src, DB_TYPE_VARCHAR, &error_status);

  if (error_status != NO_ERROR)
    {
      assert (er_errid () != NO_ERROR);
      goto exit_on_error;
    }

  /* start main body ********************************************************
   */

  src_buf = (const unsigned char *) DB_PULL_STRING (src);

  /* length in bytes */
  src_len = DB_GET_STRING_SIZE (src);

  assert (src_len >= 0);

  /* source is empty string */
  if (src_len == 0)
    {
      db_string_make_empty_typed_string (NULL, result, DB_TYPE_VARCHAR, 0,
					 DB_GET_STRING_COLLATION (src));
      goto done;
    }


  err = base64_decode (src_buf, src_len, &decode_buf, &decode_len);

  switch (err)
    {
    case BASE64_EMPTY_INPUT:
      db_string_make_empty_typed_string (NULL, result, DB_TYPE_VARCHAR, 0,
					 DB_GET_STRING_COLLATION (src));
      break;

    case NO_ERROR:
      qstr_make_typed_string (DB_TYPE_VARCHAR, result, decode_len,
			      (const DB_C_VARCHAR) decode_buf, decode_len,
			      (const int) DB_GET_STRING_COLLATION (src));
      result->need_clear = true;
      break;

    case BASE64_INVALID_INPUT:
      error_status = ER_QSTR_INVALID_FORMAT;	/* reset error code */
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, error_status, 0);
      goto exit_on_error;

    default:
      assert (er_errid () != NO_ERROR);
      error_status = err;
      goto exit_on_error;
    }

  if (error_status != NO_ERROR)
    {
      pr_clear_value (result);
      goto exit_on_error;
    }

done:
  assert (error_status == NO_ERROR);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (1, &tmp_src);

  return error_status;

exit_on_error:
  assert (error_status != NO_ERROR);

  if (er_errid () == NO_ERROR)
    {
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OBJ_INVALID_ARGUMENTS, 0);
    }

  DB_MAKE_NULL (result);

  /* arg clear tmp **********************************************************
   */
  db_value_clear_nargs (1, &tmp_src);

  return error_status;
}

/*
 *  db_value_cast_arg () - Coerce a value into one of another domain.
 *   return:   coerced value
 *   src(in): source which holds encoded buffer
 *   dest(out): dest DB_VALUE
 *   desired_type(in):
 *   errorp(out): error status
 *
 *   Note:
 */
DB_VALUE *
db_value_cast_arg (DB_VALUE const *src, DB_VALUE * dest, DB_TYPE desired_type,
		   int *errorp)
{
  DB_TYPE src_type;

  assert (src != NULL);
  assert (dest != NULL);
  assert (src != dest);

  DB_MAKE_NULL (dest);		/* init */

  if (*errorp != NO_ERROR)
    {
      return (DB_VALUE *) src;	/* give up */
    }

  src_type = DB_VALUE_TYPE (src);
  if (src_type == DB_TYPE_NULL || src_type == desired_type)
    {
      return (DB_VALUE *) src;	/* OK */
    }

  if (tp_value_coerce (src, dest,
		       db_type_to_db_domain (desired_type)) !=
      DOMAIN_COMPATIBLE)
    {
      *errorp = ER_TP_CANT_COERCE;
      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, *errorp, 2,
	      pr_type_name (src_type), pr_type_name (desired_type));

      return (DB_VALUE *) src;
    }

  /* everything is OK */

  return dest;
}
